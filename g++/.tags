!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ALLOC_BUF	.\libioP.h	502;"	d
ALLOC_BUF	.\libioP.h	515;"	d
BUFSIZ	.\iostdio.h	42;"	d
Bbase	.\streambuf.h	/^    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }$/;"	f	struct:streambuf
Bptr	.\streambuf.h	/^    char *Bptr() { return _IO_backup_base; }$/;"	f	struct:streambuf
CAlloc	.\stl_rope.h	/^    	typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	class:rope
CAlloc	.\stl_rope.h	/^    typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	struct:__rope_RopeBase
CHECK_FILE	.\libioP.h	634;"	d
CHECK_FILE	.\libioP.h	640;"	d
COERCE_FILE	.\libioP.h	619;"	d
COERCE_FILE	.\libioP.h	622;"	d
CharReader	.\parsestream.h	/^typedef char *(*CharReader)(void *arg);$/;"	t
DEFALLOC_H	.\defalloc.h	26;"	d
DataAlloc	.\stl_rope.h	/^    	typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	class:rope
DataAlloc	.\stl_rope.h	/^    typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	struct:__rope_RopeBase
EOF	.\iostdio.h	39;"	d
EOF	.\libio.h	83;"	d
EOF	.\libioP.h	456;"	d
EOF	.\streambuf.h	47;"	d
FAlloc	.\stl_rope.h	/^    	typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	class:rope
FAlloc	.\stl_rope.h	/^    typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	struct:__rope_RopeBase
FILE	.\iostdio.h	/^typedef _IO_FILE FILE;$/;"	t
FILEBUF_LITERAL	.\libioP.h	575;"	d
FILEBUF_LITERAL	.\libioP.h	581;"	d
FREELIST_INDEX	.\stl_alloc.h	/^  static  size_t FREELIST_INDEX(size_t bytes) {$/;"	f	class:__default_alloc_template
FREE_BUF	.\libioP.h	500;"	d
FREE_BUF	.\libioP.h	513;"	d
Gbase	.\streambuf.h	/^    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }$/;"	f	struct:streambuf
Init	.\streambuf.h	/^      Init () { }$/;"	f	class:ios::Init
Init	.\streambuf.h	/^    class Init {$/;"	c	class:ios
Iostream_init	.\iostream.h	/^struct Iostream_init { } ;  \/\/ Compatibility hack for AT&T library.$/;"	s
JUMP0	.\libioP.h	74;"	d
JUMP0	.\libioP.h	83;"	d
JUMP1	.\libioP.h	75;"	d
JUMP1	.\libioP.h	84;"	d
JUMP2	.\libioP.h	76;"	d
JUMP2	.\libioP.h	85;"	d
JUMP3	.\libioP.h	77;"	d
JUMP3	.\libioP.h	86;"	d
JUMP_FIELD	.\libioP.h	73;"	d
JUMP_FIELD	.\libioP.h	82;"	d
JUMP_INIT	.\libioP.h	78;"	d
JUMP_INIT	.\libioP.h	87;"	d
JUMP_INIT_DUMMY	.\libioP.h	79;"	d
JUMP_INIT_DUMMY	.\libioP.h	88;"	d
LAlloc	.\stl_rope.h	/^    	typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	class:rope
LAlloc	.\stl_rope.h	/^    typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	struct:__rope_RopeBase
LENGTHERROR	.\std\bastring.h	53;"	d
LENGTHERROR	.\std\bastring.h	60;"	d
MAP_ANONYMOUS	.\libioP.h	479;"	d
MAXEXP	.\floatio.h	49;"	d
MAXFRACT	.\floatio.h	51;"	d
MAYBE_SET_EINVAL	.\libioP.h	628;"	d
MAYBE_SET_EINVAL	.\libioP.h	630;"	d
NULL	.\libio.h	88;"	d
NULL	.\libio.h	91;"	d
NULL	.\libio.h	93;"	d
NULL	.\libioP.h	461;"	d
NULL	.\libioP.h	464;"	d
NULL	.\libioP.h	466;"	d
NULL	.\streambuf.h	51;"	d
NULL	.\streambuf.h	53;"	d
Nbase	.\streambuf.h	/^    char *Nbase() { return _IO_save_base; }$/;"	f	struct:streambuf
OS_FSTAT	.\libioP.h	525;"	d
OUTOFRANGE	.\std\bastring.h	51;"	d
OUTOFRANGE	.\std\bastring.h	59;"	d
PARSESTREAM_H	.\parsestream.h	28;"	d
PlotFile	.\PlotFile.h	/^  PlotFile() : ofstream() { }$/;"	f	class:PlotFile
PlotFile	.\PlotFile.h	/^  PlotFile(const char *name, int mode=ios::out, int prot=0664)$/;"	f	class:PlotFile
PlotFile	.\PlotFile.h	/^  PlotFile(int fd) : ofstream(fd) { }$/;"	f	class:PlotFile
PlotFile	.\PlotFile.h	/^class PlotFile : public ofstream$/;"	c
ROUND_TO_PAGE	.\libioP.h	497;"	d
ROUND_UP	.\stl_alloc.h	/^  static size_t ROUND_UP(size_t bytes) {$/;"	f	class:__default_alloc_template
Rep	.\std\bastring.h	/^  struct Rep {$/;"	s	class:basic_string
RopeBase	.\stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:rope
RopeBase	.\stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_charT_ref_proxy
RopeBase	.\stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_iterator_base
RopeConcatenation	.\stl_rope.h	/^	typedef __rope_RopeConcatenation<charT,Alloc> RopeConcatenation;$/;"	t	class:rope
RopeFunction	.\stl_rope.h	/^	typedef __rope_RopeFunction<charT,Alloc> RopeFunction;$/;"	t	class:rope
RopeFunction_from_fn	.\ropeimpl.h	/^rope<charT,Alloc>::RopeFunction_from_fn$/;"	f	class:rope
RopeLeaf	.\stl_rope.h	/^	typedef __rope_RopeLeaf<charT,Alloc> RopeLeaf;$/;"	t	class:rope
RopeLeaf_from_char_ptr	.\ropeimpl.h	/^rope<charT,Alloc>::RopeLeaf_from_char_ptr(__GC_CONST charT *s, size_t size)$/;"	f	class:rope
RopeLeaf_from_unowned_char_ptr	.\stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,$/;"	f	class:rope
RopeSubstring	.\stl_rope.h	/^	typedef __rope_RopeSubstring<charT,Alloc> RopeSubstring;$/;"	t	class:rope
S	.\stl_function.h	/^  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t
S	.\stl_function.h	/^  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t
S	.\stl_function.h	/^  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t
S	.\stl_function.h	/^  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t
S	.\stl_function.h	/^  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t
S	.\stl_function.h	/^  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t
S	.\stl_function.h	/^  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t
S	.\stl_function.h	/^  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t
S	.\stl_function.h	/^inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {$/;"	f
S	.\stl_function.h	/^inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {$/;"	f
S	.\stl_function.h	/^inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {$/;"	f
S	.\stl_function.h	/^inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {$/;"	f
S	.\stl_function.h	/^inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { $/;"	f
S	.\stl_function.h	/^inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { $/;"	f
S	.\stl_function.h	/^inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { $/;"	f
S	.\stl_function.h	/^inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { $/;"	f
SAlloc	.\stl_rope.h	/^    	typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	class:rope
SAlloc	.\stl_rope.h	/^    typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	struct:__rope_RopeBase
SEEK_CUR	.\iostdio.h	52;"	d
SEEK_END	.\iostdio.h	53;"	d
SEEK_SET	.\iostdio.h	51;"	d
SFile	.\SFile.h	/^    SFile() : fstream() { }$/;"	f	class:SFile
SFile	.\SFile.h	/^class SFile: public fstream$/;"	c
VTABLE_LABEL	.\libioP.h	590;"	d
VTABLE_LABEL	.\libioP.h	593;"	d
WS	.\stream.h	/^inline istream& WS(istream& str) { return ws(str); }$/;"	f
_BUILTINBUF_H	.\builtinbuf.h	26;"	d
_COMPAT_STREAM_H	.\stream.h	26;"	d
_EDITBUF_H	.\editbuf.h	28;"	d
_FSTREAM_H	.\fstream.h	26;"	d
_G_HAVE_MMAP	.\libioP.h	483;"	d
_G_HAVE_MMAP	.\libioP.h	484;"	d
_INDSTREAM_H	.\indstream.h	28;"	d
_IOFBF	.\iostdio.h	47;"	d
_IOLBF	.\iostdio.h	48;"	d
_IOMANIP_H	.\iomanip.h	29;"	d
_IONBF	.\iostdio.h	49;"	d
_IOSTDIO_H	.\iostdio.h	33;"	d
_IOSTREAM_H	.\iostream.h	29;"	d
_IOS_APPEND	.\libio.h	101;"	d
_IOS_ATEND	.\libio.h	100;"	d
_IOS_BAD	.\streambuf.h	102;"	d
_IOS_BIN	.\libio.h	105;"	d
_IOS_EOF	.\streambuf.h	100;"	d
_IOS_FAIL	.\streambuf.h	101;"	d
_IOS_GOOD	.\streambuf.h	99;"	d
_IOS_INPUT	.\libio.h	98;"	d
_IOS_NOCREATE	.\libio.h	103;"	d
_IOS_NOREPLACE	.\libio.h	104;"	d
_IOS_OUTPUT	.\libio.h	99;"	d
_IOS_TRUNC	.\libio.h	102;"	d
_IO_APPEND	.\streambuf.h	107;"	d
_IO_ATEND	.\streambuf.h	106;"	d
_IO_BAD_SEEN	.\libio.h	130;"	d
_IO_BIN	.\streambuf.h	111;"	d
_IO_BOOLALPHA	.\libio.h	149;"	d
_IO_BUFSIZ	.\libio.h	40;"	d
_IO_CHAR_TYPE	.\libioP.h	243;"	d
_IO_CURRENTLY_PUTTING	.\libio.h	127;"	d
_IO_DEC	.\libio.h	137;"	d
_IO_DELETE_DONT_CLOSE	.\libio.h	122;"	d
_IO_DOALLOCATE	.\libioP.h	177;"	d
_IO_DONT_CLOSE	.\libio.h	148;"	d
_IO_EOF_SEEN	.\libio.h	120;"	d
_IO_ERR_SEEN	.\libio.h	121;"	d
_IO_FILE	.\libio.h	/^struct _IO_FILE {$/;"	s
_IO_FILE	.\libio.h	/^typedef struct _IO_FILE _IO_FILE;$/;"	t	typeref:struct:_IO_FILE
_IO_FILE_plus	.\libioP.h	/^struct _IO_FILE_plus$/;"	s
_IO_FINISH	.\libioP.h	95;"	d
_IO_FIXED	.\libio.h	145;"	d
_IO_HAVE_ST_BLKSIZE	.\libio.h	39;"	d
_IO_HAVE_SYS_WAIT	.\libio.h	38;"	d
_IO_HEX	.\libio.h	139;"	d
_IO_IMBUE	.\libioP.h	239;"	d
_IO_INPUT	.\streambuf.h	104;"	d
_IO_INTERNAL	.\libio.h	136;"	d
_IO_INT_TYPE	.\libioP.h	244;"	d
_IO_IN_BACKUP	.\libio.h	124;"	d
_IO_IS_APPENDING	.\libio.h	128;"	d
_IO_IS_FILEBUF	.\libio.h	129;"	d
_IO_JUMPS	.\libioP.h	71;"	d
_IO_LEFT	.\libio.h	134;"	d
_IO_LINE_BUF	.\libio.h	125;"	d
_IO_LINKED	.\libio.h	123;"	d
_IO_LOCK_T	.\libio.h	162;"	d
_IO_LOCK_T	.\libio.h	169;"	d
_IO_LOCK_T	.\libio.h	173;"	d
_IO_MAGIC	.\libio.h	113;"	d
_IO_MAGIC_MASK	.\libio.h	115;"	d
_IO_NEW_STREAMS	.\streambuf.h	33;"	d
_IO_NOCREATE	.\streambuf.h	109;"	d
_IO_NOREPLACE	.\streambuf.h	110;"	d
_IO_NO_READS	.\libio.h	118;"	d
_IO_NO_WRITES	.\libio.h	119;"	d
_IO_OCT	.\libio.h	138;"	d
_IO_OUTPUT	.\streambuf.h	105;"	d
_IO_OVERFLOW	.\libioP.h	101;"	d
_IO_PBACKFAIL	.\libioP.h	120;"	d
_IO_PENDING_OUTPUT_COUNT	.\libio.h	318;"	d
_IO_RIGHT	.\libio.h	135;"	d
_IO_SCIENTIFIC	.\libio.h	144;"	d
_IO_SEEKOFF	.\libioP.h	148;"	d
_IO_SEEKPOS	.\libioP.h	160;"	d
_IO_SETBUF	.\libioP.h	165;"	d
_IO_SHOWBASE	.\libio.h	140;"	d
_IO_SHOWMANYC	.\libioP.h	234;"	d
_IO_SHOWPOINT	.\libio.h	141;"	d
_IO_SHOWPOS	.\libio.h	143;"	d
_IO_SKIPWS	.\libio.h	133;"	d
_IO_STDIO	.\libio.h	147;"	d
_IO_STDIO_H	.\libio.h	28;"	d
_IO_STR_DYNAMIC	.\strfile.h	59;"	d
_IO_STR_FROZEN	.\strfile.h	63;"	d
_IO_SYNC	.\libioP.h	171;"	d
_IO_SYSCLOSE	.\libioP.h	220;"	d
_IO_SYSREAD	.\libioP.h	195;"	d
_IO_SYSSEEK	.\libioP.h	213;"	d
_IO_SYSSTAT	.\libioP.h	227;"	d
_IO_SYSWRITE	.\libioP.h	202;"	d
_IO_TIED_PUT_GET	.\libio.h	126;"	d
_IO_TRUNC	.\streambuf.h	108;"	d
_IO_UFLOW	.\libioP.h	115;"	d
_IO_UNBUFFERED	.\libio.h	117;"	d
_IO_UNDERFLOW	.\libioP.h	108;"	d
_IO_UNIFIED_JUMPTABLES	.\libio.h	77;"	d
_IO_UNITBUF	.\libio.h	146;"	d
_IO_UPPERCASE	.\libio.h	142;"	d
_IO_USER_BUF	.\libio.h	116;"	d
_IO_USE_DTOA	.\libio.h	79;"	d
_IO_XSGETN	.\libioP.h	134;"	d
_IO_XSPUTN	.\libioP.h	127;"	d
_IO_alloc_type	.\strfile.h	/^typedef void *(*_IO_alloc_type) __P ((_IO_size_t));$/;"	t
_IO_backup_base	.\libio.h	/^  char *_IO_backup_base;  \/* Pointer to first valid character of backup area *\/$/;"	m	struct:_IO_FILE
_IO_blen	.\libioP.h	378;"	d
_IO_buf_base	.\libio.h	/^  char* _IO_buf_base;	\/* Start of reserve area. *\/$/;"	m	struct:_IO_FILE
_IO_buf_end	.\libio.h	/^  char* _IO_buf_end;	\/* End of reserve area. *\/$/;"	m	struct:_IO_FILE
_IO_cleanup_region_end	.\libio.h	333;"	d
_IO_cleanup_region_start	.\libio.h	332;"	d
_IO_clearerr	.\iolibio.h	43;"	d
_IO_close_t	.\libioP.h	/^typedef int (*_IO_close_t) __P ((_IO_FILE *)); \/* finalize *\/$/;"	t
_IO_cookie_file	.\libio.h	/^struct _IO_cookie_file$/;"	s
_IO_cookie_io_functions_t	.\libio.h	/^} _IO_cookie_io_functions_t;$/;"	t	typeref:struct:__anon1
_IO_default_close	.\libioP.h	354;"	d
_IO_do_flush	.\libioP.h	365;"	d
_IO_doallocate_t	.\libioP.h	/^typedef int (*_IO_doallocate_t) __P ((_IO_FILE *));$/;"	t
_IO_feof_unlocked	.\libio.h	307;"	d
_IO_ferror_unlocked	.\libio.h	308;"	d
_IO_file_flags	.\libio.h	204;"	d
_IO_file_is_open	.\libioP.h	396;"	d
_IO_fileno	.\iolibio.h	55;"	d
_IO_finish_t	.\libioP.h	/^typedef void (*_IO_finish_t) __P ((_IO_FILE *, int)); \/* finalize *\/$/;"	t
_IO_flockfile	.\libio.h	329;"	d
_IO_fpos64_t	.\libio.h	43;"	d
_IO_fpos_t	.\libio.h	32;"	d
_IO_free_type	.\strfile.h	/^typedef void (*_IO_free_type) __P ((void*));$/;"	t
_IO_freopen	.\iolibio.h	49;"	d
_IO_freopen	.\iolibio.h	52;"	d
_IO_fseek	.\iolibio.h	44;"	d
_IO_ftrylockfile	.\libio.h	331;"	d
_IO_funlockfile	.\libio.h	330;"	d
_IO_getc_unlocked	.\libio.h	294;"	d
_IO_have_backup	.\libioP.h	375;"	d
_IO_have_markers	.\libioP.h	377;"	d
_IO_imbue_t	.\libioP.h	/^typedef void (*_IO_imbue_t) __P ((_IO_FILE *, void *));$/;"	t
_IO_in_backup	.\libioP.h	376;"	d
_IO_in_put_mode	.\libioP.h	368;"	d
_IO_istream_withassign	.\iostream.h	/^class _IO_istream_withassign : public istream {$/;"	c
_IO_jump_t	.\libioP.h	/^struct _IO_jump_t$/;"	s
_IO_lock_t	.\libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	s
_IO_lock_t	.\libio.h	/^    typedef void _IO_lock_t;$/;"	t
_IO_lock_t	.\libio.h	/^   typedef void _IO_lock_t;$/;"	t
_IO_marker	.\libio.h	/^struct _IO_marker {$/;"	s
_IO_mask_flags	.\libioP.h	369;"	d
_IO_off64_t	.\libio.h	44;"	d
_IO_off_t	.\libio.h	35;"	d
_IO_ostream_withassign	.\iostream.h	/^class _IO_ostream_withassign : public ostream {$/;"	c
_IO_overflow_t	.\libioP.h	/^typedef int (*_IO_overflow_t) __P ((_IO_FILE *, int));$/;"	t
_IO_pbackfail_t	.\libioP.h	/^typedef int (*_IO_pbackfail_t) __P ((_IO_FILE *, int));$/;"	t
_IO_pclose	.\iolibio.h	57;"	d
_IO_peekc	.\libio.h	326;"	d
_IO_peekc	.\libio.h	328;"	d
_IO_peekc_unlocked	.\libio.h	297;"	d
_IO_pid_t	.\libio.h	36;"	d
_IO_pos_0	.\libioP.h	563;"	d
_IO_pos_0	.\libioP.h	565;"	d
_IO_pos_BAD	.\iolibio.h	41;"	d
_IO_pos_BAD	.\libioP.h	543;"	d
_IO_pos_BAD	.\libioP.h	545;"	d
_IO_pos_adjust	.\libioP.h	558;"	d
_IO_pos_as_off	.\libioP.h	551;"	d
_IO_pos_as_off	.\libioP.h	553;"	d
_IO_pos_t	.\libio.h	31;"	d
_IO_putc_unlocked	.\libio.h	302;"	d
_IO_read_base	.\libio.h	/^  char* _IO_read_base;	\/* Start of putback+get area. *\/$/;"	m	struct:_IO_FILE
_IO_read_end	.\libio.h	/^  char* _IO_read_end;	\/* End of get area. *\/$/;"	m	struct:_IO_FILE
_IO_read_ptr	.\libio.h	/^  char* _IO_read_ptr;	\/* Current read pointer *\/$/;"	m	struct:_IO_FILE
_IO_read_t	.\libioP.h	/^typedef _IO_ssize_t (*_IO_read_t) __P ((_IO_FILE *, void *, _IO_ssize_t));$/;"	t
_IO_rewind	.\iolibio.h	46;"	d
_IO_save_base	.\libio.h	/^  char *_IO_save_base; \/* Pointer to start of non-current get area. *\/$/;"	m	struct:_IO_FILE
_IO_save_end	.\libio.h	/^  char *_IO_save_end; \/* Pointer to end of non-current get area. *\/$/;"	m	struct:_IO_FILE
_IO_seek_cur	.\libioP.h	47;"	d
_IO_seek_end	.\libioP.h	48;"	d
_IO_seek_set	.\libioP.h	46;"	d
_IO_seek_t	.\libioP.h	/^typedef _IO_fpos64_t (*_IO_seek_t) __P ((_IO_FILE *, _IO_off64_t, int));$/;"	t
_IO_seek_t	.\libioP.h	/^typedef _IO_fpos_t (*_IO_seek_t) __P ((_IO_FILE *, _IO_off_t, int));$/;"	t
_IO_seekoff_t	.\libioP.h	/^typedef _IO_fpos64_t (*_IO_seekoff_t) __P ((_IO_FILE *FP, _IO_off64_t OFF,$/;"	t
_IO_seekoff_t	.\libioP.h	/^typedef _IO_fpos_t (*_IO_seekoff_t) __P ((_IO_FILE *FP, _IO_off_t OFF,$/;"	t
_IO_seekpos_t	.\libioP.h	/^typedef _IO_fpos64_t (*_IO_seekpos_t) __P ((_IO_FILE *, _IO_fpos64_t, int));$/;"	t
_IO_seekpos_t	.\libioP.h	/^typedef _IO_fpos_t (*_IO_seekpos_t) __P ((_IO_FILE *, _IO_fpos_t, int));$/;"	t
_IO_setbuf	.\iolibio.h	58;"	d
_IO_setbuf_t	.\libioP.h	/^typedef _IO_FILE* (*_IO_setbuf_t) __P ((_IO_FILE *, char *, _IO_ssize_t));$/;"	t
_IO_setg	.\libioP.h	371;"	d
_IO_setlinebuf	.\iolibio.h	59;"	d
_IO_setp	.\libioP.h	373;"	d
_IO_showmanyc_t	.\libioP.h	/^typedef int (*_IO_showmanyc_t) __P ((_IO_FILE *));$/;"	t
_IO_size_t	.\libio.h	33;"	d
_IO_sputn	.\libioP.h	313;"	d
_IO_ssize_t	.\libio.h	34;"	d
_IO_stat_t	.\libioP.h	/^typedef int (*_IO_stat_t) __P ((_IO_FILE *, void *));$/;"	t
_IO_stderr	.\libio.h	264;"	d
_IO_stderr_	.\libio.h	257;"	d
_IO_stdin	.\libio.h	262;"	d
_IO_stdin_	.\libio.h	255;"	d
_IO_stdout	.\libio.h	263;"	d
_IO_stdout_	.\libio.h	256;"	d
_IO_str_fields	.\strfile.h	/^struct _IO_str_fields$/;"	s
_IO_streambuf	.\strfile.h	/^struct _IO_streambuf$/;"	s
_IO_strfile	.\strfile.h	/^} _IO_strfile;$/;"	t	typeref:struct:_IO_strfile_
_IO_strfile_	.\strfile.h	/^typedef struct _IO_strfile_$/;"	s
_IO_sync_t	.\libioP.h	/^typedef int (*_IO_sync_t) __P ((_IO_FILE *));$/;"	t
_IO_uid_t	.\libio.h	37;"	d
_IO_underflow_t	.\libioP.h	/^typedef int (*_IO_underflow_t) __P ((_IO_FILE *));$/;"	t
_IO_va_list	.\libio.h	41;"	d
_IO_va_list	.\libio.h	52;"	d
_IO_va_list	.\libio.h	53;"	d
_IO_va_list	.\streambuf.h	43;"	d
_IO_va_start	.\libioP.h	611;"	d
_IO_vprintf	.\iolibio.h	47;"	d
_IO_wchar_t	.\streambuf.h	59;"	d
_IO_wchar_t	.\streambuf.h	61;"	d
_IO_write_base	.\libio.h	/^  char* _IO_write_base;	\/* Start of put area. *\/$/;"	m	struct:_IO_FILE
_IO_write_end	.\libio.h	/^  char* _IO_write_end;	\/* End of put area. *\/$/;"	m	struct:_IO_FILE
_IO_write_ptr	.\libio.h	/^  char* _IO_write_ptr;	\/* Current put pointer. *\/$/;"	m	struct:_IO_FILE
_IO_write_t	.\libioP.h	/^typedef _IO_ssize_t (*_IO_write_t) __P ((_IO_FILE *,const void *,_IO_ssize_t));$/;"	t
_IO_xsgetn_t	.\libioP.h	/^typedef _IO_size_t (*_IO_xsgetn_t) __P ((_IO_FILE *FP, void *DATA,$/;"	t
_IO_xsputn_t	.\libioP.h	/^typedef _IO_size_t (*_IO_xsputn_t) __P ((_IO_FILE *FP, const void *DATA,$/;"	t
_NOTHREADS	.\stl_alloc.h	66;"	d
_OLD_STDIO_MAGIC	.\libio.h	114;"	d
_PARAMS	.\libio.h	71;"	d
_PFSTREAM_H	.\pfstream.h	28;"	d
_PROCBUF_H	.\procbuf.h	28;"	d
_PlotFile_h	.\PlotFile.h	38;"	d
_SFile_h	.\SFile.h	30;"	d
_STDIOSTREAM_H	.\stdiostream.h	28;"	d
_STREAMBUF_H	.\streambuf.h	26;"	d
_STREAM_COMPAT	.\stream.h	32;"	d
__ALIGN	.\stl_alloc.h	/^    enum {__ALIGN = 8};$/;"	e	enum:__default_alloc_template::__anon6
__ALIGN	.\stl_alloc.h	/^  enum {__ALIGN = 8};$/;"	e	enum:__anon3
__ALLOC	.\stl_alloc.h	50;"	d
__ALLOC_PAUSE	.\stl_alloc.h	605;"	d
__BASTRING__	.\std\bastring.h	29;"	d
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR() : start(iterator()), finish(iterator()), end_of_storage(0) {}$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(InputIterator first, InputIterator last) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(const __BVECTOR& x) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(const bool* first, const bool* last) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(const_iterator first, const_iterator last) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(int n, bool value) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(long n, bool value) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  __BVECTOR(size_type n, bool value) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	/^  explicit __BVECTOR(size_type n) {$/;"	f	class:vector
__BVECTOR	.\stl_bvector.h	247;"	d
__BVECTOR	.\stl_bvector.h	250;"	d
__BVECTOR	.\stl_bvector.h	604;"	d
__COMPLEXT__	.\std\complext.h	28;"	d
__DCOMPLEX__	.\std\dcomplex.h	29;"	d
__DEFINE_IOMANIP_FN1	.\iomanip.h	162;"	d
__FCOMPLEX__	.\std\fcomplex.h	29;"	d
__GC_CONST	.\stl_rope.h	22;"	d
__GC_CONST	.\stl_rope.h	24;"	d
__HAVE_COLUMN	.\libio.h	233;"	d
__LDCOMPLEX__	.\std\ldcomplex.h	29;"	d
__MAX_BYTES	.\stl_alloc.h	/^    enum {__MAX_BYTES = 128};$/;"	e	enum:__default_alloc_template::__anon7
__MAX_BYTES	.\stl_alloc.h	/^  enum {__MAX_BYTES = 128};$/;"	e	enum:__anon4
__NFREELISTS	.\stl_alloc.h	/^    enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__default_alloc_template::__anon8
__NFREELISTS	.\stl_alloc.h	/^  enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__anon5
__NODE_ALLOCATOR_LOCK	.\stl_alloc.h	102;"	d
__NODE_ALLOCATOR_LOCK	.\stl_alloc.h	111;"	d
__NODE_ALLOCATOR_LOCK	.\stl_alloc.h	74;"	d
__NODE_ALLOCATOR_LOCK	.\stl_alloc.h	84;"	d
__NODE_ALLOCATOR_THREADS	.\stl_alloc.h	106;"	d
__NODE_ALLOCATOR_THREADS	.\stl_alloc.h	113;"	d
__NODE_ALLOCATOR_THREADS	.\stl_alloc.h	78;"	d
__NODE_ALLOCATOR_THREADS	.\stl_alloc.h	88;"	d
__NODE_ALLOCATOR_UNLOCK	.\stl_alloc.h	104;"	d
__NODE_ALLOCATOR_UNLOCK	.\stl_alloc.h	112;"	d
__NODE_ALLOCATOR_UNLOCK	.\stl_alloc.h	76;"	d
__NODE_ALLOCATOR_UNLOCK	.\stl_alloc.h	86;"	d
__P	.\libio.h	62;"	d
__P	.\libio.h	64;"	d
__PRIVATE	.\stl_alloc.h	22;"	d
__PRIVATE	.\stl_alloc.h	26;"	d
__PRIVATE	.\stl_alloc.h	692;"	d
__RESTRICT	.\stl_alloc.h	61;"	d
__SGI_STL_ALGOBASE_H	.\algobase.h	27;"	d
__SGI_STL_ALGO_H	.\algo.h	28;"	d
__SGI_STL_ALLOC_H	.\alloc.h	15;"	d
__SGI_STL_BVECTOR_H	.\bvector.h	28;"	d
__SGI_STL_DEQUE_H	.\deque.h	28;"	d
__SGI_STL_FUNCTION_H	.\function.h	28;"	d
__SGI_STL_HASHTABLE_H	.\hashtable.h	32;"	d
__SGI_STL_HASH_FUN_H	.\stl_hash_fun.h	32;"	d
__SGI_STL_HASH_MAP_H	.\hash_map.h	28;"	d
__SGI_STL_HASH_SET_H	.\hash_set.h	28;"	d
__SGI_STL_HEAP_H	.\heap.h	27;"	d
__SGI_STL_INTERNAL_ALGOBASE_H	.\stl_algobase.h	33;"	d
__SGI_STL_INTERNAL_ALGO_H	.\stl_algo.h	32;"	d
__SGI_STL_INTERNAL_ALLOC_H	.\stl_alloc.h	19;"	d
__SGI_STL_INTERNAL_BVECTOR_H	.\stl_bvector.h	32;"	d
__SGI_STL_INTERNAL_CONSTRUCT_H	.\stl_construct.h	32;"	d
__SGI_STL_INTERNAL_DEQUE_H	.\stl_deque.h	32;"	d
__SGI_STL_INTERNAL_FUNCTION_H	.\stl_function.h	32;"	d
__SGI_STL_INTERNAL_HASHTABLE_H	.\stl_hashtable.h	32;"	d
__SGI_STL_INTERNAL_HASH_MAP_H	.\stl_hash_map.h	32;"	d
__SGI_STL_INTERNAL_HASH_SET_H	.\stl_hash_set.h	32;"	d
__SGI_STL_INTERNAL_HEAP_H	.\stl_heap.h	31;"	d
__SGI_STL_INTERNAL_ITERATOR_H	.\stl_iterator.h	32;"	d
__SGI_STL_INTERNAL_LIST_H	.\stl_list.h	32;"	d
__SGI_STL_INTERNAL_MAP_H	.\stl_map.h	32;"	d
__SGI_STL_INTERNAL_MULTIMAP_H	.\stl_multimap.h	32;"	d
__SGI_STL_INTERNAL_MULTISET_H	.\stl_multiset.h	32;"	d
__SGI_STL_INTERNAL_NUMERIC_H	.\stl_numeric.h	33;"	d
__SGI_STL_INTERNAL_PAIR_H	.\stl_pair.h	32;"	d
__SGI_STL_INTERNAL_QUEUE_H	.\stl_queue.h	32;"	d
__SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H	.\stl_raw_storage_iter.h	32;"	d
__SGI_STL_INTERNAL_RELOPS	.\stl_relops.h	32;"	d
__SGI_STL_INTERNAL_ROPE_H	.\stl_rope.h	19;"	d
__SGI_STL_INTERNAL_SET_H	.\stl_set.h	32;"	d
__SGI_STL_INTERNAL_SLIST_H	.\stl_slist.h	20;"	d
__SGI_STL_INTERNAL_STACK_H	.\stl_stack.h	32;"	d
__SGI_STL_INTERNAL_TEMPBUF_H	.\stl_tempbuf.h	32;"	d
__SGI_STL_INTERNAL_TREE_H	.\stl_tree.h	34;"	d
__SGI_STL_INTERNAL_UNINITIALIZED_H	.\stl_uninitialized.h	32;"	d
__SGI_STL_INTERNAL_VECTOR_H	.\stl_vector.h	32;"	d
__SGI_STL_ITERATOR_H	.\iterator.h	28;"	d
__SGI_STL_LIST_H	.\list.h	28;"	d
__SGI_STL_MAP_H	.\map.h	28;"	d
__SGI_STL_MULTIMAP_H	.\multimap.h	28;"	d
__SGI_STL_MULTISET_H	.\multiset.h	28;"	d
__SGI_STL_NO_ARROW_OPERATOR	.\stl_config.h	153;"	d
__SGI_STL_NO_ARROW_OPERATOR	.\stl_config.h	166;"	d
__SGI_STL_PAIR_H	.\pair.h	28;"	d
__SGI_STL_PTHREAD_ALLOC_H	.\pthread_alloc.h	15;"	d
__SGI_STL_ROPE_H	.\rope.h	15;"	d
__SGI_STL_SET_H	.\set.h	28;"	d
__SGI_STL_SLIST_H	.\slist.h	16;"	d
__SGI_STL_STACK_H	.\stack.h	28;"	d
__SGI_STL_TEMPBUF_H	.\tempbuf.h	28;"	d
__SGI_STL_TREE_H	.\tree.h	30;"	d
__SGI_STL_VECBOOL_TEMPLATE	.\stl_bvector.h	246;"	d
__SGI_STL_VECBOOL_TEMPLATE	.\stl_bvector.h	249;"	d
__SGI_STL_VECBOOL_TEMPLATE	.\stl_bvector.h	603;"	d
__SGI_STL_VECTOR_H	.\vector.h	28;"	d
__STD	.\stl_config.h	206;"	d
__STD	.\stl_config.h	214;"	d
__STD_RELOPS	.\stl_config.h	212;"	d
__STD_RELOPS	.\stl_config.h	220;"	d
__STL_BEGIN_NAMESPACE	.\stl_config.h	207;"	d
__STL_BEGIN_NAMESPACE	.\stl_config.h	215;"	d
__STL_BEGIN_RELOPS_NAMESPACE	.\stl_config.h	210;"	d
__STL_BEGIN_RELOPS_NAMESPACE	.\stl_config.h	218;"	d
__STL_CATCH_ALL	.\stl_config.h	225;"	d
__STL_CATCH_ALL	.\stl_config.h	231;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	.\stl_config.h	112;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	.\stl_config.h	136;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	.\stl_config.h	86;"	d
__STL_CONFIG_H	.\stl_config.h	28;"	d
__STL_END_NAMESPACE	.\stl_config.h	208;"	d
__STL_END_NAMESPACE	.\stl_config.h	216;"	d
__STL_END_RELOPS_NAMESPACE	.\stl_config.h	211;"	d
__STL_END_RELOPS_NAMESPACE	.\stl_config.h	219;"	d
__STL_EXPLICIT_FUNCTION_TMPL_ARGS	.\stl_config.h	114;"	d
__STL_FUNCTION_TMPL_PARTIAL_ORDER	.\stl_config.h	113;"	d
__STL_LIMITED_DEFAULT_TEMPLATES	.\stl_config.h	165;"	d
__STL_MEMBER_TEMPLATES	.\stl_config.h	115;"	d
__STL_MEMBER_TEMPLATES	.\stl_config.h	135;"	d
__STL_MEMBER_TEMPLATES	.\stl_config.h	89;"	d
__STL_NEED_BOOL	.\stl_config.h	128;"	d
__STL_NEED_BOOL	.\stl_config.h	145;"	d
__STL_NEED_BOOL	.\stl_config.h	80;"	d
__STL_NEED_EXPLICIT	.\stl_config.h	110;"	d
__STL_NEED_EXPLICIT	.\stl_config.h	130;"	d
__STL_NEED_EXPLICIT	.\stl_config.h	150;"	d
__STL_NEED_EXPLICIT	.\stl_config.h	92;"	d
__STL_NEED_TYPENAME	.\stl_config.h	109;"	d
__STL_NEED_TYPENAME	.\stl_config.h	129;"	d
__STL_NEED_TYPENAME	.\stl_config.h	148;"	d
__STL_NEED_TYPENAME	.\stl_config.h	164;"	d
__STL_NEED_TYPENAME	.\stl_config.h	83;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	.\stl_config.h	152;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	.\stl_config.h	167;"	d
__STL_NOTHROW	.\stl_config.h	227;"	d
__STL_NOTHROW	.\stl_config.h	233;"	d
__STL_NO_DRAND48	.\stl_config.h	147;"	d
__STL_NO_DRAND48	.\stl_config.h	163;"	d
__STL_NULL_TMPL_ARGS	.\stl_config.h	192;"	d
__STL_NULL_TMPL_ARGS	.\stl_config.h	194;"	d
__STL_PTHREADS	.\stl_config.h	120;"	d
__STL_PTHREADS	.\stl_config.h	75;"	d
__STL_RETHROW	.\stl_config.h	226;"	d
__STL_RETHROW	.\stl_config.h	232;"	d
__STL_SGI_THREADS	.\stl_config.h	101;"	d
__STL_STATIC_TEMPLATE_MEMBER_BUG	.\stl_config.h	108;"	d
__STL_TEMPLATE_NULL	.\stl_config.h	198;"	d
__STL_TEMPLATE_NULL	.\stl_config.h	200;"	d
__STL_TRY	.\stl_config.h	224;"	d
__STL_TRY	.\stl_config.h	230;"	d
__STL_UNWIND	.\stl_config.h	228;"	d
__STL_UNWIND	.\stl_config.h	234;"	d
__STL_USE_EXCEPTIONS	.\stl_config.h	123;"	d
__STL_USE_EXCEPTIONS	.\stl_config.h	131;"	d
__STL_USE_EXCEPTIONS	.\stl_config.h	137;"	d
__STL_USE_EXCEPTIONS	.\stl_config.h	155;"	d
__STL_USE_EXCEPTIONS	.\stl_config.h	169;"	d
__STL_USE_EXCEPTIONS	.\stl_config.h	95;"	d
__STL_USE_NAMESPACES	.\stl_config.h	138;"	d
__STL_USE_NAMESPACES	.\stl_config.h	98;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	.\stl_config.h	209;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	.\stl_config.h	217;"	d
__STL_WIN32THREADS	.\stl_config.h	158;"	d
__STL_WIN32THREADS	.\stl_config.h	172;"	d
__STRING_CHAR_TRAITS__	.\std\straits.h	29;"	d
__STRSTREAM_H	.\strstream.h	28;"	d
__THROW_BAD_ALLOC	.\stl_alloc.h	46;"	d
__TYPEDEF_WORKAROUND	.\stl_rope.h	97;"	d
__TYPE_TRAITS_H	.\type_traits.h	16;"	d
__USE_MALLOC	.\stl_alloc.h	30;"	d
__VOLATILE	.\stl_alloc.h	107;"	d
__VOLATILE	.\stl_alloc.h	114;"	d
__VOLATILE	.\stl_alloc.h	79;"	d
__VOLATILE	.\stl_alloc.h	89;"	d
__WORD_BIT	.\stl_bvector.h	/^static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));$/;"	v
__add_and_fetch	.\stl_rope.h	288;"	d
__adjacent_difference	.\stl_numeric.h	/^OutputIterator __adjacent_difference(InputIterator first, InputIterator last, $/;"	f
__adjust_heap	.\stl_heap.h	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f
__advance	.\stl_iterator.h	/^inline void __advance(BidirectionalIterator& i, Distance n, $/;"	f
__advance	.\stl_iterator.h	/^inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {$/;"	f
__advance	.\stl_iterator.h	/^inline void __advance(RandomAccessIterator& i, Distance n, $/;"	f
__attribute__	.\std\complext.h	37;"	d
__bit_const_iterator	.\stl_bvector.h	/^  __bit_const_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	.\stl_bvector.h	/^  __bit_const_iterator(const __bit_iterator& x) : p(x.p), offset(x.offset) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	.\stl_bvector.h	/^  __bit_const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	.\stl_bvector.h	/^struct __bit_const_iterator$/;"	s
__bit_iterator	.\stl_bvector.h	/^  __bit_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_iterator
__bit_iterator	.\stl_bvector.h	/^  __bit_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_iterator
__bit_iterator	.\stl_bvector.h	/^struct __bit_iterator : public random_access_iterator<bool, ptrdiff_t> {$/;"	s
__bit_reference	.\stl_bvector.h	/^  __bit_reference() : p(0), mask(0) {}$/;"	f	struct:__bit_reference
__bit_reference	.\stl_bvector.h	/^  __bit_reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}$/;"	f	struct:__bit_reference
__bit_reference	.\stl_bvector.h	/^struct __bit_reference {$/;"	s
__black_count	.\stl_tree.h	/^inline int __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)$/;"	f
__chunk_insertion_sort	.\stl_algo.h	/^void __chunk_insertion_sort(RandomAccessIterator first, $/;"	f
__cond_store_eos	.\stl_rope.h	/^inline void __cond_store_eos(char& c) { c = 0; }$/;"	f
__cond_store_eos	.\stl_rope.h	/^inline void __cond_store_eos(charT&) {}$/;"	f
__cond_store_eos	.\stl_rope.h	/^inline void __cond_store_eos(wchar_t& c) { c = 0; }$/;"	f
__copy	.\stl_algobase.h	/^__copy(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__copy	.\stl_algobase.h	/^inline OutputIterator __copy(InputIterator first, InputIterator last,$/;"	f
__copy	.\stl_tree.h	/^rb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {$/;"	f	class:rb_tree
__copy_backward	.\stl_algobase.h	/^inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, $/;"	f
__copy_backward_dispatch	.\stl_algobase.h	/^struct __copy_backward_dispatch$/;"	s
__copy_backward_dispatch	.\stl_algobase.h	/^struct __copy_backward_dispatch<T*, T*>$/;"	s
__copy_backward_dispatch	.\stl_algobase.h	/^struct __copy_backward_dispatch<const T*, T*>$/;"	s
__copy_backward_t	.\stl_algobase.h	/^inline T* __copy_backward_t(const T* first, const T* last, T* result,$/;"	f
__copy_d	.\stl_algobase.h	/^__copy_d(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__copy_dispatch	.\stl_algobase.h	/^struct __copy_dispatch$/;"	s
__copy_dispatch	.\stl_algobase.h	/^struct __copy_dispatch<T*, T*>$/;"	s
__copy_dispatch	.\stl_algobase.h	/^struct __copy_dispatch<const T*, T*>$/;"	s
__copy_n	.\stl_algobase.h	/^__copy_n(RandomAccessIterator first, Size count,$/;"	f
__copy_n	.\stl_algobase.h	/^pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,$/;"	f
__copy_t	.\stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {$/;"	f
__copy_t	.\stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {$/;"	f
__default_alloc_template	.\stl_alloc.h	/^    __default_alloc_template() {$/;"	f	class:__default_alloc_template
__default_alloc_template	.\stl_alloc.h	/^class __default_alloc_template {$/;"	c
__deque_buf_size	.\stl_deque.h	/^inline size_t __deque_buf_size(size_t n, size_t sz)$/;"	f
__deque_iterator	.\stl_deque.h	/^  __deque_iterator() : cur(0), first(0), last(0), node(0) {}$/;"	f	struct:__deque_iterator::__deque_iterator
__deque_iterator	.\stl_deque.h	/^  __deque_iterator(T* x, map_pointer y) $/;"	f	struct:__deque_iterator::__deque_iterator
__deque_iterator	.\stl_deque.h	/^  __deque_iterator(const iterator& x)$/;"	f	struct:__deque_iterator::__deque_iterator
__deque_iterator	.\stl_deque.h	/^struct __deque_iterator {$/;"	s	struct:__deque_iterator
__deque_iterator	.\stl_deque.h	/^struct __deque_iterator {$/;"	s
__destroy	.\stl_construct.h	/^inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {$/;"	f
__destroy_aux	.\stl_construct.h	/^__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {$/;"	f
__destroy_aux	.\stl_construct.h	/^inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}$/;"	f
__distance	.\stl_iterator.h	/^__distance(InputIterator first, InputIterator last, input_iterator_tag) {$/;"	f
__distance	.\stl_iterator.h	/^__distance(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__distance	.\stl_iterator.h	/^inline void __distance(InputIterator first, InputIterator last, Distance& n, $/;"	f
__distance	.\stl_iterator.h	/^inline void __distance(RandomAccessIterator first, RandomAccessIterator last, $/;"	f
__doadv	.\std\complext.cc	/^__doadv (complex<FLOAT>* ths, const complex<FLOAT>& y)$/;"	f
__doami	.\std\complext.h	/^__doami (complex<_FLT>* ths, const complex<_FLT>& r)$/;"	f
__doaml	.\std\complext.h	/^__doaml (complex<_FLT>* ths, const complex<_FLT>& r)$/;"	f
__doapl	.\std\complext.h	/^__doapl (complex<_FLT>* ths, const complex<_FLT>& r)$/;"	f
__eos	.\stl_rope.h	/^inline charT __eos(charT*) { return charT(); }$/;"	f
__equal_range	.\stl_algo.h	/^__equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
__equal_range	.\stl_algo.h	/^__equal_range(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__erase	.\stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {$/;"	f	class:rb_tree
__false_type	.\type_traits.h	/^struct __false_type {$/;"	s
__final_insertion_sort	.\stl_algo.h	/^void __final_insertion_sort(RandomAccessIterator first, $/;"	f
__find_end	.\stl_algo.h	/^ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
__find_end	.\stl_algo.h	/^__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,$/;"	f
__fmtflags	.\streambuf.h	/^typedef unsigned long __fmtflags;$/;"	t
__gap_end_pos	.\editbuf.h	/^    buf_offset __gap_end_pos; \/\/ size of part 1 + size of gap$/;"	m	struct:edit_buffer
__gcd	.\stl_algo.h	/^EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)$/;"	f
__hashtable_const_iterator	.\stl_hashtable.h	/^  __hashtable_const_iterator() {}$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	.\stl_hashtable.h	/^  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	.\stl_hashtable.h	/^  __hashtable_const_iterator(const node* n, const hashtable* tab)$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	.\stl_hashtable.h	/^struct __hashtable_const_iterator {$/;"	s
__hashtable_iterator	.\stl_hashtable.h	/^  __hashtable_iterator() {}$/;"	f	struct:__hashtable_iterator
__hashtable_iterator	.\stl_hashtable.h	/^  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}$/;"	f	struct:__hashtable_iterator
__hashtable_iterator	.\stl_hashtable.h	/^struct __hashtable_iterator {$/;"	s
__hashtable_node	.\stl_hashtable.h	/^struct __hashtable_node$/;"	s
__imanip	.\iostream.h	/^typedef istream& (*__imanip)(istream&);$/;"	t
__inplace_merge_aux	.\stl_algo.h	/^inline void __inplace_merge_aux(BidirectionalIterator first,$/;"	f
__inplace_stable_partition	.\stl_algo.h	/^ForwardIterator __inplace_stable_partition(ForwardIterator first,$/;"	f
__inplace_stable_sort	.\stl_algo.h	/^void __inplace_stable_sort(RandomAccessIterator first,$/;"	f
__insert	.\stl_tree.h	/^__insert(base_ptr x_, base_ptr y_, const Value& v) {$/;"	f	class:rb_tree
__insertion_sort	.\stl_algo.h	/^void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
__insertion_sort	.\stl_algo.h	/^void __insertion_sort(RandomAccessIterator first,$/;"	f
__introsort_loop	.\stl_algo.h	/^void __introsort_loop(RandomAccessIterator first,$/;"	f
__iostate	.\streambuf.h	/^typedef unsigned char __iostate;$/;"	t
__is_basic_char_type	.\stl_rope.h	/^inline bool __is_basic_char_type(char *) { return true; }$/;"	f
__is_basic_char_type	.\stl_rope.h	/^inline bool __is_basic_char_type(charT *) { return false; }$/;"	f
__is_basic_char_type	.\stl_rope.h	/^inline bool __is_basic_char_type(wchar_t *) { return true; }$/;"	f
__is_heap	.\stl_algo.h	/^bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__is_one_byte_char_type	.\stl_rope.h	/^inline bool __is_one_byte_char_type(char *) { return true; }$/;"	f
__is_one_byte_char_type	.\stl_rope.h	/^inline bool __is_one_byte_char_type(charT *) { return false; }$/;"	f
__iter_swap	.\stl_algobase.h	/^inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {$/;"	f
__lg	.\stl_algo.h	/^inline Size __lg(Size n) {$/;"	f
__line_number	.\parsestream.h	/^    unsigned long __line_number;$/;"	m	class:parsebuf
__linear_insert	.\stl_algo.h	/^inline void __linear_insert(RandomAccessIterator first, $/;"	f
__list_iterator	.\stl_list.h	/^  __list_iterator() {}$/;"	f	struct:__list_iterator
__list_iterator	.\stl_list.h	/^  __list_iterator(const iterator& x) : node(x.node) {}$/;"	f	struct:__list_iterator
__list_iterator	.\stl_list.h	/^  __list_iterator(link_type x) : node(x) {}$/;"	f	struct:__list_iterator
__list_iterator	.\stl_list.h	/^struct __list_iterator {$/;"	s
__list_node	.\stl_list.h	/^struct __list_node {$/;"	s
__lock	.\stl_alloc.h	/^__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template
__lower_bound	.\stl_algo.h	/^ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f
__lower_bound	.\stl_algo.h	/^RandomAccessIterator __lower_bound(RandomAccessIterator first,$/;"	f
__make_heap	.\stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,$/;"	f
__make_heap	.\stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__malloc_alloc_oom_handler	.\stl_alloc.h	/^    static void (* __malloc_alloc_oom_handler)();$/;"	m	class:__malloc_alloc_template
__malloc_alloc_oom_handler	.\stl_alloc.h	/^    void (* __malloc_alloc_oom_handler)() = 0;$/;"	v
__malloc_alloc_oom_handler	.\stl_alloc.h	/^void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;$/;"	v
__malloc_alloc_template	.\stl_alloc.h	/^class __malloc_alloc_template {$/;"	c
__manip	.\iostream.h	/^typedef ios& (*__manip)(ios&);$/;"	t
__median	.\stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c) {$/;"	f
__median	.\stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {$/;"	f
__merge_adaptive	.\stl_algo.h	/^void __merge_adaptive(BidirectionalIterator first, $/;"	f
__merge_backward	.\stl_algo.h	/^BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,$/;"	f
__merge_sort_loop	.\stl_algo.h	/^void __merge_sort_loop(RandomAccessIterator1 first,$/;"	f
__merge_sort_with_buffer	.\stl_algo.h	/^void __merge_sort_with_buffer(RandomAccessIterator first, $/;"	f
__merge_without_buffer	.\stl_algo.h	/^void __merge_without_buffer(BidirectionalIterator first,$/;"	f
__mutable_reference_at	.\stl_rope.h	/^inline crope::reference __mutable_reference_at(crope& c, size_t i)$/;"	f
__mutable_reference_at	.\stl_rope.h	/^inline wrope::reference __mutable_reference_at(wrope& c, size_t i)$/;"	f
__my_fb	.\fstream.h	/^    mutable filebuf __my_fb; \/\/ mutable so rdbuf() can be const$/;"	m	class:fstreambase
__my_sb	.\strstream.h	/^    strstreambuf __my_sb;$/;"	m	class:strstreambase
__need___va_list	.\libio.h	49;"	d
__node_allocator_dummy_instance	.\stl_alloc.h	/^  static alloc __node_allocator_dummy_instance;$/;"	v
__node_allocator_lock	.\stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock$/;"	m	class:__default_alloc_template
__node_allocator_lock	.\stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	.\stl_alloc.h	/^    static CRITICAL_SECTION __node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	.\stl_alloc.h	/^    static pthread_mutex_t __node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	.\stl_alloc.h	/^    static volatile unsigned long __node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	.\stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock = 0;$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialized	.\stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialized	.\stl_alloc.h	/^    static bool __node_allocator_lock_initialized;$/;"	m	class:__default_alloc_template
__nth_element	.\stl_algo.h	/^void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f
__omanip	.\iostream.h	/^typedef ostream& (*__omanip)(ostream&);$/;"	t
__partial_sort	.\stl_algo.h	/^void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f
__partial_sort_copy	.\stl_algo.h	/^RandomAccessIterator __partial_sort_copy(InputIterator first,$/;"	f
__partial_sum	.\stl_numeric.h	/^OutputIterator __partial_sum(InputIterator first, InputIterator last,$/;"	f
__pop_heap	.\stl_heap.h	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__pop_heap_aux	.\stl_heap.h	/^inline void __pop_heap_aux(RandomAccessIterator first,$/;"	f
__push_heap	.\stl_heap.h	/^void __push_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f
__push_heap_aux	.\stl_heap.h	/^inline void __push_heap_aux(RandomAccessIterator first,$/;"	f
__random_sample	.\stl_algo.h	/^RandomAccessIterator __random_sample(InputIterator first, InputIterator last,$/;"	f
__random_shuffle	.\stl_algo.h	/^void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__rb_tree_base_iterator	.\stl_tree.h	/^struct __rb_tree_base_iterator$/;"	s
__rb_tree_black	.\stl_tree.h	/^const __rb_tree_color_type __rb_tree_black = true;$/;"	v
__rb_tree_color_type	.\stl_tree.h	/^typedef bool __rb_tree_color_type;$/;"	t
__rb_tree_iterator	.\stl_tree.h	/^  __rb_tree_iterator() {}$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	.\stl_tree.h	/^  __rb_tree_iterator(const iterator& it) { node = it.node; }$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	.\stl_tree.h	/^  __rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	.\stl_tree.h	/^struct __rb_tree_iterator : public __rb_tree_base_iterator$/;"	s
__rb_tree_node	.\stl_tree.h	/^struct __rb_tree_node : public __rb_tree_node_base$/;"	s
__rb_tree_node_base	.\stl_tree.h	/^struct __rb_tree_node_base$/;"	s
__rb_tree_rebalance	.\stl_tree.h	/^__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_tree_rebalance_for_erase	.\stl_tree.h	/^__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,$/;"	f
__rb_tree_red	.\stl_tree.h	/^const __rb_tree_color_type __rb_tree_red = false;$/;"	v
__rb_tree_rotate_left	.\stl_tree.h	/^__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_tree_rotate_right	.\stl_tree.h	/^__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_verify	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const$/;"	f	class:rb_tree
__reverse	.\stl_algo.h	/^void __reverse(BidirectionalIterator first, BidirectionalIterator last, $/;"	f
__reverse	.\stl_algo.h	/^void __reverse(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__rope_RopeBase	.\stl_rope.h	/^struct __rope_RopeBase {$/;"	s
__rope_RopeConcatenation	.\stl_rope.h	/^struct __rope_RopeConcatenation : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeFunction	.\stl_rope.h	/^struct __rope_RopeFunction : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeLeaf	.\stl_rope.h	/^struct __rope_RopeLeaf : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeSubstring	.\stl_rope.h	/^    __rope_RopeSubstring(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l) :$/;"	f	struct:__rope_RopeSubstring
__rope_RopeSubstring	.\stl_rope.h	/^struct __rope_RopeSubstring: public __rope_RopeFunction<charT,Alloc>,$/;"	s
__rope_charT_ptr_proxy	.\stl_rope.h	/^    __rope_charT_ptr_proxy() {}$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	.\stl_rope.h	/^    __rope_charT_ptr_proxy(charT * x) : root(0), pos(0) {$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	.\stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ptr_proxy & x) :$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	.\stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ref_proxy<charT,Alloc> & x) :$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	.\stl_rope.h	/^class __rope_charT_ptr_proxy {$/;"	c
__rope_charT_ref_proxy	.\stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p) :$/;"	f	class:__rope_charT_ref_proxy
__rope_charT_ref_proxy	.\stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p,$/;"	f	class:__rope_charT_ref_proxy
__rope_charT_ref_proxy	.\stl_rope.h	/^class __rope_charT_ref_proxy {$/;"	c
__rope_char_consumer	.\stl_rope.h	/^class __rope_char_consumer {$/;"	c
__rope_const_iterator	.\ropeimpl.h	/^inline __rope_const_iterator<charT, Alloc>::__rope_const_iterator$/;"	f	class:__rope_const_iterator
__rope_const_iterator	.\stl_rope.h	/^    __rope_const_iterator() {};$/;"	f	class:__rope_const_iterator
__rope_const_iterator	.\stl_rope.h	/^    __rope_const_iterator(const RopeBase * root, size_t pos):$/;"	f	class:__rope_const_iterator
__rope_const_iterator	.\stl_rope.h	/^    __rope_const_iterator(const __rope_const_iterator & x) :$/;"	f	class:__rope_const_iterator
__rope_const_iterator	.\stl_rope.h	/^    __rope_const_iterator(const rope<charT,Alloc> &r, size_t pos) :$/;"	f	class:__rope_const_iterator
__rope_const_iterator	.\stl_rope.h	/^class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c
__rope_fill	.\ropeimpl.h	/^inline void __rope_fill(ostream& o, size_t n)$/;"	f
__rope_find_char_char_consumer	.\ropeimpl.h	/^	__rope_find_char_char_consumer(charT p) : pattern(p), count(0) {}$/;"	f	class:__rope_find_char_char_consumer
__rope_find_char_char_consumer	.\ropeimpl.h	/^class __rope_find_char_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_flatten_char_consumer	.\ropeimpl.h	/^	__rope_flatten_char_consumer(charT * buffer) {$/;"	f	class:__rope_flatten_char_consumer
__rope_flatten_char_consumer	.\ropeimpl.h	/^class __rope_flatten_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_insert_char_consumer	.\ropeimpl.h	/^	__rope_insert_char_consumer(insert_ostream & writer) : o(writer) {};$/;"	f	class:__rope_insert_char_consumer
__rope_insert_char_consumer	.\ropeimpl.h	/^class __rope_insert_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_is_simple	.\ropeimpl.h	/^inline bool __rope_is_simple(char *) { return true; }$/;"	f
__rope_is_simple	.\ropeimpl.h	/^inline bool __rope_is_simple(wchar_t *) { return true; }$/;"	f
__rope_is_simple	.\ropeimpl.h	/^template <class charT> inline bool __rope_is_simple(charT *) { return false; }$/;"	f
__rope_iterator	.\ropeimpl.h	/^inline __rope_iterator<charT,Alloc>::__rope_iterator$/;"	f	class:__rope_iterator
__rope_iterator	.\stl_rope.h	/^    __rope_iterator() {$/;"	f	class:__rope_iterator
__rope_iterator	.\stl_rope.h	/^    __rope_iterator(const __rope_iterator & x) :$/;"	f	class:__rope_iterator
__rope_iterator	.\stl_rope.h	/^    __rope_iterator(rope<charT,Alloc> * r, size_t pos):$/;"	f	class:__rope_iterator
__rope_iterator	.\stl_rope.h	/^class __rope_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c
__rope_iterator_base	.\stl_rope.h	/^    __rope_iterator_base() {}$/;"	f	class:__rope_iterator_base
__rope_iterator_base	.\stl_rope.h	/^    __rope_iterator_base(RopeBase * root, size_t pos):$/;"	f	class:__rope_iterator_base
__rope_iterator_base	.\stl_rope.h	/^    __rope_iterator_base(const __rope_iterator_base& x) {$/;"	f	class:__rope_iterator_base
__rope_iterator_base	.\stl_rope.h	/^class __rope_iterator_base:$/;"	c
__rope_rotate	.\ropeimpl.h	/^__rope_rotate(__rope_iterator<charT,Alloc> first,$/;"	f
__rope_self_destruct_ptr	.\stl_rope.h	/^	__rope_self_destruct_ptr() : ptr(0) {};$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	.\stl_rope.h	/^	__rope_self_destruct_ptr() {};$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	.\stl_rope.h	/^    __rope_self_destruct_ptr(__rope_RopeBase<charT,Alloc> * p) : ptr(p) {}$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	.\stl_rope.h	/^  struct __rope_self_destruct_ptr {$/;"	s
__rotate	.\stl_algo.h	/^void __rotate(BidirectionalIterator first, BidirectionalIterator middle,$/;"	f
__rotate	.\stl_algo.h	/^void __rotate(ForwardIterator first, ForwardIterator middle,$/;"	f
__rotate	.\stl_algo.h	/^void __rotate(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f
__rotate_adaptive	.\stl_algo.h	/^BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,$/;"	f
__rotate_cycle	.\stl_algo.h	/^void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__search	.\stl_algo.h	/^ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
__set_errno	.\libioP.h	28;"	d
__slist_iterator	.\stl_slist.h	/^  __slist_iterator() : __slist_iterator_base(0) {}$/;"	f	struct:__slist_iterator
__slist_iterator	.\stl_slist.h	/^  __slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}$/;"	f	struct:__slist_iterator
__slist_iterator	.\stl_slist.h	/^  __slist_iterator(list_node* x) : __slist_iterator_base(x) {}$/;"	f	struct:__slist_iterator
__slist_iterator	.\stl_slist.h	/^struct __slist_iterator : public __slist_iterator_base$/;"	s
__slist_iterator_base	.\stl_slist.h	/^  __slist_iterator_base(__slist_node_base* x) : node(x) {}$/;"	f	struct:__slist_iterator_base
__slist_iterator_base	.\stl_slist.h	/^struct __slist_iterator_base$/;"	s
__slist_make_link	.\stl_slist.h	/^inline __slist_node_base* __slist_make_link(__slist_node_base* prev_node,$/;"	f
__slist_node	.\stl_slist.h	/^struct __slist_node : public __slist_node_base$/;"	s
__slist_node_base	.\stl_slist.h	/^struct __slist_node_base$/;"	s
__slist_previous	.\stl_slist.h	/^inline __slist_node_base* __slist_previous(__slist_node_base* head,$/;"	f
__slist_previous	.\stl_slist.h	/^inline const __slist_node_base* __slist_previous(const __slist_node_base* head,$/;"	f
__slist_reverse	.\stl_slist.h	/^inline __slist_node_base* __slist_reverse(__slist_node_base* node)$/;"	f
__slist_size	.\stl_slist.h	/^inline size_t __slist_size(__slist_node_base* node)$/;"	f
__slist_splice_after	.\stl_slist.h	/^inline void __slist_splice_after(__slist_node_base* pos,$/;"	f
__stable_partition_adaptive	.\stl_algo.h	/^ForwardIterator __stable_partition_adaptive(ForwardIterator first,$/;"	f
__stable_partition_aux	.\stl_algo.h	/^inline ForwardIterator __stable_partition_aux(ForwardIterator first,$/;"	f
__stable_sort_adaptive	.\stl_algo.h	/^void __stable_sort_adaptive(RandomAccessIterator first, $/;"	f
__stable_sort_aux	.\stl_algo.h	/^inline void __stable_sort_aux(RandomAccessIterator first,$/;"	f
__stl_assert	.\stl_config.h	239;"	d
__stl_assert	.\stl_config.h	243;"	d
__stl_chunk_size	.\stl_algo.h	/^const int __stl_chunk_size = 7;$/;"	v
__stl_hash_string	.\stl_hash_fun.h	/^inline size_t __stl_hash_string(const char* s)$/;"	f
__stl_next_prime	.\stl_hashtable.h	/^inline unsigned long __stl_next_prime(unsigned long n)$/;"	f
__stl_num_primes	.\stl_hashtable.h	/^static const int __stl_num_primes = 28;$/;"	v
__stl_prime_list	.\stl_hashtable.h	/^static const unsigned long __stl_prime_list[__stl_num_primes] =$/;"	v
__stl_threshold	.\stl_algo.h	/^const int __stl_threshold = 16;$/;"	v
__test_and_set	.\stl_alloc.h	590;"	d
__true_type	.\type_traits.h	/^struct __true_type {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<char> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<double> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<float> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<int> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<long double> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<long> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<short> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<signed char> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned char> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned int> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned long> {$/;"	s
__type_traits	.\type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned short> {$/;"	s
__type_traits	.\type_traits.h	/^struct __type_traits { $/;"	s
__type_traits	.\type_traits.h	/^struct __type_traits<T*> {$/;"	s
__type_traits	.\type_traits.h	/^struct __type_traits<char*> {$/;"	s
__type_traits	.\type_traits.h	/^struct __type_traits<signed char*> {$/;"	s
__type_traits	.\type_traits.h	/^struct __type_traits<unsigned char*> {$/;"	s
__unguarded_insertion_sort	.\stl_algo.h	/^inline void __unguarded_insertion_sort(RandomAccessIterator first, $/;"	f
__unguarded_insertion_sort_aux	.\stl_algo.h	/^void __unguarded_insertion_sort_aux(RandomAccessIterator first, $/;"	f
__unguarded_linear_insert	.\stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value) {$/;"	f
__unguarded_linear_insert	.\stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value, $/;"	f
__unguarded_partition	.\stl_algo.h	/^RandomAccessIterator __unguarded_partition(RandomAccessIterator first, $/;"	f
__uninitialized_copy	.\stl_uninitialized.h	/^__uninitialized_copy(InputIterator first, InputIterator last,$/;"	f
__uninitialized_copy_aux	.\stl_uninitialized.h	/^__uninitialized_copy_aux(InputIterator first, InputIterator last,$/;"	f
__uninitialized_copy_copy	.\stl_uninitialized.h	/^__uninitialized_copy_copy(InputIterator1 first1, InputIterator1 last1,$/;"	f
__uninitialized_copy_fill	.\stl_uninitialized.h	/^__uninitialized_copy_fill(InputIterator first1, InputIterator last1,$/;"	f
__uninitialized_copy_n	.\stl_uninitialized.h	/^__uninitialized_copy_n(InputIterator first, Size count,$/;"	f
__uninitialized_copy_n	.\stl_uninitialized.h	/^__uninitialized_copy_n(RandomAccessIterator first, Size count,$/;"	f
__uninitialized_fill	.\stl_uninitialized.h	/^inline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, $/;"	f
__uninitialized_fill_aux	.\stl_uninitialized.h	/^__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, $/;"	f
__uninitialized_fill_copy	.\stl_uninitialized.h	/^__uninitialized_fill_copy(ForwardIterator result, ForwardIterator mid,$/;"	f
__uninitialized_fill_n	.\stl_uninitialized.h	/^inline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,$/;"	f
__uninitialized_fill_n_aux	.\stl_uninitialized.h	/^__uninitialized_fill_n_aux(ForwardIterator first, Size n,$/;"	f
__unique_copy	.\stl_algo.h	/^ForwardIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unique_copy	.\stl_algo.h	/^OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unique_copy	.\stl_algo.h	/^inline OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unlock	.\stl_alloc.h	/^__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template
__upper_bound	.\stl_algo.h	/^ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f
__upper_bound	.\stl_algo.h	/^RandomAccessIterator __upper_bound(RandomAccessIterator first,$/;"	f
_a	.\iomanip.h	/^    TP _a;$/;"	m	class:imanip
_a	.\iomanip.h	/^    TP _a;$/;"	m	class:omanip
_a	.\iomanip.h	/^    TP _a;$/;"	m	class:smanip
_a	.\iomanip.h	/^    imanip(istream& (*f)(istream&, TP), TP a) : _f(f), _a(a) {}$/;"	f	class:imanip
_a	.\iomanip.h	/^    omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) {}$/;"	f	class:omanip
_a	.\iomanip.h	/^    smanip(ios& (*f)(ios&, TP), TP a) : _f(f), _a(a) {}$/;"	f	class:smanip
_allocate_buffer	.\strfile.h	/^  _IO_alloc_type _allocate_buffer;$/;"	m	struct:_IO_str_fields
_arrays	.\streambuf.h	/^    void *_arrays; \/* Support for ios::iword and ios::pword. *\/$/;"	m	struct:_ios_fields
_bad	.\streambuf.h	/^    _bad = _IOS_BAD };$/;"	e	enum:state_value
_blksize	.\libio.h	/^  int _blksize;$/;"	m	struct:_IO_FILE
_chain	.\libio.h	/^  struct _IO_FILE *_chain;$/;"	m	struct:_IO_FILE	typeref:struct:_IO_FILE::_IO_FILE
_cur_column	.\libio.h	/^  unsigned short _cur_column;$/;"	m	struct:_IO_FILE
_delete_flags	.\indstream.h	/^    int _delete_flags;$/;"	m	class:indirectbuf
_eof	.\streambuf.h	/^    _eof = _IOS_EOF,$/;"	e	enum:state_value
_exceptions	.\streambuf.h	/^    __iostate _exceptions;$/;"	m	struct:_ios_fields
_f	.\iomanip.h	/^    ios& (*_f)(ios&, TP);$/;"	m	class:sapp
_f	.\iomanip.h	/^    ios& (*_f)(ios&, TP);$/;"	m	class:smanip
_f	.\iomanip.h	/^    istream& (*_f)(istream&, TP);$/;"	m	class:iapp
_f	.\iomanip.h	/^    istream& (*_f)(istream&, TP);$/;"	m	class:imanip
_f	.\iomanip.h	/^    ostream& (*_f)(ostream&, TP);$/;"	m	class:oapp
_f	.\iomanip.h	/^    ostream& (*_f)(ostream&, TP);$/;"	m	class:omanip
_f	.\strfile.h	/^  struct _IO_FILE _f;$/;"	m	struct:_IO_streambuf	typeref:struct:_IO_streambuf::_IO_FILE
_fail	.\streambuf.h	/^    _fail = _IOS_FAIL,$/;"	e	enum:state_value
_file	.\stdiostream.h	/^    FILE *_file;$/;"	m	class:stdiobuf
_file	.\stdiostream.h	/^  stdiobuf _file;$/;"	m	class:istdiostream
_file	.\stdiostream.h	/^  stdiobuf _file;$/;"	m	class:ostdiostream
_fileno	.\libio.h	/^  int _fileno;$/;"	m	struct:_IO_FILE
_fill	.\streambuf.h	/^    _IO_wchar_t _fill;$/;"	m	struct:_ios_fields
_find	.\std\bastring.cc	/^_find (const charT* ptr, charT c, size_type xpos, size_type len)$/;"	f	class:basic_string
_flags	.\libio.h	/^  int _flags;		\/* High-order word is _IO_MAGIC; rest is flags. *\/$/;"	m	struct:_IO_FILE
_flags	.\streambuf.h	/^    __fmtflags _flags;$/;"	m	struct:_ios_fields
_free_buffer	.\strfile.h	/^  _IO_free_type _free_buffer;$/;"	m	struct:_IO_str_fields
_gap_start	.\editbuf.h	/^    buf_char *_gap_start;$/;"	m	struct:edit_buffer
_gcount	.\iostream.h	/^    _IO_size_t _gcount;$/;"	m	class:istream
_get_stream	.\indstream.h	/^    streambuf *_get_stream;  \/\/ Optional cache for get_stream().$/;"	m	class:indirectbuf
_good	.\streambuf.h	/^    _good = _IOS_GOOD,$/;"	e	enum:state_value
_insert_after	.\stl_slist.h	/^  list_node* _insert_after(list_node_base* pos, const value_type& x) {$/;"	f	class:slist
_insert_after_fill	.\stl_slist.h	/^  void _insert_after_fill(list_node_base* pos,$/;"	f	class:slist
_insert_after_range	.\stl_slist.h	/^  void _insert_after_range(list_node_base* pos, InIter first, InIter last) {$/;"	f	class:slist
_insert_after_range	.\stl_slist.h	/^  void _insert_after_range(list_node_base* pos,$/;"	f	class:slist
_inserting	.\editbuf.h	/^    int _inserting;$/;"	m	struct:edit_streambuf
_ios_fields	.\streambuf.h	/^struct _ios_fields$/;"	s
_line_length	.\parsestream.h	/^    long _line_length;$/;"	m	class:parsebuf
_list_all	.\streambuf.h	/^    static streambuf* _list_all; \/* List of open streambufs. *\/$/;"	m	struct:streambuf
_lock	.\libio.h	/^  _IO_LOCK_T _lock;$/;"	m	struct:_IO_FILE
_markers	.\libio.h	/^  struct _IO_marker *_markers;$/;"	m	struct:_IO_FILE	typeref:struct:_IO_FILE::_IO_marker
_mode	.\editbuf.h	/^    short _mode;$/;"	m	struct:edit_streambuf
_next	.\libio.h	/^  struct _IO_marker *_next;$/;"	m	struct:_IO_marker	typeref:struct:_IO_marker::_IO_marker
_next	.\procbuf.h	/^    procbuf *_next;$/;"	m	class:procbuf
_offset	.\libio.h	/^  _IO_off64_t _offset;$/;"	m	struct:_IO_FILE
_offset	.\libio.h	/^  _IO_off_t _offset;$/;"	m	struct:_IO_FILE
_old_offset	.\libio.h	/^  _IO_off_t _old_offset;$/;"	m	struct:_IO_FILE
_pid	.\procbuf.h	/^    _IO_pid_t _pid;$/;"	m	class:procbuf
_pos	.\editbuf.h	/^    mark_pointer _pos;$/;"	m	struct:edit_mark
_pos	.\libio.h	/^  int _pos;$/;"	m	struct:_IO_marker
_precision	.\streambuf.h	/^    int _precision;$/;"	m	struct:_ios_fields
_put_stream	.\indstream.h	/^    streambuf *_put_stream;  \/\/ Optional cache for put_stream().$/;"	m	class:indirectbuf
_s	.\strfile.h	/^  struct _IO_str_fields _s;$/;"	m	struct:_IO_strfile_	typeref:struct:_IO_strfile_::_IO_str_fields
_s	.\strstream.h	/^  struct _IO_str_fields _s;$/;"	m	class:strstreambuf	typeref:struct:strstreambuf::_IO_str_fields
_sbf	.\strfile.h	/^  struct _IO_streambuf _sbf;$/;"	m	struct:_IO_strfile_	typeref:struct:_IO_strfile_::_IO_streambuf
_sbuf	.\libio.h	/^  struct _IO_FILE *_sbuf;$/;"	m	struct:_IO_marker	typeref:struct:_IO_marker::_IO_FILE
_seek_dir	.\streambuf.h	/^typedef int _seek_dir;$/;"	t
_seek_dir	.\streambuf.h	/^typedef ios::seek_dir _seek_dir;$/;"	t
_shortbuf	.\libio.h	/^  char _shortbuf[1];$/;"	m	struct:_IO_FILE
_state	.\streambuf.h	/^    __iostate _state;$/;"	m	struct:_ios_fields
_strbuf	.\streambuf.h	/^    streambuf *_strbuf;$/;"	m	struct:_ios_fields
_stream	.\streambuf.h	/^	ios* _stream;$/;"	m	class:ios::failure
_throw_failure	.\streambuf.h	/^    void _throw_failure() const { throw new ios::failure(this); }$/;"	f	class:ios
_throw_failure	.\streambuf.h	/^    void _throw_failure() const { }$/;"	f	class:ios
_tie	.\streambuf.h	/^    ostream* _tie;$/;"	m	struct:_ios_fields
_unused	.\libio.h	/^  char _unused;$/;"	m	struct:_IO_FILE
_unused2	.\libio.h	/^  int _unused2[16];	\/* Make sure we don't get into trouble again.  *\/$/;"	m	struct:_IO_FILE
_vtable	.\streambuf.h	/^    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }$/;"	f	struct:streambuf
_vtable	.\strfile.h	/^  const void *_vtable;$/;"	m	struct:_IO_streambuf
_width	.\streambuf.h	/^    int _width;$/;"	m	struct:_ios_fields
_writer	.\editbuf.h	/^    edit_streambuf* _writer; \/\/ If non-NULL, currently writing stream$/;"	m	struct:edit_buffer
abs	.\std\complext.h	/^abs (const complex<_FLT>& x)$/;"	f
accumulate	.\stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init) {$/;"	f
accumulate	.\stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init,$/;"	f
add_leaf_to_forest	.\ropeimpl.h	/^rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope
add_to_forest	.\ropeimpl.h	/^rope<charT,Alloc>::add_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope
address	.\defalloc.h	/^    pointer address(reference x) { return (pointer)&x; }$/;"	f	class:allocator
adjacent_difference	.\stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last, $/;"	f
adjacent_difference	.\stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last,$/;"	f
adjacent_find	.\stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {$/;"	f
adjacent_find	.\stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,$/;"	f
adjustfield	.\streambuf.h	/^	adjustfield = left+right+internal$/;"	e	enum:ios::__anon16
advance	.\stl_iterator.h	/^inline void advance(InputIterator& i, Distance n) {$/;"	f
alloc	.\std\bastring.cc	/^alloc (basic_string::size_type size, bool save)$/;"	f	class:basic_string
alloc	.\stl_alloc.h	/^typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;$/;"	t
alloc	.\stl_alloc.h	/^typedef malloc_alloc alloc;$/;"	t
alloc_copy	.\stl_rope.h	/^	static charT * alloc_copy(const charT *s, size_t size)$/;"	f	class:rope
alloc_granularity	.\stl_rope.h	/^    enum { alloc_granularity = 8 };$/;"	e	enum:__rope_RopeBase::__anon11
allocate	.\defalloc.h	/^    pointer allocate(size_type n) { $/;"	f	class:allocator
allocate	.\defalloc.h	/^inline T* allocate(ptrdiff_t size, T*) {$/;"	f
allocate	.\stl_alloc.h	/^    static T *allocate(size_t n)$/;"	f	class:simple_alloc
allocate	.\stl_alloc.h	/^    static T *allocate(void)$/;"	f	class:simple_alloc
allocate	.\stl_alloc.h	/^  static void * allocate(size_t n)$/;"	f	class:__default_alloc_template
allocate	.\stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:__malloc_alloc_template
allocate	.\stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:debug_alloc
allocate	.\streambuf.h	/^    int allocate() { \/\/ For AT&T compatibility$/;"	f	struct:streambuf
allocate_and_copy	.\stl_vector.h	/^  iterator allocate_and_copy(size_type n,$/;"	f	class:vector
allocate_and_fill	.\stl_vector.h	/^  iterator allocate_and_fill(size_type n, const T& x) {$/;"	f	class:vector
allocate_buffer	.\stl_tempbuf.h	/^  void allocate_buffer() {$/;"	f	class:temporary_buffer
allocate_node	.\stl_deque.h	/^  pointer allocate_node() { return data_allocator::allocate(buffer_size()); }$/;"	f	class:__deque_iterator::deque
allocated_capacity	.\stl_rope.h	/^	static size_t allocated_capacity(size_t n) {$/;"	f	class:rope
allocator	.\defalloc.h	/^class allocator {$/;"	c
allocator	.\defalloc.h	/^class allocator<void> {$/;"	c
allocator_type	.\std\bastring.h	/^  typedef	   Allocator		allocator_type;$/;"	t	class:basic_string
allocbuf	.\streambuf.h	/^    void allocbuf() { if (base() == NULL) doallocbuf(); }$/;"	f	struct:streambuf
app	.\streambuf.h	/^	app = _IO_APPEND,$/;"	e	enum:ios::open_mode
append	.\std\bastring.h	/^    basic_string& append(InputIterator first, InputIterator last)$/;"	f	class:basic_string
append	.\std\bastring.h	/^  basic_string& append (const basic_string& str, size_type pos = 0,$/;"	f	class:basic_string
append	.\std\bastring.h	/^  basic_string& append (const charT* s)$/;"	f	class:basic_string
append	.\std\bastring.h	/^  basic_string& append (const charT* s, size_type n)$/;"	f	class:basic_string
append	.\std\bastring.h	/^  basic_string& append (size_type n, charT c)$/;"	f	class:basic_string
append	.\stl_rope.h	/^	rope& append() { return append(charT()); }$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(charT c) {$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(const charT* c_string) {$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(const charT* iter, size_t n) {$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(const charT* s, const charT* e) {$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(const rope& y) {$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(const_iterator s, const_iterator e) {$/;"	f	class:rope
append	.\stl_rope.h	/^	rope& append(size_t n, charT c) {$/;"	f	class:rope
append	.\stl_rope.h	/^	void append(value_type *s, size_t len)$/;"	f	class:sequence_buffer
append	.\streambuf.h	/^    append = _IO_APPEND };$/;"	e	enum:open_mode
apply_to_pieces	.\ropeimpl.h	/^bool rope<charT, Alloc>::apply_to_pieces($/;"	f	class:rope
apply_to_pieces	.\stl_rope.h	/^	void apply_to_pieces( size_t begin, size_t end,$/;"	f	class:rope
arg	.\parsestream.h	/^    void *arg;$/;"	m	class:func_parsebuf
arg	.\std\complext.h	/^arg (const complex<_FLT>& x)$/;"	f
argument_type	.\stl_function.h	/^    typedef Arg argument_type;$/;"	t	struct:unary_function
assign	.\std\bastring.h	/^    basic_string& assign(InputIterator first, InputIterator last)$/;"	f	class:basic_string
assign	.\std\bastring.h	/^  basic_string& assign (const basic_string& str, size_type pos = 0,$/;"	f	class:basic_string
assign	.\std\bastring.h	/^  basic_string& assign (const charT* s)$/;"	f	class:basic_string
assign	.\std\bastring.h	/^  basic_string& assign (const charT* s, size_type n)$/;"	f	class:basic_string
assign	.\std\bastring.h	/^  basic_string& assign (size_type n, charT c)$/;"	f	class:basic_string
assign	.\std\straits.h	/^  static void assign (char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
at	.\std\bastring.h	/^  const_reference at (size_type pos) const$/;"	f	class:basic_string
at	.\std\bastring.h	/^  reference at (size_type pos)$/;"	f	class:basic_string
at	.\stl_rope.h	/^	    reference at(size_type pos) {$/;"	f	class:rope
at	.\stl_rope.h	/^	charT at(size_type pos) const {$/;"	f	class:rope
ate	.\streambuf.h	/^	ate = _IO_ATEND,$/;"	e	enum:ios::open_mode
atend	.\streambuf.h	/^    atend = _IO_ATEND,$/;"	e	enum:open_mode
atomic_swap	.\stl_rope.h	/^	    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {$/;"	f	class:rope
back	.\stl_bvector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector
back	.\stl_bvector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector
back	.\stl_deque.h	/^  const_reference back() const {$/;"	f	class:__deque_iterator::deque
back	.\stl_deque.h	/^  reference back() {$/;"	f	class:__deque_iterator::deque
back	.\stl_list.h	/^  const_reference back() const { return *(--end()); }$/;"	f	class:list
back	.\stl_list.h	/^  reference back() { return *(--end()); }$/;"	f	class:list
back	.\stl_queue.h	/^  const_reference back() const { return c.back(); }$/;"	f	class:queue
back	.\stl_queue.h	/^  reference back() { return c.back(); }$/;"	f	class:queue
back	.\stl_rope.h	/^	charT back() const$/;"	f	class:rope
back	.\stl_vector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector
back	.\stl_vector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector
back_insert_iterator	.\stl_iterator.h	/^  explicit back_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:back_insert_iterator
back_insert_iterator	.\stl_iterator.h	/^class back_insert_iterator {$/;"	c
back_inserter	.\stl_iterator.h	/^inline back_insert_iterator<Container> back_inserter(Container& x) {$/;"	f
backed_up_to_newline	.\parsestream.h	/^    int backed_up_to_newline;$/;"	m	class:func_parsebuf
bad	.\streambuf.h	/^    int bad() const { return _state & ios::badbit; }$/;"	f	class:ios
badbit	.\streambuf.h	/^	badbit = _IOS_BAD };$/;"	e	enum:ios::io_state
balance	.\ropeimpl.h	/^rope<charT,Alloc>::balance(RopeBase *r)$/;"	f	class:rope
balance	.\stl_rope.h	/^	void balance()$/;"	f	class:rope
base	.\stl_iterator.h	/^  BidirectionalIterator base() const { return current; }$/;"	f	class:reverse_bidirectional_iterator
base	.\stl_iterator.h	/^  RandomAccessIterator base() const { return current; }$/;"	f	class:reverse_iterator
base	.\stl_iterator.h	/^  iterator_type base() const { return current; }$/;"	f	class:reverse_iterator
base	.\stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * base;	\/\/ not 0$/;"	m	struct:__rope_RopeSubstring
base	.\streambuf.h	/^    char* base() const { return _IO_buf_base; }$/;"	f	struct:streambuf
base_ptr	.\stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	class:rb_tree
base_ptr	.\stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:__rb_tree_node_base
base_ptr	.\stl_tree.h	/^  typedef __rb_tree_node_base::base_ptr base_ptr;$/;"	t	struct:__rb_tree_base_iterator
basefield	.\streambuf.h	/^	basefield=dec+oct+hex,$/;"	e	enum:ios::__anon16
basic_string	.\std\bastring.h	/^    basic_string(InputIterator begin, InputIterator end)$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^  basic_string (const basic_string& str): dat (str.rep ()->grab ()) { }$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^  basic_string (const basic_string& str, size_type pos, size_type n = npos)$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^  basic_string (const charT* s)$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^  basic_string (const charT* s, size_type n)$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^  basic_string (size_type n, charT c)$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^  explicit basic_string (): dat (nilRep.grab ()) { }$/;"	f	class:basic_string
basic_string	.\std\bastring.h	/^class basic_string$/;"	c
beg	.\streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	e	enum:ios::seek_dir
begin	.\std\bastring.h	/^  const_iterator begin () const { return ibegin (); }$/;"	f	class:basic_string
begin	.\std\bastring.h	/^  iterator begin () { selfish (); return &(*this)[0]; }$/;"	f	class:basic_string
begin	.\stl_bvector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector
begin	.\stl_bvector.h	/^  iterator begin() { return start; }$/;"	f	class:vector
begin	.\stl_deque.h	/^  const_iterator begin() const { return start; }$/;"	f	class:__deque_iterator::deque
begin	.\stl_deque.h	/^  iterator begin() { return start; }$/;"	f	class:__deque_iterator::deque
begin	.\stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_map
begin	.\stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multimap
begin	.\stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_map
begin	.\stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_multimap
begin	.\stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multiset
begin	.\stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_set
begin	.\stl_hashtable.h	/^  const_iterator begin() const$/;"	f	class:hashtable
begin	.\stl_hashtable.h	/^  iterator begin()$/;"	f	class:hashtable
begin	.\stl_list.h	/^  const_iterator begin() const { return (link_type)((*node).next); }$/;"	f	class:list
begin	.\stl_list.h	/^  iterator begin() { return (link_type)((*node).next); }$/;"	f	class:list
begin	.\stl_map.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:map
begin	.\stl_map.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:map
begin	.\stl_multimap.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:multimap
begin	.\stl_multimap.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:multimap
begin	.\stl_multiset.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:multiset
begin	.\stl_rope.h	/^	    const_iterator begin() { return const_begin(); }$/;"	f	class:rope
begin	.\stl_rope.h	/^	    iterator begin() { return mutable_begin(); }$/;"	f	class:rope
begin	.\stl_rope.h	/^	const_iterator begin() const {$/;"	f	class:rope
begin	.\stl_set.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:set
begin	.\stl_slist.h	/^  const_iterator begin() const { return const_iterator((list_node*)head.next);}$/;"	f	class:slist
begin	.\stl_slist.h	/^  iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:slist
begin	.\stl_tempbuf.h	/^  T* begin() { return buffer; }$/;"	f	class:temporary_buffer
begin	.\stl_tree.h	/^  const_iterator begin() const { return leftmost(); }$/;"	f	class:rb_tree
begin	.\stl_tree.h	/^  iterator begin() { return leftmost(); }$/;"	f	class:rb_tree
begin	.\stl_vector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector
begin	.\stl_vector.h	/^  iterator begin() { return start; }$/;"	f	class:vector
bidirectional_iterator	.\stl_iterator.h	/^template <class T, class Distance> struct bidirectional_iterator {$/;"	s
bidirectional_iterator_tag	.\stl_iterator.h	/^struct bidirectional_iterator_tag : public forward_iterator_tag {};$/;"	s
bin	.\streambuf.h	/^	bin = _IOS_BIN, \/\/ Deprecated - ANSI uses ios::binary.$/;"	e	enum:ios::open_mode
binary	.\streambuf.h	/^	binary = _IOS_BIN };$/;"	e	enum:ios::open_mode
binary_compose	.\stl_function.h	/^  binary_compose(const Operation1& x, const Operation2& y, $/;"	f	class:binary_compose
binary_compose	.\stl_function.h	/^class binary_compose$/;"	c
binary_function	.\stl_function.h	/^struct binary_function {$/;"	s
binary_negate	.\stl_function.h	/^  explicit binary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:binary_negate
binary_negate	.\stl_function.h	/^class binary_negate $/;"	c
binary_search	.\stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
binary_search	.\stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last,$/;"	f
bind1st	.\stl_function.h	/^inline binder1st<Operation> bind1st(const Operation& op, const T& x) {$/;"	f
bind2nd	.\stl_function.h	/^inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {$/;"	f
binder1st	.\stl_function.h	/^  binder1st(const Operation& x,$/;"	f	class:binder1st
binder1st	.\stl_function.h	/^class binder1st$/;"	c
binder2nd	.\stl_function.h	/^  binder2nd(const Operation& x,$/;"	f	class:binder2nd
binder2nd	.\stl_function.h	/^class binder2nd$/;"	c
bit_alloc	.\stl_bvector.h	/^  unsigned int* bit_alloc(size_type n) {$/;"	f	class:vector
bit_vector	.\stl_bvector.h	/^typedef vector<bool, alloc> bit_vector;$/;"	t
bkt_num	.\stl_hashtable.h	/^  size_type bkt_num(const value_type& obj) const$/;"	f	class:hashtable
bkt_num	.\stl_hashtable.h	/^  size_type bkt_num(const value_type& obj, size_t n) const$/;"	f	class:hashtable
bkt_num_key	.\stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key) const$/;"	f	class:hashtable
bkt_num_key	.\stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key, size_t n) const$/;"	f	class:hashtable
blen	.\streambuf.h	/^    int blen() const { return _IO_buf_end - _IO_buf_base; }$/;"	f	struct:streambuf
bool	.\stl_config.h	/^    typedef int bool;$/;"	t
bucket_count	.\stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_map
bucket_count	.\stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multimap
bucket_count	.\stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multiset
bucket_count	.\stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_set
bucket_count	.\stl_hashtable.h	/^  size_type bucket_count() const { return buckets.size(); }$/;"	f	class:hashtable
buckets	.\stl_hashtable.h	/^  vector<node*,Alloc> buckets;$/;"	m	class:hashtable
buf_char	.\editbuf.h	/^typedef \/*unsigned*\/ char buf_char;$/;"	t
buf_count	.\stl_rope.h	/^	size_t buf_count;$/;"	m	class:sequence_buffer
buf_end	.\parsestream.h	/^    char *buf_end;$/;"	m	class:parsebuf
buf_end	.\stl_rope.h	/^    __GC_CONST charT * buf_end;$/;"	m	class:__rope_iterator_base
buf_index	.\editbuf.h	/^typedef long buf_index;$/;"	t
buf_offset	.\editbuf.h	/^typedef long buf_offset; $/;"	t
buf_ptr	.\ropeimpl.h	/^	charT * buf_ptr;$/;"	m	class:__rope_flatten_char_consumer
buf_ptr	.\stl_rope.h	/^    __GC_CONST charT * buf_ptr;$/;"	m	class:__rope_iterator_base
buf_size	.\editbuf.h	/^    int buf_size;$/;"	m	struct:edit_buffer
buf_start	.\parsestream.h	/^    char *buf_start;$/;"	m	class:parsebuf
buf_start	.\stl_rope.h	/^    __GC_CONST charT * buf_start;$/;"	m	class:__rope_iterator_base
buffer	.\editbuf.h	/^    struct edit_buffer *buffer; \/\/ buffer that 'start' and 'end' belong to$/;"	m	struct:edit_string	typeref:struct:edit_string::edit_buffer
buffer	.\ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_flatten_char_consumer
buffer	.\ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_insert_char_consumer
buffer	.\stl_rope.h	/^	value_type buffer[buf_sz];$/;"	m	class:sequence_buffer
buffer	.\stl_tempbuf.h	/^  T* buffer;$/;"	m	class:temporary_buffer
buffer_size	.\stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }$/;"	f	struct:__deque_iterator::__deque_iterator
buffer_size	.\stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:__deque_iterator
buffer_size	.\stl_deque.h	/^  static size_type buffer_size() {$/;"	f	class:__deque_iterator::deque
buffered	.\stdiostream.h	/^    int buffered () const { return _flags & _IO_UNBUFFERED ? 0 : 1; }$/;"	f	class:stdiobuf
buffered	.\stdiostream.h	/^  int buffered () const { return _file.buffered (); }$/;"	f	class:istdiostream
buffered	.\stdiostream.h	/^  int buffered () const { return _file.buffered (); }$/;"	f	class:ostdiostream
buffered	.\stdiostream.h	/^  void buffered (int _i) { _file.buffered (_i); }$/;"	f	class:istdiostream
buffered	.\stdiostream.h	/^  void buffered (int _i) { _file.buffered (_i); }$/;"	f	class:ostdiostream
builtinbuf	.\builtinbuf.h	/^  builtinbuf() { }$/;"	f	class:builtinbuf
builtinbuf	.\builtinbuf.h	/^class builtinbuf : public streambuf {$/;"	c
bump_down	.\stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_const_iterator
bump_down	.\stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_iterator
bump_up	.\stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_const_iterator
bump_up	.\stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_iterator
c	.\stl_queue.h	/^  Sequence c;$/;"	m	class:priority_queue
c	.\stl_queue.h	/^  Sequence c;$/;"	m	class:queue
c	.\stl_stack.h	/^  Sequence c;$/;"	m	class:stack
c_str	.\ropeimpl.h	/^const charT * rope<charT,Alloc>::c_str() const {$/;"	f	class:rope
c_str	.\std\bastring.h	/^  const charT* c_str () const$/;"	f	class:basic_string
c_string	.\stl_rope.h	/^    __GC_CONST charT * c_string;$/;"	m	struct:__rope_RopeBase
capacity	.\std\bastring.h	/^  size_type capacity () const$/;"	f	class:basic_string
capacity	.\stl_bvector.h	/^  size_type capacity() const {$/;"	f	class:vector
capacity	.\stl_rope.h	/^	    size_type capacity() const {$/;"	f	class:rope
capacity	.\stl_vector.h	/^  size_type capacity() const { return size_type(end_of_storage - begin()); }$/;"	f	class:vector
chain	.\editbuf.h	/^    struct edit_mark *chain;$/;"	m	struct:edit_mark	typeref:struct:edit_mark::edit_mark
chain	.\parsestream.h	/^    parsebuf *chain;$/;"	m	class:parsebuf
char_producer	.\stl_rope.h	/^class char_producer {$/;"	c
char_ptr_len	.\ropeimpl.h	/^inline size_t rope<charT,Alloc>::char_ptr_len(const charT *s)$/;"	f	class:rope
char_type	.\std\straits.h	/^  typedef char char_type;$/;"	t	struct:string_char_traits
char_type	.\std\straits.h	/^  typedef charT char_type; \/\/ for users to acquire the basic character type$/;"	t	struct:string_char_traits
check	.\ropeimpl.h	/^void __rope_iterator<charT,Alloc>::check() {$/;"	f	class:__rope_iterator
check_realloc	.\std\bastring.cc	/^check_realloc (basic_string::size_type s) const$/;"	f	class:basic_string
chunk_alloc	.\stl_alloc.h	/^__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)$/;"	f	class:__default_alloc_template
clear	.\stl_bvector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector
clear	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::clear() {$/;"	f	class:__deque_iterator::deque
clear	.\stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_map
clear	.\stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multimap
clear	.\stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multiset
clear	.\stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_set
clear	.\stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::clear()$/;"	f	class:hashtable
clear	.\stl_list.h	/^void list<T, Alloc>::clear()$/;"	f	class:list
clear	.\stl_map.h	/^  void clear() { t.clear(); }$/;"	f	class:map
clear	.\stl_multimap.h	/^  void clear() { t.clear(); }$/;"	f	class:multimap
clear	.\stl_multiset.h	/^  void clear() { t.clear(); }$/;"	f	class:multiset
clear	.\stl_set.h	/^  void clear() { t.clear(); }$/;"	f	class:set
clear	.\stl_slist.h	/^  void clear() { erase_after(&head, 0); }$/;"	f	class:slist
clear	.\stl_tree.h	/^  void clear() {$/;"	f	class:rb_tree
clear	.\stl_vector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector
clear	.\streambuf.h	/^    void clear(iostate state = 0) {$/;"	f	class:ios
clearerr	.\iostdio.h	62;"	d
client_data	.\stl_alloc.h	/^        char client_data[1];    \/* The client sees this.        *\/$/;"	m	union:__default_alloc_template::obj
clone	.\std\bastring.cc	/^clone ()$/;"	f	class:basic_string::Rep
clone_node	.\stl_tree.h	/^  link_type clone_node(link_type x) {$/;"	f	class:rb_tree
close	.\libio.h	/^  int (*close) __P ((struct _IO_FILE *));$/;"	m	struct:__anon1
close	.\procbuf.h	/^    procbuf *close() { return (procbuf*)filebuf::close(); }$/;"	f	class:procbuf
close	.\streambuf.h	71;"	d
color	.\stl_tree.h	/^  color_type color; $/;"	m	struct:__rb_tree_node_base
color	.\stl_tree.h	/^  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }$/;"	f	class:rb_tree
color	.\stl_tree.h	/^  static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:rb_tree
color_type	.\stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	class:rb_tree
color_type	.\stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	struct:__rb_tree_node_base
comp	.\stl_map.h	/^    Compare comp;$/;"	m	class:map::value_compare
comp	.\stl_multimap.h	/^    Compare comp;$/;"	m	class:multimap::value_compare
comp	.\stl_queue.h	/^  Compare comp;$/;"	m	class:priority_queue
compare	.\ropeimpl.h	/^rope<charT,Alloc>::compare (const RopeBase *left, const RopeBase *right)$/;"	f	class:rope
compare	.\std\bastring.cc	/^compare (const basic_string& str, size_type pos, size_type n) const$/;"	f	class:basic_string
compare	.\std\bastring.cc	/^compare (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
compare	.\std\bastring.h	/^  int compare (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
compare	.\std\straits.h	/^  static int compare (const char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
compare	.\stl_rope.h	/^	int compare(const rope &y) const {$/;"	f	class:rope
complex	.\std\complext.h	/^  complex (_FLT r = 0, _FLT i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	.\std\complext.h	/^class complex$/;"	c
complex	.\std\dcomplex.h	/^  complex (const complex<float>& r): re (r.real ()), im (r.imag ()) { }$/;"	f	class:complex
complex	.\std\dcomplex.h	/^  complex (double r = 0, double i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	.\std\dcomplex.h	/^class complex<double>$/;"	c
complex	.\std\dcomplex.h	/^inline complex<float>::complex (const complex<double>& r)$/;"	f	class:complex
complex	.\std\fcomplex.h	/^  complex (float r = 0, float i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	.\std\fcomplex.h	/^class complex<float>$/;"	c
complex	.\std\ldcomplex.h	/^  complex (const complex<double>& r): re (r.real ()), im (r.imag ()) { }$/;"	f	class:complex
complex	.\std\ldcomplex.h	/^  complex (const complex<float>& r): re (r.real ()), im (r.imag ()) { }$/;"	f	class:complex
complex	.\std\ldcomplex.h	/^  complex (long double r = 0, long double i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	.\std\ldcomplex.h	/^class complex<long double>$/;"	c
complex	.\std\ldcomplex.h	/^inline complex<double>::complex (const complex<long double>& r)$/;"	f	class:complex
complex	.\std\ldcomplex.h	/^inline complex<float>::complex (const complex<long double>& r)$/;"	f	class:complex
compose1	.\stl_function.h	/^inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, $/;"	f
compose2	.\stl_function.h	/^compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {$/;"	f
concat	.\ropeimpl.h	/^rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)$/;"	f	class:rope
concat	.\stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon10
concat_and_set_balanced	.\stl_rope.h	/^	static RopeBase * concat_and_set_balanced(RopeBase *left,$/;"	f	class:rope
concat_char_iter	.\ropeimpl.h	/^rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter$/;"	f	class:rope
concat_fn	.\stl_rope.h	/^	struct concat_fn$/;"	s	class:rope
conj	.\std\complext.h	/^conj (const complex<_FLT>& x) $/;"	f
const	.\libio.h	75;"	d
const_address	.\defalloc.h	/^    const_pointer const_address(const_reference x) { $/;"	f	class:allocator
const_begin	.\stl_rope.h	/^	const_iterator const_begin() const {$/;"	f	class:rope
const_end	.\stl_rope.h	/^	const_iterator const_end() const {$/;"	f	class:rope
const_iterator	.\std\bastring.h	/^  typedef const_pointer const_iterator;$/;"	t	class:basic_string
const_iterator	.\stl_bvector.h	/^  typedef __bit_const_iterator          const_iterator;$/;"	t	class:vector
const_iterator	.\stl_bvector.h	/^  typedef __bit_const_iterator const_iterator;$/;"	t	struct:__bit_const_iterator
const_iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;$/;"	t	class:__deque_iterator::deque
const_iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:__deque_iterator
const_iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*>          const_iterator;$/;"	t	class:__deque_iterator::deque
const_iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__deque_iterator::__deque_iterator
const_iterator	.\stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_map
const_iterator	.\stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multimap
const_iterator	.\stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multiset
const_iterator	.\stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_set
const_iterator	.\stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_const_iterator
const_iterator	.\stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_iterator
const_iterator	.\stl_hashtable.h	/^  const_iterator;$/;"	t	class:hashtable
const_iterator	.\stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:list
const_iterator	.\stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__list_iterator
const_iterator	.\stl_map.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:map
const_iterator	.\stl_multimap.h	/^  typedef typename rep_type::const_iterator const_iterator; $/;"	t	class:multimap
const_iterator	.\stl_multiset.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:multiset
const_iterator	.\stl_rope.h	/^	typedef __rope_const_iterator<charT,Alloc> const_iterator;$/;"	t	class:rope
const_iterator	.\stl_set.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:set
const_iterator	.\stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:slist
const_iterator	.\stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__slist_iterator
const_iterator	.\stl_tree.h	/^          const_iterator;$/;"	t	class:rb_tree
const_iterator	.\stl_tree.h	/^  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;$/;"	t	struct:__rb_tree_iterator
const_iterator	.\stl_vector.h	/^  typedef const value_type* const_iterator;$/;"	t	class:vector
const_mem_fun1_ref_t	.\stl_function.h	/^  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t
const_mem_fun1_ref_t	.\stl_function.h	/^class const_mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c
const_mem_fun1_ref_t	.\stl_function.h	/^class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c
const_mem_fun1_t	.\stl_function.h	/^  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t
const_mem_fun1_t	.\stl_function.h	/^class const_mem_fun1_t : public binary_function<const T*, A, S> {$/;"	c
const_mem_fun1_t	.\stl_function.h	/^class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {$/;"	c
const_mem_fun_ref_t	.\stl_function.h	/^  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t
const_mem_fun_ref_t	.\stl_function.h	/^class const_mem_fun_ref_t : public unary_function<T, S> {$/;"	c
const_mem_fun_ref_t	.\stl_function.h	/^class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c
const_mem_fun_t	.\stl_function.h	/^  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t
const_mem_fun_t	.\stl_function.h	/^class const_mem_fun_t : public unary_function<const T*, S> {$/;"	c
const_mem_fun_t	.\stl_function.h	/^class const_mem_fun_t<void, T> : public unary_function<const T*, void> {$/;"	c
const_pointer	.\defalloc.h	/^    typedef const T* const_pointer;$/;"	t	class:allocator
const_pointer	.\std\bastring.h	/^  typedef const charT* const_pointer;$/;"	t	class:basic_string
const_pointer	.\stl_bvector.h	/^  typedef const bool* const_pointer;$/;"	t	class:vector
const_pointer	.\stl_deque.h	/^  typedef const value_type* const_pointer;$/;"	t	class:__deque_iterator::deque
const_pointer	.\stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_map
const_pointer	.\stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multimap
const_pointer	.\stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multiset
const_pointer	.\stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_set
const_pointer	.\stl_hashtable.h	/^  typedef const value_type* const_pointer;$/;"	t	class:hashtable
const_pointer	.\stl_list.h	/^  typedef const value_type* const_pointer;$/;"	t	class:list
const_pointer	.\stl_map.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:map
const_pointer	.\stl_multimap.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multimap
const_pointer	.\stl_multiset.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multiset
const_pointer	.\stl_rope.h	/^	typedef const charT* const_pointer;$/;"	t	class:rope
const_pointer	.\stl_set.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:set
const_pointer	.\stl_slist.h	/^  typedef const value_type* const_pointer;$/;"	t	class:slist
const_pointer	.\stl_tree.h	/^  typedef const value_type* const_pointer;$/;"	t	class:rb_tree
const_pointer	.\stl_vector.h	/^  typedef const value_type* const_pointer;$/;"	t	class:vector
const_rbegin	.\stl_rope.h	/^	const_reverse_iterator const_rbegin() const {$/;"	f	class:rope
const_reference	.\defalloc.h	/^    typedef const T& const_reference;$/;"	t	class:allocator
const_reference	.\std\bastring.h	/^  typedef const charT& const_reference;$/;"	t	class:basic_string
const_reference	.\stl_bvector.h	/^  typedef bool                 const_reference;$/;"	t	struct:__bit_const_iterator
const_reference	.\stl_bvector.h	/^  typedef bool const_reference;$/;"	t	class:vector
const_reference	.\stl_deque.h	/^  typedef const value_type& const_reference;$/;"	t	class:__deque_iterator::deque
const_reference	.\stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_map
const_reference	.\stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multimap
const_reference	.\stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multiset
const_reference	.\stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_set
const_reference	.\stl_hashtable.h	/^  typedef const value_type& const_reference;$/;"	t	class:hashtable
const_reference	.\stl_list.h	/^  typedef const value_type& const_reference;$/;"	t	class:list
const_reference	.\stl_map.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:map
const_reference	.\stl_multimap.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multimap
const_reference	.\stl_multiset.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multiset
const_reference	.\stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:priority_queue
const_reference	.\stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:queue
const_reference	.\stl_rope.h	/^	typedef charT const_reference;$/;"	t	class:rope
const_reference	.\stl_set.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:set
const_reference	.\stl_slist.h	/^  typedef const value_type& const_reference;$/;"	t	class:slist
const_reference	.\stl_stack.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:stack
const_reference	.\stl_tree.h	/^  typedef const value_type& const_reference;$/;"	t	class:rb_tree
const_reference	.\stl_vector.h	/^  typedef const value_type& const_reference;$/;"	t	class:vector
const_rend	.\stl_rope.h	/^	const_reverse_iterator const_rend() const {$/;"	f	class:rope
const_reverse_iterator	.\std\bastring.h	/^  typedef ::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:basic_string
const_reverse_iterator	.\stl_bvector.h	/^                           difference_type> const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	.\stl_bvector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	.\stl_deque.h	/^          const_reverse_iterator;$/;"	t	class:__deque_iterator::deque
const_reverse_iterator	.\stl_deque.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:__deque_iterator::deque
const_reverse_iterator	.\stl_list.h	/^  const_reverse_iterator;$/;"	t	class:list
const_reverse_iterator	.\stl_list.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:list
const_reverse_iterator	.\stl_map.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:map
const_reverse_iterator	.\stl_multimap.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multimap
const_reverse_iterator	.\stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multiset
const_reverse_iterator	.\stl_rope.h	/^				 difference_type>  const_reverse_iterator;$/;"	t	class:rope
const_reverse_iterator	.\stl_rope.h	/^        typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rope
const_reverse_iterator	.\stl_set.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:set
const_reverse_iterator	.\stl_tree.h	/^          const_reverse_iterator;$/;"	t	class:rb_tree
const_reverse_iterator	.\stl_tree.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rb_tree
const_reverse_iterator	.\stl_vector.h	/^                           difference_type>  const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	.\stl_vector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector
constant0	.\stl_function.h	/^inline constant_void_fun<Result> constant0(const Result& val)$/;"	f
constant1	.\stl_function.h	/^inline constant_unary_fun<Result,Result> constant1(const Result& val)$/;"	f
constant2	.\stl_function.h	/^inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)$/;"	f
constant_binary_fun	.\stl_function.h	/^  constant_binary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_binary_fun
constant_binary_fun	.\stl_function.h	/^struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {$/;"	s
constant_unary_fun	.\stl_function.h	/^  constant_unary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_unary_fun
constant_unary_fun	.\stl_function.h	/^struct constant_unary_fun : public unary_function<Argument, Result> {$/;"	s
constant_void_fun	.\stl_function.h	/^  constant_void_fun(const result_type& v) : val(v) {}$/;"	f	struct:constant_void_fun
constant_void_fun	.\stl_function.h	/^struct constant_void_fun$/;"	s
construct	.\stl_construct.h	/^inline void construct(T1* p, const T2& value) {$/;"	f
container	.\stl_iterator.h	/^  Container* container;$/;"	m	class:back_insert_iterator
container	.\stl_iterator.h	/^  Container* container;$/;"	m	class:front_insert_iterator
container	.\stl_iterator.h	/^  Container* container;$/;"	m	class:insert_iterator
container	.\stl_rope.h	/^    rope<charT,Alloc>& container() { return *root_rope; }$/;"	f	class:__rope_iterator
cookie	.\libio.h	/^  void *cookie;$/;"	m	struct:_IO_cookie_file
copy	.\std\bastring.cc	/^copy (charT* s, size_type n, size_type pos) const$/;"	f	class:basic_string
copy	.\std\bastring.cc	/^copy (size_t pos, const charT *s, size_t n)$/;"	f	class:basic_string::Rep
copy	.\std\straits.h	/^  static char_type* copy (char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
copy	.\stl_algobase.h	/^inline OutputIterator copy(InputIterator first, InputIterator last,$/;"	f
copy	.\stl_algobase.h	/^inline char* copy(const char* first, const char* last, char* result) {$/;"	f
copy	.\stl_algobase.h	/^inline wchar_t* copy(const wchar_t* first, const wchar_t* last,$/;"	f
copy	.\stl_rope.h	/^	      size_type copy(charT *buffer, size_type n, size_type pos = 0)$/;"	f	class:rope
copy	.\stl_rope.h	/^	size_type copy(size_type pos, size_type n, charT *buffer) const {$/;"	f	class:rope
copy	.\stl_rope.h	/^	void copy(charT * buffer) const {$/;"	f	class:rope
copy_backward	.\stl_algobase.h	/^inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, $/;"	f
copy_from	.\stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)$/;"	f	class:hashtable
copy_max	.\stl_rope.h	/^	enum { copy_max = 23 };$/;"	e	enum:rope::__anon14
copy_n	.\stl_algobase.h	/^copy_n(InputIterator first, Size count,$/;"	f
cos	.\std\complext.cc	/^cos (const complex<FLOAT>& x)$/;"	f
cosh	.\std\complext.cc	/^cosh (const complex<FLOAT>& x)$/;"	f
count	.\ropeimpl.h	/^	size_t count;  \/\/ Number of nonmatching characters$/;"	m	class:__rope_find_char_char_consumer
count	.\stl_algo.h	/^count(InputIterator first, InputIterator last, const T& value) {$/;"	f
count	.\stl_algo.h	/^void count(InputIterator first, InputIterator last, const T& value,$/;"	f
count	.\stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_map
count	.\stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multimap
count	.\stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multiset
count	.\stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_set
count	.\stl_hashtable.h	/^  size_type count(const key_type& key) const$/;"	f	class:hashtable
count	.\stl_map.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:map
count	.\stl_multimap.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multimap
count	.\stl_multiset.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multiset
count	.\stl_set.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:set
count	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {$/;"	f	class:rb_tree
count_if	.\stl_algo.h	/^count_if(InputIterator first, InputIterator last, Predicate pred) {$/;"	f
count_if	.\stl_algo.h	/^void count_if(InputIterator first, InputIterator last, Predicate pred,$/;"	f
create	.\std\bastring.cc	/^create (size_t extra)$/;"	f	class:basic_string::Rep
create_map_and_nodes	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {$/;"	f	class:__deque_iterator::deque
create_node	.\stl_list.h	/^  link_type create_node(const T& x) {$/;"	f	class:list
create_node	.\stl_slist.h	/^  static list_node* create_node(const value_type& x) {$/;"	f	class:slist
create_node	.\stl_tree.h	/^  link_type create_node(const value_type& x) {$/;"	f	class:rb_tree
crope	.\stl_rope.h	/^typedef rope<char, __ALLOC> crope;$/;"	t
cstrptr	.\stl_rope.h	/^	typedef __GC_CONST charT * cstrptr;$/;"	t	class:rope
cur	.\stl_deque.h	/^  T* cur;$/;"	m	struct:__deque_iterator::__deque_iterator
cur	.\stl_hashtable.h	/^  const node* cur;$/;"	m	struct:__hashtable_const_iterator
cur	.\stl_hashtable.h	/^  node* cur;$/;"	m	struct:__hashtable_iterator
cur	.\streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	e	enum:ios::seek_dir
cur_ptr	.\streambuf.h	/^    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }$/;"	f	class:filebuf
current	.\editbuf.h	/^    buf_char* current() { return is_reading() ? gptr() : pptr(); }$/;"	f	struct:edit_streambuf
current	.\stl_iterator.h	/^  BidirectionalIterator current;$/;"	m	class:reverse_bidirectional_iterator
current	.\stl_iterator.h	/^  Iterator current;$/;"	m	class:reverse_iterator
current	.\stl_iterator.h	/^  RandomAccessIterator current;$/;"	m	class:reverse_iterator
current	.\stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ptr_proxy
current	.\stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ref_proxy
current_pos	.\stl_rope.h	/^    size_t current_pos;$/;"	m	class:__rope_iterator_base
current_valid	.\stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ptr_proxy
current_valid	.\stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ref_proxy
dat	.\std\bastring.h	/^  charT *dat;$/;"	m	class:basic_string
data	.\editbuf.h	/^    buf_char *data; \/* == emacs buffer_text.p1+1 *\/$/;"	m	struct:edit_buffer
data	.\std\bastring.h	/^    charT* data () { return reinterpret_cast<charT *>(this + 1); }$/;"	f	struct:basic_string::Rep
data	.\std\bastring.h	/^  const charT* data () const$/;"	f	class:basic_string
data	.\stl_list.h	/^  T data;$/;"	m	struct:__list_node
data	.\stl_rope.h	/^    __GC_CONST charT* data;     \/* Not necessarily 0 terminated. *\/$/;"	m	struct:__rope_RopeLeaf
data	.\stl_slist.h	/^  T data;$/;"	m	struct:__slist_node
data_allocator	.\stl_bvector.h	/^  typedef simple_alloc<unsigned int, Alloc> data_allocator;$/;"	t	class:vector
data_allocator	.\stl_deque.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:__deque_iterator::deque
data_allocator	.\stl_vector.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:vector
data_type	.\stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_map
data_type	.\stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_multimap
data_type	.\stl_map.h	/^  typedef T data_type;$/;"	t	class:map
data_type	.\stl_multimap.h	/^  typedef T data_type;$/;"	t	class:multimap
deallocate	.\defalloc.h	/^    void deallocate(pointer p) { ::deallocate(p); }$/;"	f	class:allocator
deallocate	.\defalloc.h	/^inline void deallocate(T* buffer) {$/;"	f
deallocate	.\stl_alloc.h	/^    static void deallocate(T *p)$/;"	f	class:simple_alloc
deallocate	.\stl_alloc.h	/^    static void deallocate(T *p, size_t n)$/;"	f	class:simple_alloc
deallocate	.\stl_alloc.h	/^  static void deallocate(void *p, size_t n)$/;"	f	class:__default_alloc_template
deallocate	.\stl_alloc.h	/^static void deallocate(void *p, size_t \/* n *\/)$/;"	f	class:__malloc_alloc_template
deallocate	.\stl_alloc.h	/^static void deallocate(void *p, size_t n)$/;"	f	class:debug_alloc
deallocate	.\stl_bvector.h	/^  void deallocate() {$/;"	f	class:vector
deallocate	.\stl_vector.h	/^  void deallocate() {$/;"	f	class:vector
deallocate_node	.\stl_deque.h	/^  void deallocate_node(pointer n) {$/;"	f	class:__deque_iterator::deque
debug_alloc	.\stl_alloc.h	/^class debug_alloc {$/;"	c
dec	.\iostream.h	/^inline ios& dec(ios& i)$/;"	f
dec	.\streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon15
decr	.\ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::decr(size_t n) {$/;"	f	class:__rope_iterator_base
decr_refcount	.\stl_rope.h	/^	    size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase
decr_refcount	.\stl_rope.h	/^            size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase
decrement	.\stl_tree.h	/^  void decrement()$/;"	f	struct:__rb_tree_base_iterator
delete_buf	.\parsestream.h	/^    int delete_buf; \/\/ Delete sbuf when destroying this.$/;"	m	class:general_parsebuf
delete_c_str	.\stl_rope.h	/^	void delete_c_str () {$/;"	f	class:rope
delete_node	.\stl_hashtable.h	/^  void delete_node(node* n)$/;"	f	class:hashtable
delete_when_done	.\stl_rope.h	/^      bool delete_when_done;	\/\/ Char_producer is owned by the$/;"	m	struct:__rope_RopeFunction
depth	.\stl_rope.h	/^    unsigned char depth;$/;"	m	struct:__rope_RopeBase
deque	.\stl_deque.h	/^  deque()$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(InputIterator first, InputIterator last)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(const deque& x)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(const value_type* first, const value_type* last)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(const_iterator first, const_iterator last)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(int n, const value_type& value)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(long n, const value_type& value)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  deque(size_type n, const value_type& value)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^  explicit deque(size_type n)$/;"	f	class:__deque_iterator::deque
deque	.\stl_deque.h	/^class deque {$/;"	c	struct:__deque_iterator
destr_concat_char_iter	.\ropeimpl.h	/^::destr_concat_char_iter$/;"	f	class:rope
destr_concat_char_iter	.\stl_rope.h	/^	static RopeBase * destr_concat_char_iter(RopeBase * r,$/;"	f	class:rope
destr_leaf_concat_char_iter	.\ropeimpl.h	/^rope<charT,Alloc>::destr_leaf_concat_char_iter$/;"	f	class:rope
destroy	.\stl_construct.h	/^inline void destroy(ForwardIterator first, ForwardIterator last) {$/;"	f
destroy	.\stl_construct.h	/^inline void destroy(T* pointer) {$/;"	f
destroy	.\stl_construct.h	/^inline void destroy(char*, char*) {}$/;"	f
destroy	.\stl_construct.h	/^inline void destroy(wchar_t*, wchar_t*) {}$/;"	f
destroy_map_and_nodes	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {$/;"	f	class:__deque_iterator::deque
destroy_node	.\stl_list.h	/^  void destroy_node(link_type p) {$/;"	f	class:list
destroy_node	.\stl_slist.h	/^  static void destroy_node(list_node* node) {$/;"	f	class:slist
destroy_node	.\stl_tree.h	/^  void destroy_node(link_type p) {$/;"	f	class:rb_tree
destroy_nodes_at_back	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) {$/;"	f	class:__deque_iterator::deque
destroy_nodes_at_front	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) {$/;"	f	class:__deque_iterator::deque
difference_type	.\defalloc.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator
difference_type	.\std\bastring.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:basic_string
difference_type	.\stl_bvector.h	/^  typedef ptrdiff_t difference_type; $/;"	t	class:vector
difference_type	.\stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:__deque_iterator::deque
difference_type	.\stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__deque_iterator::__deque_iterator
difference_type	.\stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_map
difference_type	.\stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multimap
difference_type	.\stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multiset
difference_type	.\stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_set
difference_type	.\stl_hashtable.h	/^  typedef ptrdiff_t         difference_type;$/;"	t	class:hashtable
difference_type	.\stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_const_iterator
difference_type	.\stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_iterator
difference_type	.\stl_iterator.h	/^          difference_type;$/;"	t	class:reverse_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_bidirectional_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:bidirectional_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:random_access_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance             difference_type;$/;"	t	struct:forward_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	class:istream_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	struct:input_iterator
difference_type	.\stl_iterator.h	/^  typedef Distance  difference_type;$/;"	t	struct:iterator
difference_type	.\stl_iterator.h	/^  typedef ptrdiff_t                  difference_type;$/;"	t	struct:iterator_traits
difference_type	.\stl_iterator.h	/^  typedef typename Iterator::difference_type   difference_type;$/;"	t	struct:iterator_traits
difference_type	.\stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:back_insert_iterator
difference_type	.\stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:front_insert_iterator
difference_type	.\stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:insert_iterator
difference_type	.\stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:ostream_iterator
difference_type	.\stl_iterator.h	/^  typedef void                difference_type;$/;"	t	struct:output_iterator
difference_type	.\stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:list
difference_type	.\stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__list_iterator
difference_type	.\stl_map.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:map
difference_type	.\stl_multimap.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multimap
difference_type	.\stl_multiset.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multiset
difference_type	.\stl_raw_storage_iter.h	/^  typedef void                difference_type;$/;"	t	class:raw_storage_iterator
difference_type	.\stl_rope.h	/^	typedef ptrdiff_t difference_type;$/;"	t	class:rope
difference_type	.\stl_set.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:set
difference_type	.\stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:slist
difference_type	.\stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__slist_iterator_base
difference_type	.\stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:rb_tree
difference_type	.\stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__rb_tree_base_iterator
difference_type	.\stl_vector.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:vector
distance	.\stl_iterator.h	/^distance(InputIterator first, InputIterator last) {$/;"	f
distance	.\stl_iterator.h	/^inline void distance(InputIterator first, InputIterator last, Distance& n) {$/;"	f
distance_type	.\stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator
distance_type	.\stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator
distance_type	.\stl_hashtable.h	/^distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
distance_type	.\stl_hashtable.h	/^distance_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
distance_type	.\stl_iterator.h	/^distance_type(const Iterator&) {$/;"	f
distance_type	.\stl_iterator.h	/^distance_type(const bidirectional_iterator<T, Distance>&) {$/;"	f
distance_type	.\stl_iterator.h	/^distance_type(const random_access_iterator<T, Distance>&) {$/;"	f
distance_type	.\stl_iterator.h	/^distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f
distance_type	.\stl_iterator.h	/^inline Distance* distance_type(const forward_iterator<T, Distance>&) {$/;"	f
distance_type	.\stl_iterator.h	/^inline Distance* distance_type(const input_iterator<T, Distance>&) {$/;"	f
distance_type	.\stl_iterator.h	/^inline Distance* distance_type(const istream_iterator<T, Distance>&) {$/;"	f
distance_type	.\stl_iterator.h	/^inline Distance* distance_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f
distance_type	.\stl_iterator.h	/^inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }$/;"	f
distance_type	.\stl_list.h	/^distance_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f
distance_type	.\stl_slist.h	/^distance_type(const __slist_iterator_base&)$/;"	f
distance_type	.\stl_tree.h	/^distance_type(const __rb_tree_base_iterator&) {$/;"	f
divides	.\stl_function.h	/^struct divides : public binary_function<T, T, T> {$/;"	s
do_delete	.\parsestream.h	/^    int do_delete;$/;"	m	class:string_parsebuf
dont_close	.\streambuf.h	/^	   , dont_close=_IO_DONT_CLOSE \/\/ Don't delete streambuf on stream destruction$/;"	e	enum:ios::__anon15
dump	.\ropeimpl.h	/^rope<charT,Alloc>::dump(RopeBase * r, int indent)$/;"	f	class:rope
dump	.\stl_rope.h	/^	void dump() {$/;"	f	class:rope
eBptr	.\streambuf.h	/^    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }$/;"	f	struct:streambuf
eGptr	.\streambuf.h	/^    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }$/;"	f	struct:streambuf
eNptr	.\streambuf.h	/^    char *eNptr() { return _IO_save_end; }$/;"	f	struct:streambuf
eback	.\streambuf.h	/^    char* eback() const$/;"	f	struct:streambuf
ebuf	.\streambuf.h	/^    char* ebuf() const { return _IO_buf_end; }$/;"	f	struct:streambuf
edit_buffer	.\editbuf.h	/^struct edit_buffer {$/;"	s
edit_mark	.\editbuf.h	/^    edit_mark() { }$/;"	f	struct:edit_mark
edit_mark	.\editbuf.h	/^struct edit_mark {$/;"	s
edit_streambuf	.\editbuf.h	/^struct edit_streambuf : public streambuf {$/;"	s
edit_string	.\editbuf.h	/^    edit_string(struct edit_buffer *b,$/;"	f	struct:edit_string
edit_string	.\editbuf.h	/^struct edit_string {$/;"	s
egptr	.\streambuf.h	/^    char* egptr() const$/;"	f	struct:streambuf
elems_in_bucket	.\stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_map
elems_in_bucket	.\stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multimap
elems_in_bucket	.\stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multiset
elems_in_bucket	.\stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_set
elems_in_bucket	.\stl_hashtable.h	/^  size_type elems_in_bucket(size_type bucket) const$/;"	f	class:hashtable
empty	.\std\bastring.h	/^  bool empty () const$/;"	f	class:basic_string
empty	.\stl_bvector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector
empty	.\stl_deque.h	/^  bool empty() const { return finish == start; }$/;"	f	class:__deque_iterator::deque
empty	.\stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_map
empty	.\stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multimap
empty	.\stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multiset
empty	.\stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_set
empty	.\stl_hashtable.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:hashtable
empty	.\stl_list.h	/^  bool empty() const { return node->next == node; }$/;"	f	class:list
empty	.\stl_map.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:map
empty	.\stl_multimap.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multimap
empty	.\stl_multiset.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multiset
empty	.\stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:priority_queue
empty	.\stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:queue
empty	.\stl_rope.h	/^	bool empty() const { return 0 == tree_ptr; }$/;"	f	class:rope
empty	.\stl_set.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:set
empty	.\stl_slist.h	/^  bool empty() const { return head.next == 0; }$/;"	f	class:slist
empty	.\stl_stack.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:stack
empty	.\stl_tree.h	/^  bool empty() const { return node_count == 0; }$/;"	f	class:rb_tree
empty	.\stl_vector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector
empty_c_str	.\ropeimpl.h	/^template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];$/;"	m	class:rope
empty_c_str	.\stl_rope.h	/^	static charT empty_c_str[1];$/;"	m	class:rope
empty_initialize	.\stl_list.h	/^  void empty_initialize() { $/;"	f	class:list
end	.\editbuf.h	/^    struct edit_mark *start, *end;$/;"	m	struct:edit_string	typeref:struct:edit_string::
end	.\std\bastring.h	/^  const_iterator end () const { return iend (); }$/;"	f	class:basic_string
end	.\std\bastring.h	/^  iterator end () { selfish (); return &(*this)[length ()]; }$/;"	f	class:basic_string
end	.\stl_bvector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector
end	.\stl_bvector.h	/^  iterator end() { return finish; }$/;"	f	class:vector
end	.\stl_deque.h	/^  const_iterator end() const { return finish; }$/;"	f	class:__deque_iterator::deque
end	.\stl_deque.h	/^  iterator end() { return finish; }$/;"	f	class:__deque_iterator::deque
end	.\stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_map
end	.\stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_multimap
end	.\stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_map
end	.\stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_multimap
end	.\stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_multiset
end	.\stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_set
end	.\stl_hashtable.h	/^  const_iterator end() const { return const_iterator(0, this); }$/;"	f	class:hashtable
end	.\stl_hashtable.h	/^  iterator end() { return iterator(0, this); }$/;"	f	class:hashtable
end	.\stl_list.h	/^  const_iterator end() const { return node; }$/;"	f	class:list
end	.\stl_list.h	/^  iterator end() { return node; }$/;"	f	class:list
end	.\stl_map.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:map
end	.\stl_map.h	/^  iterator end() { return t.end(); }$/;"	f	class:map
end	.\stl_multimap.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:multimap
end	.\stl_multimap.h	/^  iterator end() { return t.end(); }$/;"	f	class:multimap
end	.\stl_multiset.h	/^  iterator end() const { return t.end(); }$/;"	f	class:multiset
end	.\stl_rope.h	/^	    const_iterator end() { return const_end(); }$/;"	f	class:rope
end	.\stl_rope.h	/^	    iterator end() { return mutable_end(); }$/;"	f	class:rope
end	.\stl_rope.h	/^	const_iterator end() const {$/;"	f	class:rope
end	.\stl_set.h	/^  iterator end() const { return t.end(); }$/;"	f	class:set
end	.\stl_slist.h	/^  const_iterator end() const { return const_iterator(0); }$/;"	f	class:slist
end	.\stl_slist.h	/^  iterator end() { return iterator(0); }$/;"	f	class:slist
end	.\stl_tempbuf.h	/^  T* end() { return buffer + len; }$/;"	f	class:temporary_buffer
end	.\stl_tree.h	/^  const_iterator end() const { return header; }$/;"	f	class:rb_tree
end	.\stl_tree.h	/^  iterator end() { return header; }$/;"	f	class:rb_tree
end	.\stl_vector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector
end	.\stl_vector.h	/^  iterator end() { return finish; }$/;"	f	class:vector
end	.\streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	e	enum:ios::seek_dir
end_free	.\stl_alloc.h	/^  static char *end_free;$/;"	m	class:__default_alloc_template
end_free	.\stl_alloc.h	/^char *__default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:__default_alloc_template
end_mark	.\editbuf.h	/^    struct edit_mark end_mark;$/;"	m	struct:edit_buffer	typeref:struct:edit_buffer::edit_mark
end_marker	.\editbuf.h	/^    inline struct edit_mark *end_marker() { return &end_mark; }$/;"	f	struct:edit_buffer
end_marker	.\stl_iterator.h	/^  bool end_marker;$/;"	m	class:istream_iterator
end_of_storage	.\stl_bvector.h	/^  unsigned int* end_of_storage;$/;"	m	class:vector
end_of_storage	.\stl_vector.h	/^  iterator end_of_storage;$/;"	m	class:vector
eof	.\streambuf.h	/^    int eof() const { return _state & ios::eofbit; }$/;"	f	class:ios
eofbit	.\streambuf.h	/^	eofbit = _IOS_EOF,$/;"	e	enum:ios::io_state
eos	.\std\bastring.h	/^  static charT eos () { return traits::eos (); }$/;"	f	class:basic_string
eos	.\std\straits.h	/^  static char_type eos () { return 0; }$/;"	f	struct:string_char_traits
eos	.\std\straits.h	/^  static char_type eos () { return char_type(); } \/\/ the null character$/;"	f	struct:string_char_traits
epptr	.\streambuf.h	/^    char* epptr() const { return _IO_write_end; }$/;"	f	struct:streambuf
eq	.\std\straits.h	/^  static bool eq (const char_type & c1, const char_type& c2)$/;"	f	struct:string_char_traits
eq	.\std\straits.h	/^  static bool eq (const char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
equal	.\stl_algobase.h	/^inline bool equal(InputIterator1 first1, InputIterator1 last1,$/;"	f
equal_range	.\stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f
equal_range	.\stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
equal_range	.\stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_map
equal_range	.\stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multimap
equal_range	.\stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_map
equal_range	.\stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_multimap
equal_range	.\stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multiset
equal_range	.\stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_set
equal_range	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const$/;"	f	class:hashtable
equal_range	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)$/;"	f	class:hashtable
equal_range	.\stl_map.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:map
equal_range	.\stl_map.h	/^  pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:map
equal_range	.\stl_multimap.h	/^   pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:multimap
equal_range	.\stl_multimap.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:multimap
equal_range	.\stl_multiset.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:multiset
equal_range	.\stl_set.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:set
equal_range	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {$/;"	f	class:rb_tree
equal_range	.\stl_tree.h	/^rb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {$/;"	f	class:rb_tree
equal_to	.\stl_function.h	/^struct equal_to : public binary_function<T, T, bool> {$/;"	s
equals	.\stl_hashtable.h	/^  key_equal equals;$/;"	m	class:hashtable
erase	.\std\bastring.h	/^  basic_string& erase (size_type pos = 0, size_type n = npos)$/;"	f	class:basic_string
erase	.\std\bastring.h	/^  iterator erase(iterator f, iterator l)$/;"	f	class:basic_string
erase	.\std\bastring.h	/^  iterator erase(iterator p)$/;"	f	class:basic_string
erase	.\stl_bvector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector
erase	.\stl_bvector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector
erase	.\stl_deque.h	/^  iterator erase(iterator pos) {$/;"	f	class:__deque_iterator::deque
erase	.\stl_deque.h	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {$/;"	f	class:__deque_iterator::deque
erase	.\stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_map
erase	.\stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multimap
erase	.\stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_map
erase	.\stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multimap
erase	.\stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_map
erase	.\stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multimap
erase	.\stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multiset
erase	.\stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_set
erase	.\stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multiset
erase	.\stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_set
erase	.\stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multiset
erase	.\stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_set
erase	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)$/;"	f	class:hashtable
erase	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)$/;"	f	class:hashtable
erase	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,$/;"	f	class:hashtable
erase	.\stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)$/;"	f	class:hashtable
erase	.\stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)$/;"	f	class:hashtable
erase	.\stl_list.h	/^  iterator erase(iterator position) {$/;"	f	class:list
erase	.\stl_list.h	/^list<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:list
erase	.\stl_map.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:map
erase	.\stl_map.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:map
erase	.\stl_map.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:map
erase	.\stl_multimap.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:multimap
erase	.\stl_multimap.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:multimap
erase	.\stl_multimap.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:multimap
erase	.\stl_multiset.h	/^  size_type erase(const key_type& x) { $/;"	f	class:multiset
erase	.\stl_multiset.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:multiset
erase	.\stl_multiset.h	/^  void erase(iterator position) { $/;"	f	class:multiset
erase	.\stl_rope.h	/^	iterator erase(const iterator &p, const iterator &q) {$/;"	f	class:rope
erase	.\stl_rope.h	/^	void erase(size_t p) {$/;"	f	class:rope
erase	.\stl_rope.h	/^	void erase(size_t p, size_t n) {$/;"	f	class:rope
erase	.\stl_rope.h	/^        iterator erase(const iterator &p) {$/;"	f	class:rope
erase	.\stl_set.h	/^  size_type erase(const key_type& x) { $/;"	f	class:set
erase	.\stl_set.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:set
erase	.\stl_set.h	/^  void erase(iterator position) { $/;"	f	class:set
erase	.\stl_slist.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:slist
erase	.\stl_slist.h	/^  iterator erase(iterator pos) {$/;"	f	class:slist
erase	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {$/;"	f	class:rb_tree
erase	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:rb_tree
erase	.\stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, $/;"	f	class:rb_tree
erase	.\stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, $/;"	f	class:rb_tree
erase	.\stl_vector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector
erase	.\stl_vector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector
erase_after	.\stl_slist.h	/^  iterator erase_after(iterator before_first, iterator last) {$/;"	f	class:slist
erase_after	.\stl_slist.h	/^  iterator erase_after(iterator pos) {$/;"	f	class:slist
erase_after	.\stl_slist.h	/^  list_node_base* erase_after(list_node_base* before_first,$/;"	f	class:slist
erase_after	.\stl_slist.h	/^  list_node_base* erase_after(list_node_base* pos) {$/;"	f	class:slist
erase_bucket	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)$/;"	f	class:hashtable
erase_bucket	.\stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, $/;"	f	class:hashtable
exceptions	.\streambuf.h	/^    iostate exceptions() const { return _exceptions; }$/;"	f	class:ios
exceptions	.\streambuf.h	/^    void exceptions(iostate enable) {$/;"	f	class:ios
excess_slop	.\std\bastring.cc	/^excess_slop (size_t s, size_t r)$/;"	f	class:basic_string::Rep
exp	.\std\complext.cc	/^exp (const complex<FLOAT>& x)$/;"	f
explicit	.\stl_config.h	188;"	d
extra	.\stl_alloc.h	/^enum {extra = 8};       \/\/ Size of space used to store size.  Note$/;"	e	enum:debug_alloc::__anon2
f	.\iomanip.h	/^    iapp(istream& (*f)(istream&,TP)) : _f(f) {}$/;"	f	class:iapp
f	.\iomanip.h	/^    oapp(ostream& (*f)(ostream&,TP)) : _f(f) {}$/;"	f	class:oapp
f	.\iomanip.h	/^    sapp(ios& (*f)(ios&, TP)) : _f(f) {}$/;"	f	class:sapp
f	.\stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t
f	.\stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_t
f	.\stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_ref_t
f	.\stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_t
f	.\stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t
f	.\stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t
f	.\stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_ref_t
f	.\stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_t
f	.\stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t
f	.\stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_t
f	.\stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_ref_t
f	.\stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_t
f	.\stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t
f	.\stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t
f	.\stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_ref_t
f	.\stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_t
fail	.\streambuf.h	/^    int fail() const { return _state & (ios::badbit|ios::failbit); }$/;"	f	class:ios
failbit	.\streambuf.h	/^	failbit = _IOS_FAIL,$/;"	e	enum:ios::io_state
failure	.\streambuf.h	/^	failure(ios* stream) { _stream = stream; }$/;"	f	class:ios::failure
failure	.\streambuf.h	/^	failure(string cause, ios* stream) { _stream = stream; }$/;"	f	class:ios::failure
failure	.\streambuf.h	/^    class failure : public xmsg {$/;"	c	class:ios
false	.\stl_config.h	180;"	d
fclose	.\iostdio.h	63;"	d
fd	.\streambuf.h	/^    int fd() const { return is_open() ? _fileno : EOF; }$/;"	f	class:filebuf
fdopen	.\iostdio.h	106;"	d
feof	.\iostdio.h	64;"	d
ferror	.\iostdio.h	65;"	d
fetch	.\ropeimpl.h	/^rope<charT,Alloc>::fetch(RopeBase *r, size_type i)$/;"	f	class:rope
fetch_ptr	.\ropeimpl.h	/^rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)$/;"	f	class:rope
fflush	.\iostdio.h	66;"	d
fgetc	.\iostdio.h	67;"	d
fgetpos	.\iostdio.h	68;"	d
fgets	.\iostdio.h	69;"	d
field1	.\libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	m	struct:_IO_lock_t
field2	.\libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	m	struct:_IO_lock_t
file	.\libio.h	/^  struct _IO_FILE file;$/;"	m	struct:_IO_cookie_file	typeref:struct:_IO_cookie_file::_IO_FILE
file	.\libioP.h	/^  _IO_FILE file;$/;"	m	struct:_IO_FILE_plus
file_ptr	.\streambuf.h	/^    char* file_ptr() { return eGptr(); }$/;"	f	class:filebuf
filebuf	.\streambuf.h	/^class filebuf : public streambuf {$/;"	c
filedesc	.\fstream.h	/^    int filedesc() { return rdbuf()->fd(); }$/;"	f	class:fstreambase
fileno	.\iostdio.h	107;"	d
files	.\editbuf.h	/^    struct edit_streambuf *files;$/;"	m	struct:edit_buffer	typeref:struct:edit_buffer::edit_streambuf
fill	.\stl_algobase.h	/^void fill(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f
fill	.\streambuf.h	/^    _IO_wchar_t fill() const { return _fill; }$/;"	f	class:ios
fill	.\streambuf.h	/^    _IO_wchar_t fill(_IO_wchar_t newf)$/;"	f	class:ios
fill_initialize	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n,$/;"	f	class:__deque_iterator::deque
fill_initialize	.\stl_list.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:list
fill_initialize	.\stl_slist.h	/^  void fill_initialize(size_type n, const value_type& x) {$/;"	f	class:slist
fill_initialize	.\stl_vector.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:vector
fill_n	.\stl_algobase.h	/^OutputIterator fill_n(OutputIterator first, Size n, const T& value) {$/;"	f
find	.\ropeimpl.h	/^rope<charT,Alloc>::find(charT pattern, size_t start) const$/;"	f	class:rope
find	.\std\bastring.cc	/^find (charT c, size_type pos) const$/;"	f	class:basic_string
find	.\std\bastring.cc	/^find (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find	.\std\bastring.h	/^  size_type find (const basic_string& str, size_type pos = 0) const$/;"	f	class:basic_string
find	.\std\bastring.h	/^  size_type find (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
find	.\stl_algo.h	/^InputIterator find(InputIterator first, InputIterator last, const T& value) {$/;"	f
find	.\stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_map
find	.\stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multimap
find	.\stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_map
find	.\stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_multimap
find	.\stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multiset
find	.\stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_set
find	.\stl_hashtable.h	/^  const_iterator find(const key_type& key) const$/;"	f	class:hashtable
find	.\stl_hashtable.h	/^  iterator find(const key_type& key) $/;"	f	class:hashtable
find	.\stl_map.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:map
find	.\stl_map.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:map
find	.\stl_multimap.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multimap
find	.\stl_multimap.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:multimap
find	.\stl_multiset.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multiset
find	.\stl_rope.h	/^	size_type find(charT *s, size_type pos = 0) const {$/;"	f	class:rope
find	.\stl_set.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:set
find	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {$/;"	f	class:rb_tree
find	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {$/;"	f	class:rb_tree
find_end	.\stl_algo.h	/^find_end(ForwardIterator1 first1, ForwardIterator1 last1, $/;"	f
find_first_not_of	.\std\bastring.cc	/^find_first_not_of (charT c, size_type pos) const$/;"	f	class:basic_string
find_first_not_of	.\std\bastring.cc	/^find_first_not_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_first_not_of	.\std\bastring.h	/^  size_type find_first_not_of (const basic_string& str, size_type pos = 0) const$/;"	f	class:basic_string
find_first_not_of	.\std\bastring.h	/^  size_type find_first_not_of (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	.\std\bastring.cc	/^find_first_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_first_of	.\std\bastring.h	/^  size_type find_first_of (charT c, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	.\std\bastring.h	/^  size_type find_first_of (const basic_string& str, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	.\std\bastring.h	/^  size_type find_first_of (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	.\stl_algo.h	/^InputIterator find_first_of(InputIterator first1, InputIterator last1,$/;"	f
find_if	.\stl_algo.h	/^InputIterator find_if(InputIterator first, InputIterator last,$/;"	f
find_last_not_of	.\std\bastring.cc	/^find_last_not_of (charT c, size_type pos) const$/;"	f	class:basic_string
find_last_not_of	.\std\bastring.cc	/^find_last_not_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_last_not_of	.\std\bastring.h	/^  size_type find_last_not_of (const basic_string& str, size_type pos = npos) const$/;"	f	class:basic_string
find_last_not_of	.\std\bastring.h	/^  size_type find_last_not_of (const charT* s, size_type pos = npos) const$/;"	f	class:basic_string
find_last_of	.\std\bastring.cc	/^find_last_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_last_of	.\std\bastring.h	/^  size_type find_last_of (charT c, size_type pos = npos) const$/;"	f	class:basic_string
find_last_of	.\std\bastring.h	/^  size_type find_last_of (const basic_string& str, size_type pos = npos) const$/;"	f	class:basic_string
find_last_of	.\std\bastring.h	/^  size_type find_last_of (const charT* s, size_type pos = npos) const$/;"	f	class:basic_string
find_or_insert	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)$/;"	f	class:hashtable
finish	.\stl_bvector.h	/^  iterator finish;$/;"	m	class:vector
finish	.\stl_deque.h	/^  iterator finish;$/;"	m	class:__deque_iterator::deque
finish	.\stl_vector.h	/^  iterator finish;$/;"	m	class:vector
first	.\stl_deque.h	/^  T* first;$/;"	m	struct:__deque_iterator::__deque_iterator
first	.\stl_pair.h	/^  T1 first;$/;"	m	struct:pair
first_argument_type	.\stl_function.h	/^    typedef Arg1 first_argument_type;$/;"	t	struct:binary_function
first_type	.\stl_pair.h	/^  typedef T1 first_type;$/;"	t	struct:pair
fixed	.\streambuf.h	/^	   scientific=_IO_SCIENTIFIC, fixed=_IO_FIXED,$/;"	e	enum:ios::__anon15
flags	.\streambuf.h	/^    fmtflags flags() const { return _flags; }$/;"	f	class:ios
flags	.\streambuf.h	/^    fmtflags flags(fmtflags new_val) {$/;"	f	class:ios
flatten	.\ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)$/;"	f	class:rope
flatten	.\ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r,$/;"	f	class:rope
flip	.\stl_bvector.h	/^  void flip() { *p ^= mask; }$/;"	f	struct:__bit_reference
floatfield	.\streambuf.h	/^	floatfield = scientific+fixed,$/;"	e	enum:ios::__anon16
flush	.\stl_rope.h	/^	void flush() {$/;"	f	class:sequence_buffer
flush_to_buffer	.\editbuf.h	/^inline void edit_streambuf::flush_to_buffer()$/;"	f	class:edit_streambuf
fmtflags	.\streambuf.h	/^    typedef __fmtflags fmtflags;$/;"	t	class:ios
fn	.\stl_rope.h	/^    char_producer<charT>* fn;$/;"	m	struct:__rope_RopeFunction
fn_finalization_proc	.\ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::fn_finalization_proc(void * tree, void *)$/;"	f	class:__rope_RopeBase
fopen	.\iostdio.h	70;"	d
for_each	.\stl_algo.h	/^Function for_each(InputIterator first, InputIterator last, Function f) {$/;"	f
forward_iterator	.\stl_iterator.h	/^template <class T, class Distance> struct forward_iterator {$/;"	s
forward_iterator_tag	.\stl_iterator.h	/^struct forward_iterator_tag : public input_iterator_tag {};$/;"	s
fprintf	.\iostdio.h	71;"	d
fputc	.\iostdio.h	72;"	d
fputs	.\iostdio.h	73;"	d
fread	.\iostdio.h	74;"	d
free_c_string	.\ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_c_string()$/;"	f	class:__rope_RopeBase
free_if_unref	.\stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
free_if_unref	.\stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
free_list	.\stl_alloc.h	/^    static obj * __VOLATILE free_list[]; $/;"	m	class:__default_alloc_template
free_list	.\stl_alloc.h	/^    static obj * __VOLATILE free_list[__NFREELISTS]; $/;"	m	class:__default_alloc_template
free_list	.\stl_alloc.h	/^__default_alloc_template<threads, inst> ::free_list[$/;"	m	class:__default_alloc_template
free_list_link	.\stl_alloc.h	/^        union obj * free_list_link;$/;"	m	union:__default_alloc_template::obj	typeref:union:__default_alloc_template::obj::obj
free_string	.\ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)$/;"	f	class:__rope_RopeBase
free_tree	.\ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::free_tree()$/;"	f	class:__rope_RopeBase
freeze	.\strstream.h	/^    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }$/;"	f	class:ostrstream
freeze	.\strstream.h	/^    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }$/;"	f	class:strstream
freeze	.\strstream.h	/^    void freeze(int n=1)$/;"	f	class:strstreambuf
freopen	.\iostdio.h	75;"	d
frob_size	.\std\bastring.cc	/^frob_size (size_t s)$/;"	f	class:basic_string::Rep
front	.\stl_bvector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector
front	.\stl_bvector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector
front	.\stl_deque.h	/^  const_reference front() const { return *start; }$/;"	f	class:__deque_iterator::deque
front	.\stl_deque.h	/^  reference front() { return *start; }$/;"	f	class:__deque_iterator::deque
front	.\stl_list.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:list
front	.\stl_list.h	/^  reference front() { return *begin(); }$/;"	f	class:list
front	.\stl_queue.h	/^  const_reference front() const { return c.front(); }$/;"	f	class:queue
front	.\stl_queue.h	/^  reference front() { return c.front(); }$/;"	f	class:queue
front	.\stl_rope.h	/^	charT front() const$/;"	f	class:rope
front	.\stl_slist.h	/^  const_reference front() const { return ((list_node*) head.next)->data; }$/;"	f	class:slist
front	.\stl_slist.h	/^  reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:slist
front	.\stl_vector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector
front	.\stl_vector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector
front_insert_iterator	.\stl_iterator.h	/^  explicit front_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:front_insert_iterator
front_insert_iterator	.\stl_iterator.h	/^class front_insert_iterator {$/;"	c
front_inserter	.\stl_iterator.h	/^inline front_insert_iterator<Container> front_inserter(Container& x) {$/;"	f
frozen	.\strstream.h	/^    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }$/;"	f	class:ostrstream
frozen	.\strstream.h	/^    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }$/;"	f	class:strstream
frozen	.\strstream.h	/^    int frozen() { return _flags & _IO_USER_BUF ? 1 : 0; }$/;"	f	class:strstreambuf
fscanf	.\iostdio.h	76;"	d
fseek	.\iostdio.h	77;"	d
fsetpos	.\iostdio.h	78;"	d
fstream	.\fstream.h	/^    fstream() : fstreambase() { }$/;"	f	class:fstream
fstream	.\fstream.h	/^    fstream(const char *name, int mode, int prot=0664)$/;"	f	class:fstream
fstream	.\fstream.h	/^    fstream(int fd) : fstreambase(fd) { }$/;"	f	class:fstream
fstream	.\fstream.h	/^    fstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } \/*Deprecated*\/$/;"	f	class:fstream
fstream	.\fstream.h	/^class fstream : public fstreambase, public iostream {$/;"	c
fstreambase	.\fstream.h	/^class fstreambase : virtual public ios {$/;"	c
ftell	.\iostdio.h	79;"	d
func_parsebuf	.\parsestream.h	/^class func_parsebuf : public parsebuf {$/;"	c
function	.\stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon10
fwrite	.\iostdio.h	80;"	d
gap_end	.\editbuf.h	/^    inline buf_char *gap_end() { return data + gap_end_pos(); }$/;"	f	struct:edit_buffer
gap_end_pos	.\editbuf.h	/^    inline buf_offset gap_end_pos() { return __gap_end_pos; }$/;"	f	struct:edit_buffer
gap_size	.\editbuf.h	/^    inline int gap_size() { return gap_end() - gap_start(); }$/;"	f	struct:edit_buffer
gap_start	.\editbuf.h	/^    inline buf_char *gap_start()$/;"	f	struct:edit_buffer
gbump	.\streambuf.h	/^    void gbump(int n)$/;"	f	struct:streambuf
gcount	.\iostream.h	/^    _IO_size_t gcount() { return _gcount; }$/;"	f	class:istream
general_parsebuf	.\parsestream.h	/^class general_parsebuf : public parsebuf {$/;"	c
generate	.\stl_algo.h	/^void generate(ForwardIterator first, ForwardIterator last, Generator gen) {$/;"	f
generate_n	.\stl_algo.h	/^OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {$/;"	f
get	.\iostream.h	/^    int get() { if (!ipfx1()) return EOF;$/;"	f	class:istream
get	.\iostream.h	/^    istream& get(signed char& c)  { return get((char&)c); }$/;"	f	class:istream
get	.\iostream.h	/^    istream& get(signed char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
get	.\iostream.h	/^    istream& get(unsigned char& c) { return get((char&)c); }$/;"	f	class:istream
get	.\iostream.h	/^    istream& get(unsigned char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
get_key	.\stl_hashtable.h	/^  ExtractKey get_key;$/;"	m	class:hashtable
get_node	.\stl_list.h	/^  link_type get_node() { return list_node_allocator::allocate(); }$/;"	f	class:list
get_node	.\stl_tree.h	/^  link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:rb_tree
get_stream	.\indstream.h	/^    streambuf *get_stream()$/;"	f	class:indirectbuf
get_temporary_buffer	.\stl_tempbuf.h	/^pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t len, T*) {$/;"	f
getc	.\iostdio.h	59;"	d
getline	.\iostream.h	/^    istream& getline(signed char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
getline	.\iostream.h	/^    istream& getline(unsigned char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
getline	.\std\bastring.cc	/^getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)$/;"	f
gets	.\iostdio.h	81;"	d
good	.\streambuf.h	/^    int good() const { return _state == 0; }$/;"	f	class:ios
goodbit	.\streambuf.h	/^	goodbit = _IOS_GOOD,$/;"	e	enum:ios::io_state
gptr	.\streambuf.h	/^    char* gptr() const$/;"	f	struct:streambuf
grab	.\std\bastring.h	/^    charT* grab () { if (selfish) return clone (); ++ref; return data (); }$/;"	f	struct:basic_string::Rep
greater	.\stl_function.h	/^struct greater : public binary_function<T, T, bool> {$/;"	s
greater_equal	.\stl_function.h	/^struct greater_equal : public binary_function<T, T, bool> {$/;"	s
has_trivial_assignment_operator	.\type_traits.h	/^   typedef __false_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_assignment_operator	.\type_traits.h	/^   typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	.\type_traits.h	/^   typedef __false_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	.\type_traits.h	/^   typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	.\type_traits.h	/^   typedef __false_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	.\type_traits.h	/^   typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_destructor	.\type_traits.h	/^   typedef __false_type    has_trivial_destructor;$/;"	t	struct:__type_traits
has_trivial_destructor	.\type_traits.h	/^   typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char*>$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<const char*>$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<int> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<long> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<short> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<signed char> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned char> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned int> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned long> {$/;"	s
hash	.\stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned short> {$/;"	s
hash	.\stl_hash_fun.h	/^template <class Key> struct hash { };$/;"	s
hash	.\stl_hashtable.h	/^  hasher hash;$/;"	m	class:hashtable
hash	.\stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<crope>$/;"	s
hash	.\stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<wrope>$/;"	s
hash_funct	.\stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_map
hash_funct	.\stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multimap
hash_funct	.\stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multiset
hash_funct	.\stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_set
hash_funct	.\stl_hashtable.h	/^  hasher hash_funct() const { return hash; }$/;"	f	class:hashtable
hash_map	.\stl_hash_map.h	/^  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_map
hash_map	.\stl_hash_map.h	/^class hash_map$/;"	c
hash_multimap	.\stl_hash_map.h	/^  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multimap
hash_multimap	.\stl_hash_map.h	/^class hash_multimap$/;"	c
hash_multiset	.\stl_hash_set.h	/^  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multiset
hash_multiset	.\stl_hash_set.h	/^class hash_multiset$/;"	c
hash_set	.\stl_hash_set.h	/^  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_set
hash_set	.\stl_hash_set.h	/^class hash_set$/;"	c
hasher	.\stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_map
hasher	.\stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multimap
hasher	.\stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multiset
hasher	.\stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_set
hasher	.\stl_hashtable.h	/^  typedef HashFcn hasher;$/;"	t	class:hashtable
hashtable	.\stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_const_iterator
hashtable	.\stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_iterator
hashtable	.\stl_hashtable.h	/^  hashtable(const hashtable& ht)$/;"	f	class:hashtable
hashtable	.\stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable
hashtable	.\stl_hashtable.h	/^class hashtable {$/;"	c
have_backup	.\streambuf.h	/^    int have_backup() { return _IO_save_base != NULL; }$/;"	f	struct:streambuf
have_markers	.\streambuf.h	/^    int have_markers() { return _markers != NULL; }$/;"	f	struct:streambuf
head	.\stl_slist.h	/^  list_node_base head;$/;"	m	class:slist
header	.\stl_tree.h	/^  link_type header;  $/;"	m	class:rb_tree
heap_size	.\stl_alloc.h	/^  static size_t heap_size;$/;"	m	class:__default_alloc_template
heap_size	.\stl_alloc.h	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:__default_alloc_template
hex	.\iostream.h	/^inline ios& hex(ios& i)$/;"	f
hex	.\streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon15
ht	.\stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_map
ht	.\stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_multimap
ht	.\stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_multiset
ht	.\stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_set
ht	.\stl_hashtable.h	/^  const hashtable* ht;$/;"	m	struct:__hashtable_const_iterator
ht	.\stl_hashtable.h	/^  hashtable* ht;$/;"	m	struct:__hashtable_iterator
iapp	.\iomanip.h	/^template<class TP> class iapp {$/;"	c
ibegin	.\std\bastring.h	/^  iterator ibegin () const { return &(*rep ())[0]; }$/;"	f	class:basic_string
identity	.\stl_function.h	/^struct identity : public unary_function<T, T> {$/;"	s
identity_element	.\stl_function.h	/^template <class T> inline T identity_element(multiplies<T>) { return T(1); }$/;"	f
identity_element	.\stl_function.h	/^template <class T> inline T identity_element(plus<T>) { return T(0); }$/;"	f
identity_element	.\stl_rope.h	/^        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }$/;"	f	class:rope
iend	.\std\bastring.h	/^  iterator iend () const { return &(*rep ())[length ()]; }$/;"	f	class:basic_string
ifstream	.\fstream.h	/^    ifstream() : fstreambase() { }$/;"	f	class:ifstream
ifstream	.\fstream.h	/^    ifstream(const char *name, int mode=ios::in, int prot=0664)$/;"	f	class:ifstream
ifstream	.\fstream.h	/^    ifstream(int fd) : fstreambase(fd) { }$/;"	f	class:ifstream
ifstream	.\fstream.h	/^    ifstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } \/*Deprecated*\/$/;"	f	class:ifstream
ifstream	.\fstream.h	/^class ifstream : public fstreambase, public istream {$/;"	c
im	.\std\complext.h	/^  _FLT re, im;$/;"	m	class:complex
im	.\std\dcomplex.h	/^  double re, im;$/;"	m	class:complex
im	.\std\fcomplex.h	/^  float re, im;$/;"	m	class:complex
im	.\std\ldcomplex.h	/^  long double re, im;$/;"	m	class:complex
imag	.\std\complext.h	/^  _FLT imag () const { return im; }$/;"	f	class:complex
imag	.\std\complext.h	/^imag (const complex<_FLT>& x)$/;"	f
imag	.\std\dcomplex.h	/^  double imag () const { return im; }$/;"	f	class:complex
imag	.\std\fcomplex.h	/^  float imag () const { return im; }$/;"	f	class:complex
imag	.\std\ldcomplex.h	/^  long double imag () const { return im; }$/;"	f	class:complex
imanip	.\iomanip.h	/^template <class TP> class imanip {$/;"	c
in	.\streambuf.h	/^	in = _IO_INPUT,$/;"	e	enum:ios::open_mode
in_avail	.\streambuf.h	/^    int in_avail() { return _IO_read_end - _IO_read_ptr; }$/;"	f	struct:streambuf
in_backup	.\streambuf.h	/^    int in_backup() { return _flags & _IO_IN_BACKUP; }$/;"	f	struct:streambuf
includes	.\stl_algo.h	/^bool includes(InputIterator1 first1, InputIterator1 last1,$/;"	f
incr	.\ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::incr(size_t n) {$/;"	f	class:__rope_iterator_base
incr	.\stl_slist.h	/^  void incr() { node = node->next; }$/;"	f	struct:__slist_iterator_base
incr_refcount	.\stl_rope.h	/^	    void incr_refcount ()$/;"	f	struct:__rope_RopeBase
incr_refcount	.\stl_rope.h	/^	void incr_refcount () {}$/;"	f	struct:__rope_RopeBase
incr_refcount	.\stl_rope.h	/^            void incr_refcount ()$/;"	f	struct:__rope_RopeBase
increment	.\stl_tree.h	/^  void increment()$/;"	f	struct:__rb_tree_base_iterator
index	.\stl_rope.h	/^    size_t index() const { return current_pos; }$/;"	f	class:__rope_iterator_base
index1	.\stl_function.h	/^  size_t index1;$/;"	m	class:subtractive_rng
index2	.\stl_function.h	/^  size_t index2;$/;"	m	class:subtractive_rng
index_in_buffer	.\editbuf.h	/^    inline unsigned long index_in_buffer(struct edit_buffer *)$/;"	f	struct:edit_mark
indirectbuf	.\indstream.h	/^class indirectbuf : public streambuf {$/;"	c
init	.\stl_tree.h	/^  void init() {$/;"	f	class:rb_tree
init	.\streambuf.h	/^inline void ios::init(streambuf* sb, ostream* tie_to) {$/;"	f	class:ios
init_page_size	.\defalloc.h	/^    size_type init_page_size() { $/;"	f	class:allocator
init_refcount_lock	.\stl_rope.h	/^	    void init_refcount_lock() {$/;"	f	struct:__rope_RopeBase
init_refcount_lock	.\stl_rope.h	/^	    void init_refcount_lock() {}$/;"	f	struct:__rope_RopeBase
initial_map_size	.\stl_deque.h	/^  static size_type initial_map_size() { return 8; }$/;"	f	class:__deque_iterator::deque
initialize	.\stl_bvector.h	/^  void initialize(size_type n) {$/;"	f	class:vector
initialize	.\stl_function.h	/^  void initialize(unsigned int seed)$/;"	f	class:subtractive_rng
initialize_buckets	.\stl_hashtable.h	/^  void initialize_buckets(size_type n)$/;"	f	class:hashtable
initialize_buffer	.\stl_tempbuf.h	/^  void initialize_buffer(const T& val, __false_type) {$/;"	f	class:temporary_buffer
initialize_buffer	.\stl_tempbuf.h	/^  void initialize_buffer(const T&, __true_type) {}$/;"	f	class:temporary_buffer
initialize_range	.\stl_bvector.h	/^  void initialize_range(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector
initialize_range	.\stl_bvector.h	/^  void initialize_range(InputIterator first, InputIterator last,$/;"	f	class:vector
inner_product	.\stl_numeric.h	/^T inner_product(InputIterator1 first1, InputIterator1 last1,$/;"	f
inplace_merge	.\stl_algo.h	/^inline void inplace_merge(BidirectionalIterator first,$/;"	f
input	.\streambuf.h	/^    input = _IO_INPUT,$/;"	e	enum:open_mode
input_iterator	.\stl_iterator.h	/^template <class T, class Distance> struct input_iterator {$/;"	s
input_iterator_tag	.\stl_iterator.h	/^struct input_iterator_tag {};$/;"	s
insert	.\std\bastring.h	/^    void insert(iterator p, InputIterator first, InputIterator last)$/;"	f	class:basic_string
insert	.\std\bastring.h	/^  basic_string& insert (size_type pos, const charT* s)$/;"	f	class:basic_string
insert	.\std\bastring.h	/^  basic_string& insert (size_type pos, const charT* s, size_type n)$/;"	f	class:basic_string
insert	.\std\bastring.h	/^  basic_string& insert (size_type pos, size_type n, charT c)$/;"	f	class:basic_string
insert	.\std\bastring.h	/^  basic_string& insert (size_type pos1, const basic_string& str,$/;"	f	class:basic_string
insert	.\std\bastring.h	/^  iterator insert(iterator p, charT c)$/;"	f	class:basic_string
insert	.\std\bastring.h	/^  iterator insert(iterator p, size_type n, charT c)$/;"	f	class:basic_string
insert	.\stl_bvector.h	/^  iterator insert(iterator position, bool x = bool()) {$/;"	f	class:vector
insert	.\stl_bvector.h	/^  template <class InputIterator> void insert(iterator position,$/;"	f	class:vector
insert	.\stl_bvector.h	/^  void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }$/;"	f	class:vector
insert	.\stl_bvector.h	/^  void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }$/;"	f	class:vector
insert	.\stl_bvector.h	/^  void insert(iterator position, const bool* first, const bool* last) {$/;"	f	class:vector
insert	.\stl_bvector.h	/^  void insert(iterator position, const_iterator first, $/;"	f	class:vector
insert	.\stl_bvector.h	/^  void insert(iterator position, size_type n, bool x) {$/;"	f	class:vector
insert	.\stl_deque.h	/^  iterator insert(iterator position) { return insert(position, value_type()); }$/;"	f	class:__deque_iterator::deque
insert	.\stl_deque.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert	.\stl_deque.h	/^  void insert(iterator pos, InputIterator first, InputIterator last) {$/;"	f	class:__deque_iterator::deque
insert	.\stl_deque.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert	.\stl_deque.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque
insert	.\stl_hash_map.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multimap
insert	.\stl_hash_map.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_map
insert	.\stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multimap
insert	.\stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_map
insert	.\stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_map
insert	.\stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multimap
insert	.\stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multimap
insert	.\stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }$/;"	f	class:hash_map
insert	.\stl_hash_set.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multiset
insert	.\stl_hash_set.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_set
insert	.\stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multiset
insert	.\stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_set
insert	.\stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multiset
insert	.\stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_set
insert	.\stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multiset
insert	.\stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }$/;"	f	class:hash_set
insert	.\stl_list.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:list
insert	.\stl_list.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:list
insert	.\stl_list.h	/^  void insert(iterator pos, int n, const T& x) {$/;"	f	class:list
insert	.\stl_list.h	/^  void insert(iterator pos, long n, const T& x) {$/;"	f	class:list
insert	.\stl_list.h	/^void list<T, Alloc>::insert(iterator position, const T* first, const T* last) {$/;"	f	class:list
insert	.\stl_list.h	/^void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:list
insert	.\stl_list.h	/^void list<T, Alloc>::insert(iterator position,$/;"	f	class:list
insert	.\stl_map.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:map
insert	.\stl_map.h	/^  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }$/;"	f	class:map
insert	.\stl_map.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:map
insert	.\stl_map.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:map
insert	.\stl_map.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:map
insert	.\stl_multimap.h	/^  iterator insert(const value_type& x) { return t.insert_equal(x); }$/;"	f	class:multimap
insert	.\stl_multimap.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multimap
insert	.\stl_multimap.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multimap
insert	.\stl_multimap.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multimap
insert	.\stl_multimap.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multimap
insert	.\stl_multiset.h	/^  iterator insert(const value_type& x) { $/;"	f	class:multiset
insert	.\stl_multiset.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multiset
insert	.\stl_multiset.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multiset
insert	.\stl_multiset.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multiset
insert	.\stl_multiset.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multiset
insert	.\stl_rope.h	/^	iterator insert(const iterator& p ) $/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p, charT c) $/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p, const charT *c_string) $/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p, const rope& r)$/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p, size_t n, charT c)$/;"	f	class:rope
insert	.\stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p) {$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, charT c) {$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, const charT * c_string) {$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, const charT * i, size_t n) {$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, const const_iterator& i,$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, const iterator& i,$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, const rope& r) {$/;"	f	class:rope
insert	.\stl_rope.h	/^	void insert(size_t p, size_t n, charT c) {$/;"	f	class:rope
insert	.\stl_set.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:set
insert	.\stl_set.h	/^  pair<iterator,bool> insert(const value_type& x) { $/;"	f	class:set
insert	.\stl_set.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:set
insert	.\stl_set.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:set
insert	.\stl_set.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:set
insert	.\stl_slist.h	/^  iterator insert(iterator pos) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  iterator insert(iterator pos, const value_type& x) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  void insert(iterator pos, InIter first, InIter last) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  void insert(iterator pos, const value_type* first, const value_type* last) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  void insert(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:slist
insert	.\stl_slist.h	/^  void insert(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist
insert	.\stl_vector.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:vector
insert	.\stl_vector.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:vector
insert	.\stl_vector.h	/^  void insert (iterator pos, int n, const T& x) {$/;"	f	class:vector
insert	.\stl_vector.h	/^  void insert (iterator pos, long n, const T& x) {$/;"	f	class:vector
insert	.\stl_vector.h	/^  void insert(iterator position, InputIterator first, InputIterator last) {$/;"	f	class:vector
insert	.\stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, $/;"	f	class:vector
insert	.\stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:vector
insert_after	.\stl_slist.h	/^  iterator insert_after(iterator pos) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  iterator insert_after(iterator pos, const value_type& x) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  void insert_after(iterator pos, InIter first, InIter last) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  void insert_after(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  void insert_after(iterator pos, int n, const value_type& x) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  void insert_after(iterator pos, long n, const value_type& x) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  void insert_after(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist
insert_after	.\stl_slist.h	/^  void insert_after(iterator pos,$/;"	f	class:slist
insert_aux	.\stl_bvector.h	/^  void insert_aux(iterator position, bool x) {$/;"	f	class:vector
insert_aux	.\stl_deque.h	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert_aux	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque
insert_aux	.\stl_vector.h	/^void vector<T, Alloc>::insert_aux(iterator position, const T& x) {$/;"	f	class:vector
insert_before	.\editbuf.h	/^    inline int insert_before() { return _pos & 1; }$/;"	f	struct:edit_mark
insert_equal	.\stl_hashtable.h	/^  iterator insert_equal(const value_type& obj)$/;"	f	class:hashtable
insert_equal	.\stl_hashtable.h	/^  void insert_equal(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable
insert_equal	.\stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l)$/;"	f	class:hashtable
insert_equal	.\stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l,$/;"	f	class:hashtable
insert_equal	.\stl_hashtable.h	/^  void insert_equal(const value_type* f, const value_type* l)$/;"	f	class:hashtable
insert_equal	.\stl_hashtable.h	/^  void insert_equal(const_iterator f, const_iterator l)$/;"	f	class:hashtable
insert_equal	.\stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const V* first, const V* last) {$/;"	f	class:rb_tree
insert_equal	.\stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const_iterator first,$/;"	f	class:rb_tree
insert_equal	.\stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,$/;"	f	class:rb_tree
insert_equal	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)$/;"	f	class:rb_tree
insert_equal	.\stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {$/;"	f	class:rb_tree
insert_equal_noresize	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)$/;"	f	class:hashtable
insert_iterator	.\stl_iterator.h	/^  insert_iterator(Container& x, typename Container::iterator i) $/;"	f	class:insert_iterator
insert_iterator	.\stl_iterator.h	/^class insert_iterator {$/;"	c
insert_noresize	.\stl_hash_map.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multimap
insert_noresize	.\stl_hash_map.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_map
insert_noresize	.\stl_hash_set.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multiset
insert_noresize	.\stl_hash_set.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_set
insert_ostream	.\ropeimpl.h	/^	typedef ostream insert_ostream;$/;"	t	class:__rope_insert_char_consumer
insert_range	.\stl_bvector.h	/^  void insert_range(iterator pos,$/;"	f	class:vector
insert_range	.\stl_bvector.h	/^  void insert_range(iterator position,$/;"	f	class:vector
insert_unique	.\stl_hashtable.h	/^  pair<iterator, bool> insert_unique(const value_type& obj)$/;"	f	class:hashtable
insert_unique	.\stl_hashtable.h	/^  void insert_unique(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable
insert_unique	.\stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l)$/;"	f	class:hashtable
insert_unique	.\stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l,$/;"	f	class:hashtable
insert_unique	.\stl_hashtable.h	/^  void insert_unique(const value_type* f, const value_type* l)$/;"	f	class:hashtable
insert_unique	.\stl_hashtable.h	/^  void insert_unique(const_iterator f, const_iterator l)$/;"	f	class:hashtable
insert_unique	.\stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const V* first, const V* last) {$/;"	f	class:rb_tree
insert_unique	.\stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const_iterator first,$/;"	f	class:rb_tree
insert_unique	.\stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,$/;"	f	class:rb_tree
insert_unique	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)$/;"	f	class:rb_tree
insert_unique	.\stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {$/;"	f	class:rb_tree
insert_unique_noresize	.\stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)$/;"	f	class:hashtable
inserter	.\stl_iterator.h	/^inline insert_iterator<Container> inserter(Container& x, Iterator i) {$/;"	f
inserting	.\editbuf.h	/^    int inserting() { return _inserting; }$/;"	f	struct:edit_streambuf
inserting	.\editbuf.h	/^    void inserting(int i) { _inserting = i; }$/;"	f	struct:edit_streambuf
internal	.\streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon15
io_functions	.\libio.h	/^  _IO_cookie_io_functions_t io_functions;$/;"	m	struct:_IO_cookie_file
io_state	.\streambuf.h	/^    enum io_state {$/;"	g	class:ios
ios	.\streambuf.h	/^class ios : public _ios_fields {$/;"	c
ios	.\streambuf.h	/^inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }$/;"	f	class:ios
iostate	.\streambuf.h	/^    typedef int iostate;$/;"	t	class:ios
iostream	.\iostream.h	/^    iostream() { }$/;"	f	class:iostream
iostream	.\iostream.h	/^class iostream : public istream, public ostream$/;"	c
iota	.\stl_numeric.h	/^void iota(ForwardIterator first, ForwardIterator last, T value) {$/;"	f
ipfstream	.\pfstream.h	/^class ipfstream : public ifstream {$/;"	c
ipfx	.\iostream.h	/^    int ipfx(int need = 0) {$/;"	f	class:istream
ipfx0	.\iostream.h	/^    int ipfx0() { \/\/ Optimized version of ipfx(0).$/;"	f	class:istream
ipfx1	.\iostream.h	/^    int ipfx1() { \/\/ Optimized version of ipfx(1).$/;"	f	class:istream
is0	.\stl_rope.h	/^	static bool is0(charT c) { return c == __eos((charT *)0); }$/;"	f	class:rope
is_POD_type	.\type_traits.h	/^   typedef __false_type    is_POD_type;$/;"	t	struct:__type_traits
is_POD_type	.\type_traits.h	/^   typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits
is_almost_balanced	.\stl_rope.h	/^	static bool is_almost_balanced(RopeBase *r)$/;"	f	class:rope
is_balanced	.\stl_rope.h	/^	static bool is_balanced(RopeBase *r)$/;"	f	class:rope
is_balanced	.\stl_rope.h	/^    bool is_balanced:8;$/;"	m	struct:__rope_RopeBase
is_del	.\std\straits.h	/^  static bool is_del(char_type a) { return 0; }$/;"	f	struct:string_char_traits
is_del	.\std\straits.h	/^  static bool is_del(char_type a) { return isspace(a); }$/;"	f	struct:string_char_traits
is_heap	.\stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last)$/;"	f
is_heap	.\stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
is_open	.\fstream.h	/^    int is_open() const { return rdbuf()->is_open(); }$/;"	f	class:fstreambase
is_open	.\streambuf.h	/^    int is_open() const { return _fileno >= 0; }$/;"	f	class:filebuf
is_reading	.\editbuf.h	/^    int is_reading() { return gptr() != NULL; }$/;"	f	struct:edit_streambuf
is_reading	.\streambuf.h	/^    int is_reading() { return eback() != egptr(); }$/;"	f	class:filebuf
is_roughly_balanced	.\stl_rope.h	/^	static bool is_roughly_balanced(RopeBase *r)$/;"	f	class:rope
is_sorted	.\stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last)$/;"	f
is_sorted	.\stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last,$/;"	f
isfx	.\iostream.h	/^    void isfx() { _IO_funlockfile(_strbuf); }$/;"	f	class:istream
istdiostream	.\stdiostream.h	/^  istdiostream (FILE* __f) : istream(), _file(__f) { init(&_file); }$/;"	f	class:istdiostream
istdiostream	.\stdiostream.h	/^class istdiostream : public istream$/;"	c
istream	.\iostream.h	/^    istream(): _gcount (0) { }$/;"	f	class:istream
istream	.\iostream.h	/^class istream : virtual public ios$/;"	c
istream_iterator	.\stl_iterator.h	/^  istream_iterator() : stream(&cin), end_marker(false) {}$/;"	f	class:istream_iterator
istream_iterator	.\stl_iterator.h	/^  istream_iterator(istream& s) : stream(&s) { read(); }$/;"	f	class:istream_iterator
istream_iterator	.\stl_iterator.h	/^class istream_iterator {$/;"	c
istreambuf	.\iostream.h	/^    streambuf* istreambuf() const { return _strbuf; }$/;"	f	class:istream
istrstream	.\strstream.h	/^class istrstream : public strstreambase, public istream {$/;"	c
iter	.\stl_iterator.h	/^  typename Container::iterator iter;$/;"	m	class:insert_iterator
iter	.\stl_raw_storage_iter.h	/^  ForwardIterator iter;$/;"	m	class:raw_storage_iterator
iter_swap	.\stl_algobase.h	/^inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {$/;"	f
iterator	.\std\bastring.h	/^  typedef pointer iterator;$/;"	t	class:basic_string
iterator	.\stl_bvector.h	/^  typedef __bit_iterator                iterator;$/;"	t	class:vector
iterator	.\stl_bvector.h	/^  typedef __bit_iterator iterator;$/;"	t	struct:__bit_iterator
iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;$/;"	t	class:__deque_iterator::deque
iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;$/;"	t	struct:__deque_iterator
iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>                      iterator;$/;"	t	class:__deque_iterator::deque
iterator	.\stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>             iterator;$/;"	t	struct:__deque_iterator::__deque_iterator
iterator	.\stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_map
iterator	.\stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_multimap
iterator	.\stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_multiset
iterator	.\stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_set
iterator	.\stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_const_iterator
iterator	.\stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_iterator
iterator	.\stl_hashtable.h	/^  iterator;$/;"	t	class:hashtable
iterator	.\stl_iterator.h	/^struct iterator {$/;"	s
iterator	.\stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	class:list
iterator	.\stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	struct:__list_iterator
iterator	.\stl_map.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:map
iterator	.\stl_multimap.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:multimap
iterator	.\stl_multiset.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:multiset
iterator	.\stl_rope.h	/^	typedef __rope_iterator<charT,Alloc> iterator;$/;"	t	class:rope
iterator	.\stl_set.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:set
iterator	.\stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:slist
iterator	.\stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:__slist_iterator
iterator	.\stl_tree.h	/^  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;$/;"	t	struct:__rb_tree_iterator
iterator	.\stl_tree.h	/^  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:rb_tree
iterator	.\stl_vector.h	/^  typedef value_type* iterator;$/;"	t	class:vector
iterator_base	.\stl_slist.h	/^  typedef __slist_iterator_base iterator_base;$/;"	t	class:slist
iterator_buf_len	.\stl_rope.h	/^    enum { iterator_buf_len = 15 };$/;"	e	enum:__rope_iterator_base::__anon13
iterator_category	.\stl_deque.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:__deque_iterator::__deque_iterator
iterator_category	.\stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator
iterator_category	.\stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator
iterator_category	.\stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_const_iterator
iterator_category	.\stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_iterator
iterator_category	.\stl_hashtable.h	/^iterator_category(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
iterator_category	.\stl_hashtable.h	/^iterator_category(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
iterator_category	.\stl_iterator.h	/^          iterator_category;$/;"	t	class:reverse_iterator
iterator_category	.\stl_iterator.h	/^  typedef Category  iterator_category;$/;"	t	struct:iterator
iterator_category	.\stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	class:reverse_bidirectional_iterator
iterator_category	.\stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:bidirectional_iterator
iterator_category	.\stl_iterator.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:forward_iterator
iterator_category	.\stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	class:istream_iterator
iterator_category	.\stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	struct:input_iterator
iterator_category	.\stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:back_insert_iterator
iterator_category	.\stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:front_insert_iterator
iterator_category	.\stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:insert_iterator
iterator_category	.\stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:ostream_iterator
iterator_category	.\stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	struct:output_iterator
iterator_category	.\stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	class:reverse_iterator
iterator_category	.\stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:iterator_traits
iterator_category	.\stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:random_access_iterator
iterator_category	.\stl_iterator.h	/^  typedef typename Iterator::iterator_category iterator_category;$/;"	t	struct:iterator_traits
iterator_category	.\stl_iterator.h	/^inline output_iterator_tag iterator_category(const output_iterator&) {$/;"	f
iterator_category	.\stl_iterator.h	/^inline random_access_iterator_tag iterator_category(const T*) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const Iterator&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const back_insert_iterator<Container>&)$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const bidirectional_iterator<T, Distance>&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const forward_iterator<T, Distance>&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const front_insert_iterator<Container>&)$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const input_iterator<T, Distance>&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const insert_iterator<Container>&)$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const istream_iterator<T, Distance>&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const ostream_iterator<T>&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const random_access_iterator<T, Distance>&) {$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const reverse_bidirectional_iterator<BidirectionalIterator,$/;"	f
iterator_category	.\stl_iterator.h	/^iterator_category(const reverse_iterator<RandomAccessIterator, T,$/;"	f
iterator_category	.\stl_list.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__list_iterator
iterator_category	.\stl_list.h	/^iterator_category(const __list_iterator<T, Ref, Ptr>&) {$/;"	f
iterator_category	.\stl_raw_storage_iter.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:raw_storage_iterator
iterator_category	.\stl_raw_storage_iter.h	/^iterator_category(const raw_storage_iterator<ForwardIterator, T>&)$/;"	f
iterator_category	.\stl_slist.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__slist_iterator_base
iterator_category	.\stl_slist.h	/^iterator_category(const __slist_iterator_base&)$/;"	f
iterator_category	.\stl_tree.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__rb_tree_base_iterator
iterator_category	.\stl_tree.h	/^iterator_category(const __rb_tree_base_iterator&) {$/;"	f
iterator_traits	.\stl_iterator.h	/^struct iterator_traits {$/;"	s
iterator_traits	.\stl_iterator.h	/^struct iterator_traits<T*> {$/;"	s
iterator_traits	.\stl_iterator.h	/^struct iterator_traits<const T*> {$/;"	s
iterator_type	.\stl_iterator.h	/^  typedef Iterator iterator_type;$/;"	t	class:reverse_iterator
key	.\stl_tree.h	/^  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} $/;"	f	class:rb_tree
key	.\stl_tree.h	/^  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:rb_tree
key_comp	.\stl_map.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:map
key_comp	.\stl_multimap.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multimap
key_comp	.\stl_multiset.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multiset
key_comp	.\stl_set.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:set
key_comp	.\stl_tree.h	/^  Compare key_comp() const { return key_compare; }$/;"	f	class:rb_tree
key_compare	.\stl_map.h	/^  typedef Compare key_compare;$/;"	t	class:map
key_compare	.\stl_multimap.h	/^  typedef Compare key_compare;$/;"	t	class:multimap
key_compare	.\stl_multiset.h	/^  typedef Compare key_compare;$/;"	t	class:multiset
key_compare	.\stl_set.h	/^  typedef Compare key_compare;$/;"	t	class:set
key_compare	.\stl_tree.h	/^  Compare key_compare;$/;"	m	class:rb_tree
key_eq	.\stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_map
key_eq	.\stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multimap
key_eq	.\stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multiset
key_eq	.\stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_set
key_eq	.\stl_hashtable.h	/^  key_equal key_eq() const { return equals; }$/;"	f	class:hashtable
key_equal	.\stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_map
key_equal	.\stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multimap
key_equal	.\stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multiset
key_equal	.\stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_set
key_equal	.\stl_hashtable.h	/^  typedef EqualKey key_equal;$/;"	t	class:hashtable
key_type	.\stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_map
key_type	.\stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multimap
key_type	.\stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multiset
key_type	.\stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_set
key_type	.\stl_hashtable.h	/^  typedef Key key_type;$/;"	t	class:hashtable
key_type	.\stl_map.h	/^  typedef Key key_type;$/;"	t	class:map
key_type	.\stl_multimap.h	/^  typedef Key key_type;$/;"	t	class:multimap
key_type	.\stl_multiset.h	/^  typedef Key key_type;$/;"	t	class:multiset
key_type	.\stl_set.h	/^  typedef Key key_type;$/;"	t	class:set
key_type	.\stl_tree.h	/^  typedef Key key_type;$/;"	t	class:rb_tree
last	.\stl_deque.h	/^  T* last;$/;"	m	struct:__deque_iterator::__deque_iterator
leaf	.\stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon10
leaf_concat_char_iter	.\ropeimpl.h	/^rope<charT,Alloc>::leaf_concat_char_iter$/;"	f	class:rope
leaf_index	.\stl_rope.h	/^    int leaf_index;     \/\/ Last valid pos in path_end;$/;"	m	class:__rope_iterator_base
leaf_pos	.\stl_rope.h	/^    size_t leaf_pos;    \/\/ Starting position for current leaf$/;"	m	class:__rope_iterator_base
left	.\parsestream.h	/^    char *left() const { return base(); }$/;"	f	class:string_parsebuf
left	.\stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* left;$/;"	m	struct:__rope_RopeConcatenation
left	.\stl_tree.h	/^  base_ptr left;$/;"	m	struct:__rb_tree_node_base
left	.\stl_tree.h	/^  static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree
left	.\stl_tree.h	/^  static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree
left	.\streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon15
leftmost	.\stl_tree.h	/^  link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:rb_tree
len	.\std\bastring.h	/^    size_t len, res, ref;$/;"	m	struct:basic_string::Rep
len	.\stl_tempbuf.h	/^  ptrdiff_t len;$/;"	m	class:temporary_buffer
length	.\std\bastring.h	/^  size_type length () const$/;"	f	class:basic_string
length	.\std\straits.h	/^  static size_t length (const char_type* s)$/;"	f	struct:string_char_traits
length	.\stl_rope.h	/^	size_type length() const {$/;"	f	class:rope
less	.\stl_function.h	/^struct less : public binary_function<T, T, bool> {$/;"	s
less_equal	.\stl_function.h	/^struct less_equal : public binary_function<T, T, bool> {$/;"	s
lexicographical_compare	.\stl_algobase.h	/^bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,$/;"	f
lexicographical_compare	.\stl_algobase.h	/^inline bool lexicographical_compare(const char* first1, const char* last1,$/;"	f
lexicographical_compare	.\stl_algobase.h	/^lexicographical_compare(const unsigned char* first1,$/;"	f
lexicographical_compare_3way	.\stl_algobase.h	/^inline int lexicographical_compare_3way(const char* first1, const char* last1,$/;"	f
lexicographical_compare_3way	.\stl_algobase.h	/^int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,$/;"	f
lexicographical_compare_3way	.\stl_algobase.h	/^lexicographical_compare_3way(const unsigned char* first1,$/;"	f
line_length	.\parsestream.h	/^    int line_length() { return _line_length; }$/;"	f	class:parsebuf
line_number	.\parsestream.h	/^    int line_number() { return __line_number; }$/;"	f	class:parsebuf
linebuffered	.\streambuf.h	/^    int linebuffered() { return _flags & _IO_LINE_BUF ? 1 : 0; }$/;"	f	struct:streambuf
linebuffered	.\streambuf.h	/^    void linebuffered(int i)$/;"	f	struct:streambuf
link_type	.\stl_list.h	/^  typedef __list_node<T>* link_type;$/;"	t	struct:__list_iterator
link_type	.\stl_list.h	/^  typedef list_node* link_type;$/;"	t	class:list
link_type	.\stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_iterator
link_type	.\stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_node
link_type	.\stl_tree.h	/^  typedef rb_tree_node* link_type;$/;"	t	class:rb_tree
list	.\stl_list.h	/^  explicit list(size_type n) { fill_initialize(n, T()); }$/;"	f	class:list
list	.\stl_list.h	/^  list() { empty_initialize(); }$/;"	f	class:list
list	.\stl_list.h	/^  list(InputIterator first, InputIterator last) {$/;"	f	class:list
list	.\stl_list.h	/^  list(const T* first, const T* last) { range_initialize(first, last); }$/;"	f	class:list
list	.\stl_list.h	/^  list(const list<T, Alloc>& x) {$/;"	f	class:list
list	.\stl_list.h	/^  list(const_iterator first, const_iterator last) {$/;"	f	class:list
list	.\stl_list.h	/^  list(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list
list	.\stl_list.h	/^  list(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list
list	.\stl_list.h	/^  list(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list
list	.\stl_list.h	/^class list {$/;"	c
list_node	.\stl_list.h	/^  typedef __list_node<T> list_node;$/;"	t	class:list
list_node	.\stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	class:slist
list_node	.\stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	struct:__slist_iterator
list_node_allocator	.\stl_list.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:list
list_node_allocator	.\stl_slist.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:slist
list_node_base	.\stl_slist.h	/^  typedef __slist_node_base list_node_base;$/;"	t	class:slist
lock	.\stl_alloc.h	/^            lock() { __NODE_ALLOCATOR_LOCK; }$/;"	f	class:__default_alloc_template::lock
lock	.\stl_alloc.h	/^    class lock {$/;"	c	class:__default_alloc_template
log	.\std\complext.cc	/^log (const complex<FLOAT>& x)$/;"	f
logical_and	.\stl_function.h	/^struct logical_and : public binary_function<T, T, bool> {$/;"	s
logical_not	.\stl_function.h	/^struct logical_not : public unary_function<T, bool> {$/;"	s
logical_or	.\stl_function.h	/^struct logical_or : public binary_function<T, T, bool> {$/;"	s
lookup_stream	.\indstream.h	/^    virtual streambuf *lookup_stream(int\/*mode*\/) { return NULL; } \/\/ ERROR!$/;"	f	class:indirectbuf
lower_bound	.\stl_algo.h	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f
lower_bound	.\stl_map.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:map
lower_bound	.\stl_map.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:map
lower_bound	.\stl_multimap.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:multimap
lower_bound	.\stl_multimap.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:multimap
lower_bound	.\stl_multiset.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:multiset
lower_bound	.\stl_set.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:set
lower_bound	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {$/;"	f	class:rb_tree
lower_bound	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {$/;"	f	class:rb_tree
lt	.\std\straits.h	/^  static bool lt (const char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
make_heap	.\stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
make_heap	.\stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
make_pair	.\stl_pair.h	/^inline pair<T1, T2> make_pair(const T1& x, const T2& y) {$/;"	f
malloc_alloc	.\stl_alloc.h	/^typedef __malloc_alloc_template<0> malloc_alloc;$/;"	t
map	.\stl_deque.h	/^  map_pointer map;$/;"	m	class:__deque_iterator::deque
map	.\stl_map.h	/^  explicit map(const Compare& comp) : t(comp) {}$/;"	f	class:map
map	.\stl_map.h	/^  map() : t(Compare()) {}$/;"	f	class:map
map	.\stl_map.h	/^  map(InputIterator first, InputIterator last)$/;"	f	class:map
map	.\stl_map.h	/^  map(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:map
map	.\stl_map.h	/^  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:map
map	.\stl_map.h	/^  map(const value_type* first, const value_type* last)$/;"	f	class:map
map	.\stl_map.h	/^  map(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:map
map	.\stl_map.h	/^  map(const_iterator first, const_iterator last)$/;"	f	class:map
map	.\stl_map.h	/^  map(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:map
map	.\stl_map.h	/^class map {$/;"	c
map_allocator	.\stl_deque.h	/^  typedef simple_alloc<pointer, Alloc> map_allocator;$/;"	t	class:__deque_iterator::deque
map_pointer	.\stl_deque.h	/^  typedef T** map_pointer;$/;"	t	struct:__deque_iterator::__deque_iterator
map_pointer	.\stl_deque.h	/^  typedef pointer* map_pointer;$/;"	t	class:__deque_iterator::deque
map_size	.\stl_deque.h	/^  size_type map_size;$/;"	m	class:__deque_iterator::deque
mapped_type	.\stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_map
mapped_type	.\stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_multimap
mapped_type	.\stl_map.h	/^  typedef T mapped_type;$/;"	t	class:map
mapped_type	.\stl_multimap.h	/^  typedef T mapped_type;$/;"	t	class:multimap
mark_list	.\editbuf.h	/^    inline struct edit_mark * mark_list() { return &start_mark; }$/;"	f	struct:edit_buffer
mark_pointer	.\editbuf.h	/^typedef unsigned long mark_pointer;$/;"	t
mask	.\stl_bvector.h	/^  unsigned int mask;$/;"	m	struct:__bit_reference
max	.\stl_algobase.h	/^inline const T& max(const T& a, const T& b) {$/;"	f
max	.\stl_algobase.h	/^inline const T& max(const T& a, const T& b, Compare comp) {$/;"	f
max	.\stl_algobase.h	83;"	d
max_bucket_count	.\stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_map
max_bucket_count	.\stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multimap
max_bucket_count	.\stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multiset
max_bucket_count	.\stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_set
max_bucket_count	.\stl_hashtable.h	/^  size_type max_bucket_count() const$/;"	f	class:hashtable
max_element	.\stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {$/;"	f
max_element	.\stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last,$/;"	f
max_rope_depth	.\stl_rope.h	/^    enum { max_rope_depth = 45 };$/;"	e	enum:__rope_RopeBase::__anon9
max_size	.\defalloc.h	/^    size_type max_size() const { $/;"	f	class:allocator
max_size	.\std\bastring.h	/^  size_type max_size () const$/;"	f	class:basic_string
max_size	.\stl_bvector.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:vector
max_size	.\stl_deque.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:__deque_iterator::deque
max_size	.\stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_map
max_size	.\stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multimap
max_size	.\stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multiset
max_size	.\stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_set
max_size	.\stl_hashtable.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:hashtable
max_size	.\stl_list.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:list
max_size	.\stl_map.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:map
max_size	.\stl_multimap.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multimap
max_size	.\stl_multiset.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multiset
max_size	.\stl_rope.h	/^	size_type max_size() const {$/;"	f	class:rope
max_size	.\stl_set.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:set
max_size	.\stl_slist.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:slist
max_size	.\stl_tree.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:rb_tree
max_size	.\stl_vector.h	/^  size_type max_size() const { return size_type(-1) \/ sizeof(T); }$/;"	f	class:vector
maximum	.\stl_tree.h	/^  static base_ptr maximum(base_ptr x)$/;"	f	struct:__rb_tree_node_base
maximum	.\stl_tree.h	/^  static link_type maximum(link_type x) {$/;"	f	class:rb_tree
mem_fun1_ref_t	.\stl_function.h	/^  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t
mem_fun1_ref_t	.\stl_function.h	/^class mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c
mem_fun1_ref_t	.\stl_function.h	/^class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c
mem_fun1_t	.\stl_function.h	/^  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t
mem_fun1_t	.\stl_function.h	/^class mem_fun1_t : public binary_function<T*, A, S> {$/;"	c
mem_fun1_t	.\stl_function.h	/^class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {$/;"	c
mem_fun_ref_t	.\stl_function.h	/^  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t
mem_fun_ref_t	.\stl_function.h	/^class mem_fun_ref_t : public unary_function<T, S> {$/;"	c
mem_fun_ref_t	.\stl_function.h	/^class mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c
mem_fun_t	.\stl_function.h	/^  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t
mem_fun_t	.\stl_function.h	/^class mem_fun_t : public unary_function<T*, S> {$/;"	c
mem_fun_t	.\stl_function.h	/^class mem_fun_t<void, T> : public unary_function<T*, void> {$/;"	c
merge	.\stl_algo.h	/^OutputIterator merge(InputIterator1 first1, InputIterator1 last1,$/;"	f
merge	.\stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x) {$/;"	f	class:list
merge	.\stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {$/;"	f	class:list
merge	.\stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L)$/;"	f	class:slist
merge	.\stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L, StrictWeakOrdering comp)$/;"	f	class:slist
min	.\stl_algobase.h	/^inline const T& min(const T& a, const T& b) {$/;"	f
min	.\stl_algobase.h	/^inline const T& min(const T& a, const T& b, Compare comp) {$/;"	f
min	.\stl_algobase.h	82;"	d
min_element	.\stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {$/;"	f
min_element	.\stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last,$/;"	f
min_len	.\ropeimpl.h	/^rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {$/;"	m	class:rope
min_len	.\stl_rope.h	/^	static const unsigned long min_len[RopeBase::max_rope_depth + 1];$/;"	m	class:rope
minimum	.\stl_tree.h	/^  static base_ptr minimum(base_ptr x)$/;"	f	struct:__rb_tree_node_base
minimum	.\stl_tree.h	/^  static link_type minimum(link_type x) { $/;"	f	class:rb_tree
minus	.\stl_function.h	/^struct minus : public binary_function<T, T, T> {$/;"	s
mismatch	.\stl_algobase.h	/^pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,$/;"	f
mmap	.\libioP.h	493;"	d
modulus	.\stl_function.h	/^struct modulus : public binary_function<T, T, T> {$/;"	s
move	.\std\bastring.cc	/^move (size_t pos, const charT *s, size_t n)$/;"	f	class:basic_string::Rep
move	.\std\straits.h	/^  static char_type* move (char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
move_gap	.\editbuf.h	/^    void move_gap (buf_char *pos) { move_gap(pos - data); }$/;"	f	struct:edit_buffer
multimap	.\stl_multimap.h	/^  explicit multimap(const Compare& comp) : t(comp) { }$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap() : t(Compare()) { }$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(InputIterator first, InputIterator last)$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(const value_type* first, const value_type* last)$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(const value_type* first, const value_type* last,$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(const_iterator first, const_iterator last)$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^  multimap(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multimap
multimap	.\stl_multimap.h	/^class multimap {$/;"	c
multiplies	.\stl_function.h	/^struct multiplies : public binary_function<T, T, T> {$/;"	s
multiset	.\stl_multiset.h	/^  explicit multiset(const Compare& comp) : t(comp) {}$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset() : t(Compare()) {}$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(InputIterator first, InputIterator last)$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(const value_type* first, const value_type* last)$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(const value_type* first, const value_type* last,$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(const_iterator first, const_iterator last)$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^  multiset(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multiset
multiset	.\stl_multiset.h	/^class multiset {$/;"	c
munmap	.\libioP.h	494;"	d
mutable_begin	.\stl_rope.h	/^	iterator mutable_begin() {$/;"	f	class:rope
mutable_end	.\stl_rope.h	/^	iterator mutable_end() {$/;"	f	class:rope
mutable_rbegin	.\stl_rope.h	/^	reverse_iterator mutable_rbegin() {$/;"	f	class:rope
mutable_reference_at	.\stl_rope.h	/^	reference mutable_reference_at(size_type pos) {$/;"	f	class:rope
mutable_rend	.\stl_rope.h	/^	reverse_iterator mutable_rend() {$/;"	f	class:rope
my_rope	.\stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	class:__rope_charT_ref_proxy
my_rope	.\stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	struct:__rope_RopeBase
ne	.\std\straits.h	/^  static bool ne (const char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
negate	.\stl_function.h	/^struct negate : public unary_function<T, T> {$/;"	s
new_elements_at_back	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) {$/;"	f	class:__deque_iterator::deque
new_elements_at_front	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) {$/;"	f	class:__deque_iterator::deque
new_node	.\stl_hashtable.h	/^  node* new_node(const value_type& obj)$/;"	f	class:hashtable
next	.\editbuf.h	/^    edit_streambuf* next; \/\/ Chain of edit_streambuf's for a edit_buffer.$/;"	m	struct:edit_streambuf
next	.\stl_hashtable.h	/^  __hashtable_node* next;$/;"	m	struct:__hashtable_node
next	.\stl_list.h	/^  void_pointer next;$/;"	m	struct:__list_node
next	.\stl_slist.h	/^  __slist_node_base* next;$/;"	m	struct:__slist_node_base
next_permutation	.\stl_algo.h	/^bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f
next_permutation	.\stl_algo.h	/^bool next_permutation(BidirectionalIterator first,$/;"	f
next_size	.\stl_hashtable.h	/^  size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:hashtable
nilRep	.\std\bastring.cc	/^basic_string<charT, traits, Allocator>::nilRep = { 0, 0, 1, false };$/;"	m	class:basic_string	file:
nilRep	.\std\bastring.h	/^  static Rep nilRep;$/;"	m	class:basic_string
nocreate	.\streambuf.h	/^	nocreate = _IO_NOCREATE,$/;"	e	enum:ios::open_mode
node	.\stl_deque.h	/^  map_pointer node;$/;"	m	struct:__deque_iterator::__deque_iterator
node	.\stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	class:hashtable
node	.\stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_const_iterator
node	.\stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_iterator
node	.\stl_list.h	/^  link_type node;$/;"	m	class:list
node	.\stl_list.h	/^  link_type node;$/;"	m	struct:__list_iterator
node	.\stl_slist.h	/^  __slist_node_base* node;$/;"	m	struct:__slist_iterator_base
node	.\stl_tree.h	/^  base_ptr node;$/;"	m	struct:__rb_tree_base_iterator
node_allocator	.\stl_hashtable.h	/^  typedef simple_alloc<node, Alloc> node_allocator;$/;"	t	class:hashtable
node_count	.\stl_tree.h	/^  size_type node_count; \/\/ keeps track of size of tree$/;"	m	class:rb_tree
noreplace	.\streambuf.h	/^	noreplace = _IO_NOREPLACE,$/;"	e	enum:ios::open_mode
norm	.\std\complext.h	/^norm (const complex<_FLT>& x)$/;"	f
not1	.\stl_function.h	/^inline unary_negate<Predicate> not1(const Predicate& pred) {$/;"	f
not2	.\stl_function.h	/^inline binary_negate<Predicate> not2(const Predicate& pred) {$/;"	f
not_equal_to	.\stl_function.h	/^struct not_equal_to : public binary_function<T, T, bool> {$/;"	s
npos	.\std\bastring.cc	/^basic_string <charT, traits, Allocator>::npos;$/;"	m	class:basic_string	file:
npos	.\std\bastring.h	/^  static const size_type npos = static_cast<size_type>(-1);$/;"	m	class:basic_string
nth_element	.\stl_algo.h	/^inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f
num_elements	.\stl_hashtable.h	/^  size_type num_elements;$/;"	m	class:hashtable
o	.\ropeimpl.h	/^	insert_ostream & o;$/;"	m	class:__rope_insert_char_consumer
oapp	.\iomanip.h	/^template<class TP> class oapp {$/;"	c
obj	.\stl_alloc.h	/^  union obj {$/;"	u	class:__default_alloc_template
oct	.\iostream.h	/^inline ios& oct(ios& i)$/;"	f
oct	.\streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon15
offset	.\stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_const_iterator
offset	.\stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_iterator
ofstream	.\fstream.h	/^    ofstream() : fstreambase() { }$/;"	f	class:ofstream
ofstream	.\fstream.h	/^    ofstream(const char *name, int mode=ios::out, int prot=0664)$/;"	f	class:ofstream
ofstream	.\fstream.h	/^    ofstream(int fd) : fstreambase(fd) { }$/;"	f	class:ofstream
ofstream	.\fstream.h	/^    ofstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } \/*Deprecated*\/$/;"	f	class:ofstream
ofstream	.\fstream.h	/^class ofstream : public fstreambase, public ostream {$/;"	c
omanip	.\iomanip.h	/^template <class TP> class omanip {$/;"	c
oom_malloc	.\stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_malloc(size_t n)$/;"	f	class:__malloc_alloc_template
oom_realloc	.\stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)$/;"	f	class:__malloc_alloc_template
op	.\stl_function.h	/^  Operation op;$/;"	m	class:binder1st
op	.\stl_function.h	/^  Operation op;$/;"	m	class:binder2nd
op1	.\stl_function.h	/^  Operation1 op1;$/;"	m	class:binary_compose
op1	.\stl_function.h	/^  Operation1 op1;$/;"	m	class:unary_compose
op2	.\stl_function.h	/^  Operation2 op2;$/;"	m	class:binary_compose
op2	.\stl_function.h	/^  Operation2 op2;$/;"	m	class:unary_compose
op3	.\stl_function.h	/^  Operation3 op3;$/;"	m	class:binary_compose
open	.\fstream.h	/^    void open(const char *name, int mode, int prot=0664)$/;"	f	class:fstream
open	.\fstream.h	/^    void open(const char *name, int mode=ios::in, int prot=0664)$/;"	f	class:ifstream
open	.\fstream.h	/^    void open(const char *name, int mode=ios::out, int prot=0664)$/;"	f	class:ofstream
open	.\streambuf.h	70;"	d
open_mode	.\streambuf.h	/^    enum open_mode {$/;"	g	class:ios
open_mode	.\streambuf.h	/^enum open_mode {$/;"	g
openmode	.\streambuf.h	/^    typedef int openmode;$/;"	t	class:ios
openprot	.\streambuf.h	/^    static const int openprot; \/\/ Non-ANSI AT&T-ism:  Default open protection.$/;"	m	class:filebuf
operator !	.\streambuf.h	/^    int operator!() const { return fail(); }$/;"	f	class:ios
operator !=	.\std\bastring.h	/^operator!= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator !=	.\std\bastring.h	/^operator!= (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator !=	.\std\bastring.h	/^operator!= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator !=	.\std\complext.h	/^operator != (_FLT x, const complex<_FLT>& y)$/;"	f
operator !=	.\std\complext.h	/^operator != (const complex<_FLT>& x, _FLT y)$/;"	f
operator !=	.\std\complext.h	/^operator != (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator !=	.\std\dcomplex.h	/^  friend inline bool operator != (const complex& x, double y)$/;"	f	class:complex
operator !=	.\std\dcomplex.h	/^  friend inline bool operator != (double x, const complex& y)$/;"	f	class:complex
operator !=	.\std\fcomplex.h	/^  friend inline bool operator != (const complex& x, float y)$/;"	f	class:complex
operator !=	.\std\fcomplex.h	/^  friend inline bool operator != (float x, const complex& y)$/;"	f	class:complex
operator !=	.\std\ldcomplex.h	/^  friend inline bool operator != (const complex& x, long double y)$/;"	f	class:complex
operator !=	.\std\ldcomplex.h	/^  friend inline bool operator != (long double x, const complex& y)$/;"	f	class:complex
operator !=	.\stl_bvector.h	/^  bool operator!=(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator
operator !=	.\stl_bvector.h	/^  bool operator!=(const iterator& x) const {$/;"	f	struct:__bit_iterator
operator !=	.\stl_deque.h	/^  bool operator!=(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque
operator !=	.\stl_deque.h	/^  bool operator!=(const self& x) const { return !(*this == x); }$/;"	f	struct:__deque_iterator::__deque_iterator
operator !=	.\stl_hashtable.h	/^  bool operator!=(const const_iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_const_iterator
operator !=	.\stl_hashtable.h	/^  bool operator!=(const iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_iterator
operator !=	.\stl_list.h	/^  bool operator!=(const self& x) const { return node != x.node; }$/;"	f	struct:__list_iterator
operator !=	.\stl_relops.h	/^inline bool operator!=(const T& x, const T& y) {$/;"	f
operator !=	.\stl_slist.h	/^  bool operator!=(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base
operator !=	.\stl_tree.h	/^inline bool operator!=(const __rb_tree_base_iterator& x,$/;"	f
operator &	.\ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator& () const {$/;"	f	class:__rope_charT_ref_proxy
operator ()	.\iomanip.h	/^    imanip<TP> operator()(TP a)$/;"	f	class:iapp
operator ()	.\iomanip.h	/^    omanip<TP> operator()(TP a)$/;"	f	class:oapp
operator ()	.\iomanip.h	/^    smanip<TP> operator()(TP a) $/;"	f	class:sapp
operator ()	.\ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_find_char_char_consumer
operator ()	.\ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_flatten_char_consumer
operator ()	.\ropeimpl.h	/^bool __rope_insert_char_consumer<charT>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	.\ropeimpl.h	/^inline bool __rope_insert_char_consumer<char>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	.\ropeimpl.h	/^inline bool __rope_insert_char_consumer<wchar_t>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	.\stl_algobase.h	/^  BidirectionalIterator2 operator()(BidirectionalIterator1 first, $/;"	f	struct:__copy_backward_dispatch
operator ()	.\stl_algobase.h	/^  OutputIterator operator()(InputIterator first, InputIterator last,$/;"	f	struct:__copy_dispatch
operator ()	.\stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch
operator ()	.\stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_dispatch
operator ()	.\stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch
operator ()	.\stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_dispatch
operator ()	.\stl_function.h	/^    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }$/;"	f	class:pointer_to_binary_function
operator ()	.\stl_function.h	/^    T operator()(const T& x) const { return -x; }$/;"	f	struct:negate
operator ()	.\stl_function.h	/^    T operator()(const T& x, const T& y) const { return x % y; }$/;"	f	struct:modulus
operator ()	.\stl_function.h	/^    T operator()(const T& x, const T& y) const { return x * y; }$/;"	f	struct:multiplies
operator ()	.\stl_function.h	/^    T operator()(const T& x, const T& y) const { return x + y; }$/;"	f	struct:plus
operator ()	.\stl_function.h	/^    T operator()(const T& x, const T& y) const { return x - y; }$/;"	f	struct:minus
operator ()	.\stl_function.h	/^    T operator()(const T& x, const T& y) const { return x \/ y; }$/;"	f	struct:divides
operator ()	.\stl_function.h	/^    bool operator()(const T& x) const { return !x; }$/;"	f	struct:logical_not
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x != y; }$/;"	f	struct:not_equal_to
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x && y; }$/;"	f	struct:logical_and
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x < y; }$/;"	f	struct:less
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x <= y; }$/;"	f	struct:less_equal
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x == y; }$/;"	f	struct:equal_to
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x > y; }$/;"	f	struct:greater
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x >= y; }$/;"	f	struct:greater_equal
operator ()	.\stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x || y; }$/;"	f	struct:logical_or
operator ()	.\stl_function.h	/^  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }$/;"	f	struct:project1st
operator ()	.\stl_function.h	/^  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }$/;"	f	struct:project2nd
operator ()	.\stl_function.h	/^  Result operator()(Arg x) const { return ptr(x); }$/;"	f	class:pointer_to_unary_function
operator ()	.\stl_function.h	/^  S operator()(T& r) const { return (r.*f)(); }$/;"	f	class:mem_fun_ref_t
operator ()	.\stl_function.h	/^  S operator()(T& r, A x) const { return (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t
operator ()	.\stl_function.h	/^  S operator()(T* p) const { return (p->*f)(); }$/;"	f	class:mem_fun_t
operator ()	.\stl_function.h	/^  S operator()(T* p, A x) const { return (p->*f)(x); }$/;"	f	class:mem_fun1_t
operator ()	.\stl_function.h	/^  S operator()(const T& r) const { return (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t
operator ()	.\stl_function.h	/^  S operator()(const T& r, A x) const { return (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t
operator ()	.\stl_function.h	/^  S operator()(const T* p) const { return (p->*f)(); }$/;"	f	class:const_mem_fun_t
operator ()	.\stl_function.h	/^  S operator()(const T* p, A x) const { return (p->*f)(x); }$/;"	f	class:const_mem_fun1_t
operator ()	.\stl_function.h	/^  bool operator()(const typename Predicate::argument_type& x) const {$/;"	f	class:unary_negate
operator ()	.\stl_function.h	/^  bool operator()(const typename Predicate::first_argument_type& x, $/;"	f	class:binary_negate
operator ()	.\stl_function.h	/^  const Result& operator()(const Arg1&, const Arg2&) const {$/;"	f	struct:constant_binary_fun
operator ()	.\stl_function.h	/^  const Result& operator()(const Argument&) const { return val; }$/;"	f	struct:constant_unary_fun
operator ()	.\stl_function.h	/^  const T& operator()(const T& x) const { return x; }$/;"	f	struct:identity
operator ()	.\stl_function.h	/^  const result_type& operator()() const { return val; }$/;"	f	struct:constant_void_fun
operator ()	.\stl_function.h	/^  const typename Pair::first_type& operator()(const Pair& x) const$/;"	f	struct:select1st
operator ()	.\stl_function.h	/^  const typename Pair::second_type& operator()(const Pair& x) const$/;"	f	struct:select2nd
operator ()	.\stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:binary_compose
operator ()	.\stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:unary_compose
operator ()	.\stl_function.h	/^  operator()(const typename Operation::first_argument_type& x) const {$/;"	f	class:binder2nd
operator ()	.\stl_function.h	/^  operator()(const typename Operation::second_argument_type& x) const {$/;"	f	class:binder1st
operator ()	.\stl_function.h	/^  unsigned int operator()(unsigned int limit) {$/;"	f	class:subtractive_rng
operator ()	.\stl_function.h	/^  void operator()(T& r) const { (r.*f)(); }$/;"	f	class:mem_fun_ref_t
operator ()	.\stl_function.h	/^  void operator()(T& r, A x) const { (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t
operator ()	.\stl_function.h	/^  void operator()(T* p) const { (p->*f)(); }$/;"	f	class:mem_fun_t
operator ()	.\stl_function.h	/^  void operator()(T* p, A x) const { (p->*f)(x); }$/;"	f	class:mem_fun1_t
operator ()	.\stl_function.h	/^  void operator()(const T& r) const { (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t
operator ()	.\stl_function.h	/^  void operator()(const T& r, A x) const { (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t
operator ()	.\stl_function.h	/^  void operator()(const T* p) const { (p->*f)(); }$/;"	f	class:const_mem_fun_t
operator ()	.\stl_function.h	/^  void operator()(const T* p, A x) const { (p->*f)(x); }$/;"	f	class:const_mem_fun1_t
operator ()	.\stl_hash_fun.h	/^  size_t operator()(char x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(const char* s) const { return __stl_hash_string(s); }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(int x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(long x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(short x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_hash_fun.h	/^  size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:hash
operator ()	.\stl_map.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:map::value_compare
operator ()	.\stl_multimap.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:multimap::value_compare
operator ()	.\stl_rope.h	/^		rope operator() (const rope& x, const rope& y) {$/;"	f	struct:rope::concat_fn
operator ()	.\stl_rope.h	/^    virtual void operator()(size_t start_pos, size_t req_len,$/;"	f	struct:__rope_RopeSubstring
operator ()	.\stl_rope.h	/^  size_t operator()(const crope& str) const$/;"	f	struct:hash
operator ()	.\stl_rope.h	/^  size_t operator()(const wrope& str) const$/;"	f	struct:hash
operator *	.\std\complext.h	/^operator * (_FLT x, const complex<_FLT>& y)$/;"	f
operator *	.\std\complext.h	/^operator * (const complex<_FLT>& x, _FLT y)$/;"	f
operator *	.\std\complext.h	/^operator * (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator *	.\std\dcomplex.h	/^  friend inline complex operator * (const complex& x, double y)$/;"	f	class:complex
operator *	.\std\dcomplex.h	/^  friend inline complex operator * (double x, const complex& y)$/;"	f	class:complex
operator *	.\std\fcomplex.h	/^  friend inline complex operator * (const complex& x, float y)$/;"	f	class:complex
operator *	.\std\fcomplex.h	/^  friend inline complex operator * (float x, const complex& y)$/;"	f	class:complex
operator *	.\std\ldcomplex.h	/^  friend inline complex operator * (const complex& x, long double y)$/;"	f	class:complex
operator *	.\std\ldcomplex.h	/^  friend inline complex operator * (long double x, const complex& y)$/;"	f	class:complex
operator *	.\stl_bvector.h	/^  const_reference operator*() const {$/;"	f	struct:__bit_const_iterator
operator *	.\stl_bvector.h	/^  reference operator*() const { return reference(p, 1U << offset); }$/;"	f	struct:__bit_iterator
operator *	.\stl_deque.h	/^  reference operator*() const { return *cur; }$/;"	f	struct:__deque_iterator::__deque_iterator
operator *	.\stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_const_iterator
operator *	.\stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_iterator
operator *	.\stl_iterator.h	/^  Reference operator*() const { return *(current - 1); }$/;"	f	class:reverse_iterator
operator *	.\stl_iterator.h	/^  Reference operator*() const {$/;"	f	class:reverse_bidirectional_iterator
operator *	.\stl_iterator.h	/^  back_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:back_insert_iterator
operator *	.\stl_iterator.h	/^  front_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:front_insert_iterator
operator *	.\stl_iterator.h	/^  insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:insert_iterator
operator *	.\stl_iterator.h	/^  ostream_iterator<T>& operator*() { return *this; }$/;"	f	class:ostream_iterator
operator *	.\stl_iterator.h	/^  reference operator*() const { return value; }$/;"	f	class:istream_iterator
operator *	.\stl_iterator.h	/^  reference operator*() const {$/;"	f	class:reverse_iterator
operator *	.\stl_list.h	/^  reference operator*() const { return (*node).data; }$/;"	f	struct:__list_iterator
operator *	.\stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }$/;"	f	class:raw_storage_iterator
operator *	.\stl_rope.h	/^	sequence_buffer& operator*() { return *this; }$/;"	f	class:sequence_buffer
operator *	.\stl_rope.h	/^    __rope_RopeBase<charT,Alloc> & operator*() { return *ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator *	.\stl_rope.h	/^    __rope_charT_ref_proxy<charT,Alloc> operator *() const {$/;"	f	class:__rope_charT_ptr_proxy
operator *	.\stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_const_iterator
operator *	.\stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_iterator
operator *	.\stl_slist.h	/^  reference operator*() const { return ((list_node*) node)->data; }$/;"	f	struct:__slist_iterator
operator *	.\stl_tree.h	/^  reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:__rb_tree_iterator
operator *=	.\std\complext.h	/^complex<_FLT>::operator *= (const complex<_FLT>& r)$/;"	f	class:complex
operator *=	.\std\dcomplex.h	/^  complex& operator*= (const complex& r) { return __doaml (this, r); }$/;"	f	class:complex
operator *=	.\std\fcomplex.h	/^  complex& operator*= (const complex& r) { return __doaml (this, r); }$/;"	f	class:complex
operator *=	.\std\ldcomplex.h	/^  complex& operator*= (const complex& r) { return __doaml (this, r); }$/;"	f	class:complex
operator +	.\std\bastring.h	/^operator+ (charT lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator +	.\std\bastring.h	/^operator+ (const basic_string <charT, traits, Allocator>& lhs, charT rhs)$/;"	f
operator +	.\std\bastring.h	/^operator+ (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator +	.\std\bastring.h	/^operator+ (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator +	.\std\bastring.h	/^operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator +	.\std\complext.h	/^operator + (_FLT x, const complex<_FLT>& y)$/;"	f
operator +	.\std\complext.h	/^operator + (const complex<_FLT>& x)$/;"	f
operator +	.\std\complext.h	/^operator + (const complex<_FLT>& x, _FLT y)$/;"	f
operator +	.\std\complext.h	/^operator + (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator +	.\std\dcomplex.h	/^  friend inline complex operator + (const complex& x, double y)$/;"	f	class:complex
operator +	.\std\dcomplex.h	/^  friend inline complex operator + (double x, const complex& y)$/;"	f	class:complex
operator +	.\std\fcomplex.h	/^  friend inline complex operator + (const complex& x, float y)$/;"	f	class:complex
operator +	.\std\fcomplex.h	/^  friend inline complex operator + (float x, const complex& y)$/;"	f	class:complex
operator +	.\std\ldcomplex.h	/^  friend inline complex operator + (const complex& x, long double y)$/;"	f	class:complex
operator +	.\std\ldcomplex.h	/^  friend inline complex operator + (long double x, const complex& y)$/;"	f	class:complex
operator +	.\stl_bvector.h	/^  const_iterator operator+(difference_type i) const {$/;"	f	struct:__bit_const_iterator
operator +	.\stl_bvector.h	/^  iterator operator+(difference_type i) const {$/;"	f	struct:__bit_iterator
operator +	.\stl_deque.h	/^  self operator+(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator +	.\stl_iterator.h	/^  self operator+(Distance n) const {$/;"	f	class:reverse_iterator
operator +	.\stl_iterator.h	/^  self operator+(difference_type n) const {$/;"	f	class:reverse_iterator
operator +	.\stl_iterator.h	/^operator+(Dist n, const reverse_iterator<RandomAccessIter, T, Ref, Dist>& x) {$/;"	f
operator +	.\stl_iterator.h	/^operator+(reverse_iterator<Iterator>::difference_type n,$/;"	f
operator +	.\stl_rope.h	/^operator+ (const rope<charT,Alloc> &left, charT right) {$/;"	f
operator +	.\stl_rope.h	/^operator+ (const rope<charT,Alloc> &left,$/;"	f
operator +	.\stl_rope.h	/^operator+(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator +	.\stl_rope.h	/^operator+(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator +	.\stl_rope.h	/^operator+(ptrdiff_t n,$/;"	f
operator ++	.\stl_bvector.h	/^  const_iterator operator++(int) {$/;"	f	struct:__bit_const_iterator
operator ++	.\stl_bvector.h	/^  const_iterator& operator++() {$/;"	f	struct:__bit_const_iterator
operator ++	.\stl_bvector.h	/^  iterator operator++(int) {$/;"	f	struct:__bit_iterator
operator ++	.\stl_bvector.h	/^  iterator& operator++() {$/;"	f	struct:__bit_iterator
operator ++	.\stl_deque.h	/^  self operator++(int)  {$/;"	f	struct:__deque_iterator::__deque_iterator
operator ++	.\stl_deque.h	/^  self& operator++() {$/;"	f	struct:__deque_iterator::__deque_iterator
operator ++	.\stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_const_iterator
operator ++	.\stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_const_iterator
operator ++	.\stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_iterator
operator ++	.\stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_iterator
operator ++	.\stl_iterator.h	/^  back_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:back_insert_iterator
operator ++	.\stl_iterator.h	/^  back_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:back_insert_iterator
operator ++	.\stl_iterator.h	/^  front_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:front_insert_iterator
operator ++	.\stl_iterator.h	/^  front_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:front_insert_iterator
operator ++	.\stl_iterator.h	/^  insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:insert_iterator
operator ++	.\stl_iterator.h	/^  insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:insert_iterator
operator ++	.\stl_iterator.h	/^  istream_iterator<T, Distance> operator++(int)  {$/;"	f	class:istream_iterator
operator ++	.\stl_iterator.h	/^  istream_iterator<T, Distance>& operator++() { $/;"	f	class:istream_iterator
operator ++	.\stl_iterator.h	/^  ostream_iterator<T>& operator++() { return *this; } $/;"	f	class:ostream_iterator
operator ++	.\stl_iterator.h	/^  ostream_iterator<T>& operator++(int) { return *this; } $/;"	f	class:ostream_iterator
operator ++	.\stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_bidirectional_iterator
operator ++	.\stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_iterator
operator ++	.\stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_bidirectional_iterator
operator ++	.\stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_iterator
operator ++	.\stl_list.h	/^  self operator++(int) { $/;"	f	struct:__list_iterator
operator ++	.\stl_list.h	/^  self& operator++() { $/;"	f	struct:__list_iterator
operator ++	.\stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T> operator++(int) {$/;"	f	class:raw_storage_iterator
operator ++	.\stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator++() {$/;"	f	class:raw_storage_iterator
operator ++	.\stl_rope.h	/^	sequence_buffer& operator++() { return *this; }$/;"	f	class:sequence_buffer
operator ++	.\stl_rope.h	/^	sequence_buffer& operator++(int) { return *this; }$/;"	f	class:sequence_buffer
operator ++	.\stl_rope.h	/^    __rope_const_iterator operator++(int) {$/;"	f	class:__rope_const_iterator
operator ++	.\stl_rope.h	/^    __rope_const_iterator& operator++() {$/;"	f	class:__rope_const_iterator
operator ++	.\stl_rope.h	/^    __rope_iterator operator++(int) {$/;"	f	class:__rope_iterator
operator ++	.\stl_rope.h	/^    __rope_iterator& operator++() {$/;"	f	class:__rope_iterator
operator ++	.\stl_slist.h	/^  self operator++(int)$/;"	f	struct:__slist_iterator
operator ++	.\stl_slist.h	/^  self& operator++()$/;"	f	struct:__slist_iterator
operator ++	.\stl_tree.h	/^  self operator++(int) {$/;"	f	struct:__rb_tree_iterator
operator ++	.\stl_tree.h	/^  self& operator++() { increment(); return *this; }$/;"	f	struct:__rb_tree_iterator
operator +=	.\std\bastring.h	/^  basic_string& operator+= (charT c)$/;"	f	class:basic_string
operator +=	.\std\bastring.h	/^  basic_string& operator+= (const basic_string& rhs)$/;"	f	class:basic_string
operator +=	.\std\bastring.h	/^  basic_string& operator+= (const charT* s)$/;"	f	class:basic_string
operator +=	.\std\complext.h	/^complex<_FLT>::operator += (const complex<_FLT>& r)$/;"	f	class:complex
operator +=	.\std\dcomplex.h	/^  complex& operator+= (const complex& r) { return __doapl (this, r); }$/;"	f	class:complex
operator +=	.\std\fcomplex.h	/^  complex& operator+= (const complex& r) { return __doapl (this, r); }$/;"	f	class:complex
operator +=	.\std\ldcomplex.h	/^  complex& operator+= (const complex& r) { return __doapl (this, r); }$/;"	f	class:complex
operator +=	.\stl_bvector.h	/^  const_iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_const_iterator
operator +=	.\stl_bvector.h	/^  iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_iterator
operator +=	.\stl_deque.h	/^  self& operator+=(difference_type n) {$/;"	f	struct:__deque_iterator::__deque_iterator
operator +=	.\stl_iterator.h	/^  self& operator+=(Distance n) {$/;"	f	class:reverse_iterator
operator +=	.\stl_iterator.h	/^  self& operator+=(difference_type n) {$/;"	f	class:reverse_iterator
operator +=	.\stl_rope.h	/^    __rope_const_iterator& operator+=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator
operator +=	.\stl_rope.h	/^    __rope_iterator& operator+=(difference_type n) {$/;"	f	class:__rope_iterator
operator +=	.\stl_rope.h	/^operator+= (rope<charT,Alloc> &left, charT right) {$/;"	f
operator +=	.\stl_rope.h	/^operator+= (rope<charT,Alloc> &left,$/;"	f
operator -	.\std\complext.h	/^operator - (_FLT x, const complex<_FLT>& y)$/;"	f
operator -	.\std\complext.h	/^operator - (const complex<_FLT>& x)$/;"	f
operator -	.\std\complext.h	/^operator - (const complex<_FLT>& x, _FLT y)$/;"	f
operator -	.\std\complext.h	/^operator - (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator -	.\std\dcomplex.h	/^  friend inline complex operator - (const complex& x, double y)$/;"	f	class:complex
operator -	.\std\dcomplex.h	/^  friend inline complex operator - (double x, const complex& y)$/;"	f	class:complex
operator -	.\std\fcomplex.h	/^  friend inline complex operator - (const complex& x, float y)$/;"	f	class:complex
operator -	.\std\fcomplex.h	/^  friend inline complex operator - (float x, const complex& y)$/;"	f	class:complex
operator -	.\std\ldcomplex.h	/^  friend inline complex operator - (const complex& x, long double y)$/;"	f	class:complex
operator -	.\std\ldcomplex.h	/^  friend inline complex operator - (long double x, const complex& y)$/;"	f	class:complex
operator -	.\stl_bvector.h	/^  const_iterator operator-(difference_type i) const {$/;"	f	struct:__bit_const_iterator
operator -	.\stl_bvector.h	/^  difference_type operator-(const_iterator x) const {$/;"	f	struct:__bit_const_iterator
operator -	.\stl_bvector.h	/^  difference_type operator-(iterator x) const {$/;"	f	struct:__bit_iterator
operator -	.\stl_bvector.h	/^  iterator operator-(difference_type i) const {$/;"	f	struct:__bit_iterator
operator -	.\stl_deque.h	/^  difference_type operator-(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator -	.\stl_deque.h	/^  self operator-(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator -	.\stl_iterator.h	/^  self operator-(Distance n) const {$/;"	f	class:reverse_iterator
operator -	.\stl_iterator.h	/^  self operator-(difference_type n) const {$/;"	f	class:reverse_iterator
operator -	.\stl_iterator.h	/^inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator -	.\stl_iterator.h	/^operator-(const reverse_iterator<Iterator>& x, $/;"	f
operator -	.\stl_rope.h	/^inline ptrdiff_t operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator -	.\stl_rope.h	/^inline ptrdiff_t operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator -	.\stl_rope.h	/^operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator -	.\stl_rope.h	/^operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator --	.\stl_bvector.h	/^  const_iterator operator--(int) {$/;"	f	struct:__bit_const_iterator
operator --	.\stl_bvector.h	/^  const_iterator& operator--() {$/;"	f	struct:__bit_const_iterator
operator --	.\stl_bvector.h	/^  iterator operator--(int) {$/;"	f	struct:__bit_iterator
operator --	.\stl_bvector.h	/^  iterator& operator--() {$/;"	f	struct:__bit_iterator
operator --	.\stl_deque.h	/^  self operator--(int) {$/;"	f	struct:__deque_iterator::__deque_iterator
operator --	.\stl_deque.h	/^  self& operator--() {$/;"	f	struct:__deque_iterator::__deque_iterator
operator --	.\stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_bidirectional_iterator
operator --	.\stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_iterator
operator --	.\stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_bidirectional_iterator
operator --	.\stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_iterator
operator --	.\stl_list.h	/^  self operator--(int) { $/;"	f	struct:__list_iterator
operator --	.\stl_list.h	/^  self& operator--() { $/;"	f	struct:__list_iterator
operator --	.\stl_rope.h	/^    __rope_const_iterator operator--(int) {$/;"	f	class:__rope_const_iterator
operator --	.\stl_rope.h	/^    __rope_const_iterator& operator--() {$/;"	f	class:__rope_const_iterator
operator --	.\stl_rope.h	/^    __rope_iterator operator--(int) {$/;"	f	class:__rope_iterator
operator --	.\stl_rope.h	/^    __rope_iterator& operator--() {$/;"	f	class:__rope_iterator
operator --	.\stl_tree.h	/^  self operator--(int) {$/;"	f	struct:__rb_tree_iterator
operator --	.\stl_tree.h	/^  self& operator--() { decrement(); return *this; }$/;"	f	struct:__rb_tree_iterator
operator -=	.\std\complext.h	/^complex<_FLT>::operator -= (const complex<_FLT>& r)$/;"	f	class:complex
operator -=	.\std\dcomplex.h	/^  complex& operator-= (const complex& r) { return __doami (this, r); }$/;"	f	class:complex
operator -=	.\std\fcomplex.h	/^  complex& operator-= (const complex& r) { return __doami (this, r); }$/;"	f	class:complex
operator -=	.\std\ldcomplex.h	/^  complex& operator-= (const complex& r) { return __doami (this, r); }$/;"	f	class:complex
operator -=	.\stl_bvector.h	/^  const_iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_const_iterator
operator -=	.\stl_bvector.h	/^  iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_iterator
operator -=	.\stl_deque.h	/^  self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:__deque_iterator::__deque_iterator
operator -=	.\stl_iterator.h	/^  self& operator-=(Distance n) {$/;"	f	class:reverse_iterator
operator -=	.\stl_iterator.h	/^  self& operator-=(difference_type n) {$/;"	f	class:reverse_iterator
operator -=	.\stl_rope.h	/^    __rope_const_iterator& operator-=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator
operator -=	.\stl_rope.h	/^    __rope_iterator& operator-=(difference_type n) {$/;"	f	class:__rope_iterator
operator ->	.\stl_deque.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__deque_iterator::__deque_iterator
operator ->	.\stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_const_iterator
operator ->	.\stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_iterator
operator ->	.\stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:istream_iterator
operator ->	.\stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_bidirectional_iterator
operator ->	.\stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_iterator
operator ->	.\stl_list.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__list_iterator
operator ->	.\stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * operator->() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator ->	.\stl_slist.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__slist_iterator
operator ->	.\stl_tree.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__rb_tree_iterator
operator /	.\std\complext.cc	/^operator \/ (FLOAT x, const complex<FLOAT>& y)$/;"	f
operator /	.\std\complext.cc	/^operator \/ (const complex<FLOAT>& x, const complex<FLOAT>& y)$/;"	f
operator /	.\std\complext.h	/^operator \/ (const complex<_FLT>& x, _FLT y)$/;"	f
operator /	.\std\dcomplex.h	/^  friend inline complex operator \/ (const complex& x, double y)$/;"	f	class:complex
operator /	.\std\dcomplex.h	/^  friend inline complex operator \/ (double x, const complex& y)$/;"	f	class:complex
operator /	.\std\fcomplex.h	/^  friend inline complex operator \/ (const complex& x, float y)$/;"	f	class:complex
operator /	.\std\fcomplex.h	/^  friend inline complex operator \/ (float x, const complex& y)$/;"	f	class:complex
operator /	.\std\ldcomplex.h	/^  friend inline complex operator \/ (const complex& x, long double y)$/;"	f	class:complex
operator /	.\std\ldcomplex.h	/^  friend inline complex operator \/ (long double x, const complex& y)$/;"	f	class:complex
operator /=	.\std\complext.h	/^complex<_FLT>::operator \/= (const complex<_FLT>& r)$/;"	f	class:complex
operator /=	.\std\dcomplex.h	/^  complex& operator\/= (const complex& r) { return __doadv (this, r); }$/;"	f	class:complex
operator /=	.\std\fcomplex.h	/^  complex& operator\/= (const complex& r) { return __doadv (this, r); }$/;"	f	class:complex
operator /=	.\std\ldcomplex.h	/^  complex& operator\/= (const complex& r) { return __doadv (this, r); }$/;"	f	class:complex
operator <	.\std\bastring.h	/^operator< (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator <	.\std\bastring.h	/^operator< (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator <	.\std\bastring.h	/^operator< (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator <	.\stl_bvector.h	/^  bool operator<(const __bit_reference& x) const {$/;"	f	struct:__bit_reference
operator <	.\stl_bvector.h	/^  bool operator<(const_iterator x) const {$/;"	f	struct:__bit_const_iterator
operator <	.\stl_bvector.h	/^  bool operator<(iterator x) const {$/;"	f	struct:__bit_iterator
operator <	.\stl_bvector.h	/^inline bool operator<(const bit_vector& x, const bit_vector& y) {$/;"	f
operator <	.\stl_deque.h	/^  bool operator<(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque
operator <	.\stl_deque.h	/^  bool operator<(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator <	.\stl_deque.h	/^bool operator<(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator
operator <	.\stl_iterator.h	/^inline bool operator<(const reverse_iterator<Iterator>& x, $/;"	f
operator <	.\stl_iterator.h	/^inline bool operator<(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator <	.\stl_list.h	/^inline bool operator<(const list<T, Alloc>& x, const list<T, Alloc>& y) {$/;"	f
operator <	.\stl_map.h	/^inline bool operator<(const map<Key, T, Compare, Alloc>& x, $/;"	f
operator <	.\stl_multimap.h	/^inline bool operator<(const multimap<Key, T, Compare, Alloc>& x, $/;"	f
operator <	.\stl_multiset.h	/^inline bool operator<(const multiset<Key, Compare, Alloc>& x, $/;"	f
operator <	.\stl_pair.h	/^inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f
operator <	.\stl_queue.h	/^bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {$/;"	f
operator <	.\stl_rope.h	/^inline bool operator< (const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator <	.\stl_rope.h	/^inline bool operator< (const __rope_iterator<charT,Alloc> & x,$/;"	f
operator <	.\stl_rope.h	/^operator< (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f
operator <	.\stl_set.h	/^inline bool operator<(const set<Key, Compare, Alloc>& x, $/;"	f
operator <	.\stl_slist.h	/^inline bool operator<(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f
operator <	.\stl_stack.h	/^bool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f
operator <	.\stl_tree.h	/^inline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
operator <	.\stl_vector.h	/^inline bool operator<(const vector<T, Alloc>& x, const vector<T, Alloc>& y) {$/;"	f
operator <<	.\iomanip.h	/^inline ostream& operator<<(ostream& o, const omanip<TP>& m)$/;"	f
operator <<	.\iomanip.h	/^inline ostream& operator<<(ostream& o, const smanip<TP>& m)$/;"	f
operator <<	.\iostream.h	/^    ostream& operator<<(__manip func) {(*func)(*this); return *this;}$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(__omanip func) { return (*func)(*this); }$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(bool b) { return operator<<((int)b); }$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(const signed char *s)$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(const unsigned char *s)$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(float n) { return operator<<((double)n); }$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(long double n) { return operator<<((double)n); }$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(short n) {return operator<<((int)n);}$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(signed char c) { return (*this) << (char)c; }$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }$/;"	f	class:ostream
operator <<	.\iostream.h	/^    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}$/;"	f	class:ostream
operator <<	.\ropeimpl.h	/^ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)$/;"	f
operator <<	.\std\bastring.cc	/^operator<< (ostream &o, const basic_string <charT, traits, Allocator>& s)$/;"	f
operator <<	.\std\complext.cc	/^operator << (ostream& os, const complex<FLOAT>& x)$/;"	f
operator <=	.\std\bastring.h	/^operator<= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator <=	.\std\bastring.h	/^operator<= (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator <=	.\std\bastring.h	/^operator<= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator <=	.\stl_relops.h	/^inline bool operator<=(const T& x, const T& y) {$/;"	f
operator =	.\iostream.h	/^  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)$/;"	f	class:_IO_istream_withassign
operator =	.\iostream.h	/^  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)$/;"	f	class:_IO_ostream_withassign
operator =	.\ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator= (charT c) {$/;"	f	class:__rope_charT_ref_proxy
operator =	.\std\bastring.h	/^  basic_string& operator= (charT c)$/;"	f	class:basic_string
operator =	.\std\bastring.h	/^  basic_string& operator= (const basic_string& str)$/;"	f	class:basic_string
operator =	.\std\bastring.h	/^  basic_string& operator= (const charT* s)$/;"	f	class:basic_string
operator =	.\stl_bvector.h	/^  __BVECTOR& operator=(const __BVECTOR& x) {$/;"	f	class:vector
operator =	.\stl_bvector.h	/^  __bit_reference& operator=(bool x) {$/;"	f	struct:__bit_reference
operator =	.\stl_bvector.h	/^  __bit_reference& operator=(const __bit_reference& x) { return *this = bool(x); }$/;"	f	struct:__bit_reference
operator =	.\stl_deque.h	/^  deque& operator= (const deque& x) {$/;"	f	class:__deque_iterator::deque
operator =	.\stl_hashtable.h	/^  hashtable& operator= (const hashtable& ht)$/;"	f	class:hashtable
operator =	.\stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:back_insert_iterator
operator =	.\stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:front_insert_iterator
operator =	.\stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:insert_iterator
operator =	.\stl_iterator.h	/^  ostream_iterator<T>& operator=(const T& value) { $/;"	f	class:ostream_iterator
operator =	.\stl_list.h	/^list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x) {$/;"	f	class:list
operator =	.\stl_map.h	/^  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)$/;"	f	class:map
operator =	.\stl_multimap.h	/^  operator=(const multimap<Key, T, Compare, Alloc>& x) {$/;"	f	class:multimap
operator =	.\stl_multiset.h	/^  operator=(const multiset<Key, Compare, Alloc>& x) {$/;"	f	class:multiset
operator =	.\stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {$/;"	f	class:raw_storage_iterator
operator =	.\stl_rope.h	/^	rope& operator=(const rope& x)$/;"	f	class:rope
operator =	.\stl_rope.h	/^	sequence_buffer& operator= (const sequence_buffer& x) {$/;"	f	class:sequence_buffer
operator =	.\stl_rope.h	/^	sequence_buffer& operator= (sequence_buffer& x) {$/;"	f	class:sequence_buffer
operator =	.\stl_rope.h	/^	sequence_buffer& operator=(const value_type& rhs)$/;"	f	class:sequence_buffer
operator =	.\stl_rope.h	/^    __rope_charT_ptr_proxy& operator= (const __rope_charT_ptr_proxy& x) {$/;"	f	class:__rope_charT_ptr_proxy
operator =	.\stl_rope.h	/^    __rope_charT_ref_proxy& operator= (const __rope_charT_ref_proxy& c) {$/;"	f	class:__rope_charT_ref_proxy
operator =	.\stl_rope.h	/^    __rope_const_iterator& operator= (const __rope_const_iterator & x) {$/;"	f	class:__rope_const_iterator
operator =	.\stl_rope.h	/^    __rope_iterator& operator= (const __rope_iterator & x) {$/;"	f	class:__rope_iterator
operator =	.\stl_rope.h	/^    __rope_self_destruct_ptr & operator= (__rope_RopeBase<charT,Alloc> * x)$/;"	f	struct:__rope_self_destruct_ptr
operator =	.\stl_set.h	/^  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { $/;"	f	class:set
operator =	.\stl_slist.h	/^slist<T, Alloc>& slist<T,Alloc>::operator=(const slist<T, Alloc>& L)$/;"	f	class:slist
operator =	.\stl_tempbuf.h	/^  void operator=(const temporary_buffer&) {}$/;"	f	class:temporary_buffer
operator =	.\stl_tree.h	/^operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {$/;"	f	class:rb_tree
operator =	.\stl_vector.h	/^vector<T, Alloc>& vector<T, Alloc>::operator=(const vector<T, Alloc>& x) {$/;"	f	class:vector
operator ==	.\std\bastring.h	/^operator== (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator ==	.\std\bastring.h	/^operator== (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator ==	.\std\bastring.h	/^operator== (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator ==	.\std\complext.h	/^operator == (_FLT x, const complex<_FLT>& y)$/;"	f
operator ==	.\std\complext.h	/^operator == (const complex<_FLT>& x, _FLT y)$/;"	f
operator ==	.\std\complext.h	/^operator == (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator ==	.\std\dcomplex.h	/^  friend inline bool operator == (const complex& x, double y)$/;"	f	class:complex
operator ==	.\std\dcomplex.h	/^  friend inline bool operator == (double x, const complex& y)$/;"	f	class:complex
operator ==	.\std\fcomplex.h	/^  friend inline bool operator == (const complex& x, float y)$/;"	f	class:complex
operator ==	.\std\fcomplex.h	/^  friend inline bool operator == (float x, const complex& y)$/;"	f	class:complex
operator ==	.\std\ldcomplex.h	/^  friend inline bool operator == (const complex& x, long double y)$/;"	f	class:complex
operator ==	.\std\ldcomplex.h	/^  friend inline bool operator == (long double x, const complex& y)$/;"	f	class:complex
operator ==	.\stl_bvector.h	/^  bool operator==(const __bit_reference& x) const {$/;"	f	struct:__bit_reference
operator ==	.\stl_bvector.h	/^  bool operator==(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator
operator ==	.\stl_bvector.h	/^  bool operator==(const iterator& x) const {$/;"	f	struct:__bit_iterator
operator ==	.\stl_bvector.h	/^inline bool operator==(const bit_vector& x, const bit_vector& y) {$/;"	f
operator ==	.\stl_deque.h	/^  bool operator==(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque
operator ==	.\stl_deque.h	/^  bool operator==(const self& x) const { return cur == x.cur; }$/;"	f	struct:__deque_iterator::__deque_iterator
operator ==	.\stl_deque.h	/^bool operator==(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator
operator ==	.\stl_hash_map.h	/^inline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
operator ==	.\stl_hash_map.h	/^inline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,$/;"	f
operator ==	.\stl_hash_set.h	/^inline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
operator ==	.\stl_hash_set.h	/^inline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
operator ==	.\stl_hashtable.h	/^  bool operator==(const const_iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_const_iterator
operator ==	.\stl_hashtable.h	/^  bool operator==(const iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_iterator
operator ==	.\stl_hashtable.h	/^bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,$/;"	f
operator ==	.\stl_iterator.h	/^inline bool operator==($/;"	f
operator ==	.\stl_iterator.h	/^inline bool operator==(const istream_iterator<T, Distance>& x,$/;"	f
operator ==	.\stl_iterator.h	/^inline bool operator==(const reverse_iterator<Iterator>& x, $/;"	f
operator ==	.\stl_iterator.h	/^inline bool operator==(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator ==	.\stl_list.h	/^  bool operator==(const self& x) const { return node == x.node; }$/;"	f	struct:__list_iterator
operator ==	.\stl_list.h	/^inline bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y) {$/;"	f
operator ==	.\stl_map.h	/^inline bool operator==(const map<Key, T, Compare, Alloc>& x, $/;"	f
operator ==	.\stl_multimap.h	/^inline bool operator==(const multimap<Key, T, Compare, Alloc>& x, $/;"	f
operator ==	.\stl_multiset.h	/^inline bool operator==(const multiset<Key, Compare, Alloc>& x, $/;"	f
operator ==	.\stl_pair.h	/^inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f
operator ==	.\stl_queue.h	/^bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {$/;"	f
operator ==	.\stl_rope.h	/^inline bool operator== (const __rope_charT_ptr_proxy<charT,Alloc> & x,$/;"	f
operator ==	.\stl_rope.h	/^inline bool operator== (const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator ==	.\stl_rope.h	/^inline bool operator== (const __rope_iterator<charT,Alloc> & x,$/;"	f
operator ==	.\stl_rope.h	/^operator== (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f
operator ==	.\stl_set.h	/^inline bool operator==(const set<Key, Compare, Alloc>& x, $/;"	f
operator ==	.\stl_slist.h	/^  bool operator==(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base
operator ==	.\stl_slist.h	/^bool operator==(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f
operator ==	.\stl_stack.h	/^bool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f
operator ==	.\stl_tree.h	/^inline bool operator==(const __rb_tree_base_iterator& x,$/;"	f
operator ==	.\stl_tree.h	/^inline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
operator ==	.\stl_vector.h	/^inline bool operator==(const vector<T, Alloc>& x, const vector<T, Alloc>& y) {$/;"	f
operator >	.\std\bastring.h	/^operator> (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator >	.\std\bastring.h	/^operator> (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator >	.\std\bastring.h	/^operator> (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator >	.\stl_relops.h	/^inline bool operator>(const T& x, const T& y) {$/;"	f
operator >=	.\std\bastring.h	/^operator>= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator >=	.\std\bastring.h	/^operator>= (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator >=	.\std\bastring.h	/^operator>= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator >=	.\stl_relops.h	/^inline bool operator>=(const T& x, const T& y) {$/;"	f
operator >>	.\iomanip.h	/^inline istream& operator>>(istream& i, const imanip<TP>& m)$/;"	f
operator >>	.\iomanip.h	/^inline istream& operator>>(istream& i, const smanip<TP>& m)$/;"	f
operator >>	.\iostream.h	/^    istream& operator>>( __manip func) {(*func)(*this); return *this;}$/;"	f	class:istream
operator >>	.\iostream.h	/^    istream& operator>>(__imanip func) { return (*func)(*this); }$/;"	f	class:istream
operator >>	.\iostream.h	/^    istream& operator>>(signed char& c) {return operator>>((char&)c);}$/;"	f	class:istream
operator >>	.\iostream.h	/^    istream& operator>>(signed char*p) { return operator>>((char*)p); }$/;"	f	class:istream
operator >>	.\iostream.h	/^    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}$/;"	f	class:istream
operator >>	.\iostream.h	/^    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }$/;"	f	class:istream
operator >>	.\std\bastring.cc	/^operator>> (istream &is, basic_string <charT, traits, Allocator> &s)$/;"	f
operator >>	.\std\complext.cc	/^operator >> (istream& is, complex<FLOAT>& x)$/;"	f
operator []	.\std\bastring.h	/^    charT& operator[] (size_t s) { return data () [s]; }$/;"	f	struct:basic_string::Rep
operator []	.\std\bastring.h	/^  charT operator[] (size_type pos) const$/;"	f	class:basic_string
operator []	.\std\bastring.h	/^  reference operator[] (size_type pos)$/;"	f	class:basic_string
operator []	.\stl_bvector.h	/^  const_reference operator[](difference_type i) { $/;"	f	struct:__bit_const_iterator
operator []	.\stl_bvector.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:vector
operator []	.\stl_bvector.h	/^  reference operator[](difference_type i) { return *(*this + i); }$/;"	f	struct:__bit_iterator
operator []	.\stl_bvector.h	/^  reference operator[](size_type n) {$/;"	f	class:vector
operator []	.\stl_deque.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:__deque_iterator::deque
operator []	.\stl_deque.h	/^  reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:__deque_iterator::__deque_iterator
operator []	.\stl_deque.h	/^  reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:__deque_iterator::deque
operator []	.\stl_hash_map.h	/^  T& operator[](const key_type& key) {$/;"	f	class:hash_map
operator []	.\stl_iterator.h	/^  Reference operator[](Distance n) const { return *(*this + n); }$/;"	f	class:reverse_iterator
operator []	.\stl_iterator.h	/^  reference operator[](difference_type n) const { return *(*this + n); }  $/;"	f	class:reverse_iterator
operator []	.\stl_map.h	/^  T& operator[](const key_type& k) {$/;"	f	class:map
operator []	.\stl_rope.h	/^	    reference operator[] (size_type pos) {$/;"	f	class:rope
operator []	.\stl_rope.h	/^	charT operator[] (size_type pos) const {$/;"	f	class:rope
operator []	.\stl_rope.h	/^    reference operator[](ptrdiff_t n) {$/;"	f	class:__rope_iterator
operator []	.\stl_rope.h	/^    reference operator[](size_t n) {$/;"	f	class:__rope_const_iterator
operator []	.\stl_vector.h	/^  const_reference operator[](size_type n) const { return *(begin() + n); }$/;"	f	class:vector
operator []	.\stl_vector.h	/^  reference operator[](size_type n) { return *(begin() + n); }$/;"	f	class:vector
operator __rope_RopeBase<charT,Alloc> *	.\stl_rope.h	/^    operator __rope_RopeBase<charT,Alloc> *() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator bool	.\stl_bvector.h	/^  operator bool() const { return !(!(*p & mask)); }$/;"	f	struct:__bit_reference
operator charT	.\ropeimpl.h	/^inline __rope_charT_ref_proxy<charT, Alloc>::operator charT () const$/;"	f	class:__rope_charT_ref_proxy
operator delete	.\std\bastring.cc	/^operator delete (void * ptr)$/;"	f	class:basic_string::Rep
operator new	.\std\bastring.cc	/^operator new (size_t s, size_t extra)$/;"	f	class:basic_string::Rep
operator void*	.\streambuf.h	/^    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }$/;"	f	class:ios
opfstream	.\pfstream.h	/^class opfstream : public ofstream {$/;"	c
opfx	.\iostream.h	/^    int opfx() {$/;"	f	class:ostream
original_len	.\stl_tempbuf.h	/^  ptrdiff_t original_len;$/;"	m	class:temporary_buffer
osfx	.\iostream.h	/^    void osfx() { _IO_funlockfile(_strbuf);$/;"	f	class:ostream
ostdiostream	.\stdiostream.h	/^  ostdiostream (FILE* __f) : ostream(), _file(__f) { init(&_file); }$/;"	f	class:ostdiostream
ostdiostream	.\stdiostream.h	/^class ostdiostream : public ostream$/;"	c
ostream	.\iostream.h	/^    ostream() { }$/;"	f	class:ostream
ostream	.\iostream.h	/^class ostream : virtual public ios$/;"	c
ostream_iterator	.\stl_iterator.h	/^  ostream_iterator(ostream& s) : stream(&s), string(0) {}$/;"	f	class:ostream_iterator
ostream_iterator	.\stl_iterator.h	/^  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}$/;"	f	class:ostream_iterator
ostream_iterator	.\stl_iterator.h	/^class ostream_iterator {$/;"	c
ostreambuf	.\iostream.h	/^    streambuf* ostreambuf() const { return _strbuf; }$/;"	f	class:ostream
ostrstream	.\strstream.h	/^    ostrstream() { }$/;"	f	class:ostrstream
ostrstream	.\strstream.h	/^    ostrstream(char *cp, int n, int mode=ios::out) :strstreambase(cp,n,mode){}$/;"	f	class:ostrstream
ostrstream	.\strstream.h	/^class ostrstream : public strstreambase, public ostream {$/;"	c
out	.\streambuf.h	/^	out = _IO_OUTPUT,$/;"	e	enum:ios::open_mode
out_waiting	.\streambuf.h	/^    int out_waiting() { return _IO_write_ptr - _IO_write_base; }$/;"	f	struct:streambuf
output	.\streambuf.h	/^    output = _IO_OUTPUT,$/;"	e	enum:open_mode
output_iterator	.\stl_iterator.h	/^struct output_iterator {$/;"	s
output_iterator_tag	.\stl_iterator.h	/^struct output_iterator_tag {};$/;"	s
p	.\stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_const_iterator
p	.\stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_iterator
p	.\stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_reference
padn	.\streambuf.h	/^    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }$/;"	f	struct:streambuf
pair	.\stl_pair.h	/^  pair() : first(T1()), second(T2()) {}$/;"	f	struct:pair
pair	.\stl_pair.h	/^  pair(const T1& a, const T2& b) : first(a), second(b) {}$/;"	f	struct:pair
pair	.\stl_pair.h	/^  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}$/;"	f	struct:pair
pair	.\stl_pair.h	/^struct pair {$/;"	s
pair_iterator_bool	.\stl_set.h	/^  typedef  pair<iterator, bool> pair_iterator_bool; $/;"	t	class:set
parent	.\stl_tree.h	/^  base_ptr parent;$/;"	m	struct:__rb_tree_node_base
parent	.\stl_tree.h	/^  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree
parent	.\stl_tree.h	/^  static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree
parsebuf	.\parsestream.h	/^    parsebuf() { chain= NULL;$/;"	f	class:parsebuf
parsebuf	.\parsestream.h	/^class parsebuf : public streambuf {$/;"	c
partial_sort	.\stl_algo.h	/^inline void partial_sort(RandomAccessIterator first,$/;"	f
partial_sort_copy	.\stl_algo.h	/^partial_sort_copy(InputIterator first, InputIterator last,$/;"	f
partial_sum	.\stl_numeric.h	/^OutputIterator partial_sum(InputIterator first, InputIterator last,$/;"	f
partition	.\stl_algo.h	/^BidirectionalIterator partition(BidirectionalIterator first,$/;"	f
path_cache_len	.\stl_rope.h	/^    enum { path_cache_len = 4 }; \/\/ Must be <= 9.$/;"	e	enum:__rope_iterator_base::__anon12
path_directions	.\stl_rope.h	/^    unsigned char path_directions;$/;"	m	class:__rope_iterator_base
path_end	.\stl_rope.h	/^    const RopeBase * path_end[path_cache_len];$/;"	m	class:__rope_iterator_base
pattern	.\ropeimpl.h	/^	charT pattern;$/;"	m	class:__rope_find_char_char_consumer
pbase	.\streambuf.h	/^    char* pbase() const { return _IO_write_base; }$/;"	f	struct:streambuf
pbump	.\streambuf.h	/^    void pbump(int n) { _IO_write_ptr += n; }$/;"	f	struct:streambuf
pclose	.\iostdio.h	109;"	d
pcount	.\strstream.h	/^    _IO_ssize_t pcount() { return ((strstreambuf*)_strbuf)->pcount(); }$/;"	f	class:ostrstream
pcount	.\strstream.h	/^    _IO_ssize_t pcount() { return ((strstreambuf*)_strbuf)->pcount(); }$/;"	f	class:strstream
perror	.\iostdio.h	82;"	d
plus	.\stl_function.h	/^struct plus : public binary_function<T, T, T> {$/;"	s
pointer	.\defalloc.h	/^    typedef T* pointer;$/;"	t	class:allocator
pointer	.\defalloc.h	/^    typedef void* pointer;$/;"	t	class:allocator
pointer	.\std\bastring.h	/^  typedef charT* pointer;$/;"	t	class:basic_string
pointer	.\stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	class:vector
pointer	.\stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	struct:__bit_iterator
pointer	.\stl_bvector.h	/^  typedef const bool*          pointer;$/;"	t	struct:__bit_const_iterator
pointer	.\stl_deque.h	/^  typedef Ptr pointer;$/;"	t	struct:__deque_iterator::__deque_iterator
pointer	.\stl_deque.h	/^  typedef value_type* pointer;$/;"	t	class:__deque_iterator::deque
pointer	.\stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_map
pointer	.\stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_multimap
pointer	.\stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_multiset
pointer	.\stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_set
pointer	.\stl_hashtable.h	/^  typedef Value* pointer;$/;"	t	struct:__hashtable_iterator
pointer	.\stl_hashtable.h	/^  typedef const Value* pointer;$/;"	t	struct:__hashtable_const_iterator
pointer	.\stl_hashtable.h	/^  typedef value_type*       pointer;$/;"	t	class:hashtable
pointer	.\stl_iterator.h	/^          pointer;$/;"	t	class:reverse_iterator
pointer	.\stl_iterator.h	/^  typedef Pointer   pointer;$/;"	t	struct:iterator
pointer	.\stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_bidirectional_iterator
pointer	.\stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_iterator
pointer	.\stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:bidirectional_iterator
pointer	.\stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:iterator_traits
pointer	.\stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:random_access_iterator
pointer	.\stl_iterator.h	/^  typedef T*                   pointer;$/;"	t	struct:forward_iterator
pointer	.\stl_iterator.h	/^  typedef T*                 pointer;$/;"	t	struct:input_iterator
pointer	.\stl_iterator.h	/^  typedef const T*                   pointer;$/;"	t	struct:iterator_traits
pointer	.\stl_iterator.h	/^  typedef const T*           pointer;$/;"	t	class:istream_iterator
pointer	.\stl_iterator.h	/^  typedef typename Iterator::pointer           pointer;$/;"	t	struct:iterator_traits
pointer	.\stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:back_insert_iterator
pointer	.\stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:front_insert_iterator
pointer	.\stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:insert_iterator
pointer	.\stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:ostream_iterator
pointer	.\stl_iterator.h	/^  typedef void                pointer;$/;"	t	struct:output_iterator
pointer	.\stl_list.h	/^  typedef Ptr pointer;$/;"	t	struct:__list_iterator
pointer	.\stl_list.h	/^  typedef value_type* pointer;$/;"	t	class:list
pointer	.\stl_map.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:map
pointer	.\stl_multimap.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:multimap
pointer	.\stl_multiset.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:multiset
pointer	.\stl_raw_storage_iter.h	/^  typedef void                pointer;$/;"	t	class:raw_storage_iterator
pointer	.\stl_rope.h	/^	typedef __rope_charT_ptr_proxy<charT,Alloc> pointer;$/;"	t	class:rope
pointer	.\stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;$/;"	t	class:__rope_iterator
pointer	.\stl_rope.h	/^    typedef const charT* pointer;$/;"	t	class:__rope_const_iterator
pointer	.\stl_set.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:set
pointer	.\stl_slist.h	/^  typedef Ptr pointer;$/;"	t	struct:__slist_iterator
pointer	.\stl_slist.h	/^  typedef value_type* pointer;$/;"	t	class:slist
pointer	.\stl_tree.h	/^  typedef Ptr pointer;$/;"	t	struct:__rb_tree_iterator
pointer	.\stl_tree.h	/^  typedef value_type* pointer;$/;"	t	class:rb_tree
pointer	.\stl_vector.h	/^  typedef value_type* pointer;$/;"	t	class:vector
pointer_to_binary_function	.\stl_function.h	/^    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}$/;"	f	class:pointer_to_binary_function
pointer_to_binary_function	.\stl_function.h	/^    pointer_to_binary_function() {}$/;"	f	class:pointer_to_binary_function
pointer_to_binary_function	.\stl_function.h	/^class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {$/;"	c
pointer_to_unary_function	.\stl_function.h	/^  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}$/;"	f	class:pointer_to_unary_function
pointer_to_unary_function	.\stl_function.h	/^  pointer_to_unary_function() {}$/;"	f	class:pointer_to_unary_function
pointer_to_unary_function	.\stl_function.h	/^class pointer_to_unary_function : public unary_function<Arg, Result> {$/;"	c
polar	.\std\complext.h	/^polar (_FLT r, _FLT t)$/;"	f
pop	.\stl_queue.h	/^  void pop() { c.pop_front(); }$/;"	f	class:queue
pop	.\stl_queue.h	/^  void pop() {$/;"	f	class:priority_queue
pop	.\stl_stack.h	/^  void pop() { c.pop_back(); }$/;"	f	class:stack
pop_back	.\stl_bvector.h	/^  void pop_back() { --finish; }$/;"	f	class:vector
pop_back	.\stl_deque.h	/^  void pop_back() {$/;"	f	class:__deque_iterator::deque
pop_back	.\stl_list.h	/^  void pop_back() { $/;"	f	class:list
pop_back	.\stl_rope.h	/^	void pop_back()$/;"	f	class:rope
pop_back	.\stl_vector.h	/^  void pop_back() {$/;"	f	class:vector
pop_back_aux	.\stl_deque.h	/^void deque<T, Alloc, BufSize>:: pop_back_aux() {$/;"	f	class:__deque_iterator::deque
pop_front	.\stl_deque.h	/^  void pop_front() {$/;"	f	class:__deque_iterator::deque
pop_front	.\stl_list.h	/^  void pop_front() { erase(begin()); }$/;"	f	class:list
pop_front	.\stl_rope.h	/^	void pop_front()$/;"	f	class:rope
pop_front	.\stl_slist.h	/^  void pop_front() {$/;"	f	class:slist
pop_front_aux	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:__deque_iterator::deque
pop_heap	.\stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
pop_heap	.\stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
popen	.\iostdio.h	108;"	d
pos	.\stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ptr_proxy
pos	.\stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ref_proxy
pos_at_line_start	.\parsestream.h	/^    _IO_fpos_t pos_at_line_start;$/;"	m	class:parsebuf
pow	.\std\complext.cc	/^pow (FLOAT x, const complex<FLOAT>& y)$/;"	f
pow	.\std\complext.cc	/^pow (const complex<FLOAT>& x, FLOAT y)$/;"	f
pow	.\std\complext.cc	/^pow (const complex<FLOAT>& x, const complex<FLOAT>& y)$/;"	f
pow	.\std\complext.cc	/^pow (const complex<FLOAT>& xin, int y)$/;"	f
power	.\stl_numeric.h	/^T power(T x, Integer n, MonoidOperation op) {$/;"	f
power	.\stl_numeric.h	/^inline T power(T x, Integer n) {$/;"	f
pptr	.\streambuf.h	/^    char* pptr() const { return _IO_write_ptr; }$/;"	f	struct:streambuf
precision	.\streambuf.h	/^    int precision() const { return _precision; }$/;"	f	class:ios
precision	.\streambuf.h	/^    int precision(int newp) {$/;"	f	class:ios
pred	.\stl_function.h	/^  Predicate pred;$/;"	m	class:binary_negate
pred	.\stl_function.h	/^  Predicate pred;$/;"	m	class:unary_negate
prefix	.\stl_rope.h	/^	sequence *prefix;$/;"	m	class:sequence_buffer
prev	.\stl_list.h	/^  void_pointer prev;$/;"	m	struct:__list_node
prev_permutation	.\stl_algo.h	/^bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f
prev_permutation	.\stl_algo.h	/^bool prev_permutation(BidirectionalIterator first,$/;"	f
previous	.\stl_slist.h	/^  const_iterator previous(const_iterator pos) const {$/;"	f	class:slist
previous	.\stl_slist.h	/^  iterator previous(const_iterator pos) {$/;"	f	class:slist
printf	.\iostdio.h	83;"	d
priority_queue	.\stl_queue.h	/^  explicit priority_queue(const Compare& x) :  c(), comp(x) {}$/;"	f	class:priority_queue
priority_queue	.\stl_queue.h	/^  priority_queue() : c() {}$/;"	f	class:priority_queue
priority_queue	.\stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last) $/;"	f	class:priority_queue
priority_queue	.\stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last, const Compare& x)$/;"	f	class:priority_queue
priority_queue	.\stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last) $/;"	f	class:priority_queue
priority_queue	.\stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last, $/;"	f	class:priority_queue
priority_queue	.\stl_queue.h	/^class  priority_queue {$/;"	c
procbuf	.\procbuf.h	/^    procbuf() : filebuf() { }$/;"	f	class:procbuf
procbuf	.\procbuf.h	/^class procbuf : public filebuf {$/;"	c
project1st	.\stl_function.h	/^struct project1st : public binary_function<Arg1, Arg2, Arg1> {$/;"	s
project2nd	.\stl_function.h	/^struct project2nd : public binary_function<Arg1, Arg2, Arg2> {$/;"	s
ptr	.\editbuf.h	/^inline buf_char *edit_mark::ptr(struct edit_buffer *buf)$/;"	f	class:edit_mark
ptr	.\libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	m	struct:_IO_lock_t
ptr	.\stl_function.h	/^    Result (*ptr)(Arg1, Arg2);$/;"	m	class:pointer_to_binary_function
ptr	.\stl_function.h	/^  Result (*ptr)(Arg);$/;"	m	class:pointer_to_unary_function
ptr	.\stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * ptr;$/;"	m	struct:__rope_self_destruct_ptr
ptr_fun	.\stl_function.h	/^inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {$/;"	f
ptr_fun	.\stl_function.h	/^ptr_fun(Result (*x)(Arg1, Arg2)) {$/;"	f
pubseekoff	.\streambuf.h	/^    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)$/;"	f	struct:streambuf
pubseekpos	.\streambuf.h	/^    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)$/;"	f	struct:streambuf
push	.\stl_queue.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:queue
push	.\stl_queue.h	/^  void push(const value_type& x) {$/;"	f	class:priority_queue
push	.\stl_stack.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:stack
push_back	.\stl_bvector.h	/^  void push_back(bool x) {$/;"	f	class:vector
push_back	.\stl_deque.h	/^  void push_back(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_back	.\stl_list.h	/^  void push_back(const T& x) { insert(end(), x); }$/;"	f	class:list
push_back	.\stl_rope.h	/^	void push_back(charT x)$/;"	f	class:rope
push_back	.\stl_rope.h	/^	void push_back(value_type x)$/;"	f	class:sequence_buffer
push_back	.\stl_vector.h	/^  void push_back(const T& x) {$/;"	f	class:vector
push_back_aux	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_front	.\stl_deque.h	/^  void push_front(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_front	.\stl_list.h	/^  void push_front(const T& x) { insert(begin(), x); }$/;"	f	class:list
push_front	.\stl_rope.h	/^	void push_front(charT x)$/;"	f	class:rope
push_front	.\stl_slist.h	/^  void push_front(const value_type& x)   {$/;"	f	class:slist
push_front_aux	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_heap	.\stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
push_heap	.\stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
put	.\iostream.h	/^    ostream& put(char c) { _strbuf->sputc(c); return *this; }$/;"	f	class:ostream
put	.\iostream.h	/^    ostream& put(signed char c) { return put((char)c); }$/;"	f	class:ostream
put	.\iostream.h	/^    ostream& put(unsigned char c) { return put((char)c); }$/;"	f	class:ostream
put	.\stl_rope.h	/^	sequence_buffer& put(value_type x)$/;"	f	class:sequence_buffer
put_mode	.\streambuf.h	/^    int put_mode() { return _flags & _IO_CURRENTLY_PUTTING; }$/;"	f	struct:streambuf
put_node	.\stl_list.h	/^  void put_node(link_type p) { list_node_allocator::deallocate(p); }$/;"	f	class:list
put_node	.\stl_tree.h	/^  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:rb_tree
put_stream	.\indstream.h	/^    streambuf *put_stream()$/;"	f	class:indirectbuf
putback	.\iostream.h	/^    istream& putback(char ch) {$/;"	f	class:istream
putc	.\iostdio.h	60;"	d
puts	.\iostdio.h	84;"	d
queue	.\stl_queue.h	/^class queue {$/;"	c
random_access_iterator	.\stl_iterator.h	/^template <class T, class Distance> struct random_access_iterator {$/;"	s
random_access_iterator_tag	.\stl_iterator.h	/^struct random_access_iterator_tag : public bidirectional_iterator_tag {};$/;"	s
random_sample	.\stl_algo.h	/^random_sample(InputIterator first, InputIterator last,$/;"	f
random_sample_n	.\stl_algo.h	/^OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,$/;"	f
random_shuffle	.\stl_algo.h	/^inline void random_shuffle(RandomAccessIterator first,$/;"	f
random_shuffle	.\stl_algo.h	/^void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
range_initialize	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,$/;"	f	class:__deque_iterator::deque
range_initialize	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,$/;"	f	class:__deque_iterator::deque
range_initialize	.\stl_list.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:list
range_initialize	.\stl_list.h	/^  void range_initialize(const T* first, const T* last) {$/;"	f	class:list
range_initialize	.\stl_list.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:list
range_initialize	.\stl_slist.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:slist
range_initialize	.\stl_slist.h	/^  void range_initialize(const value_type* first, const value_type* last) {$/;"	f	class:slist
range_initialize	.\stl_slist.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:slist
range_initialize	.\stl_vector.h	/^  void range_initialize(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector
range_initialize	.\stl_vector.h	/^  void range_initialize(InputIterator first, InputIterator last,$/;"	f	class:vector
range_insert	.\stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator pos,$/;"	f	class:vector
range_insert	.\stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator position,$/;"	f	class:vector
raw	.\fstream.h	/^    fstreambase& raw() { rdbuf()->setbuf(NULL, 0); return *this; }$/;"	f	class:fstreambase
raw_storage_iterator	.\stl_raw_storage_iter.h	/^  explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}$/;"	f	class:raw_storage_iterator
raw_storage_iterator	.\stl_raw_storage_iter.h	/^class raw_storage_iterator {$/;"	c
rb_tree	.\stl_tree.h	/^  rb_tree(const Compare& comp = Compare())$/;"	f	class:rb_tree
rb_tree	.\stl_tree.h	/^  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) $/;"	f	class:rb_tree
rb_tree	.\stl_tree.h	/^class rb_tree {$/;"	c
rb_tree_node	.\stl_tree.h	/^  typedef __rb_tree_node<Value> rb_tree_node;$/;"	t	class:rb_tree
rb_tree_node_allocator	.\stl_tree.h	/^  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;$/;"	t	class:rb_tree
rbegin	.\std\bastring.h	/^  const_reverse_iterator rbegin() const$/;"	f	class:basic_string
rbegin	.\std\bastring.h	/^  reverse_iterator       rbegin() { return reverse_iterator (end ()); }$/;"	f	class:basic_string
rbegin	.\stl_bvector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector
rbegin	.\stl_bvector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector
rbegin	.\stl_deque.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:__deque_iterator::deque
rbegin	.\stl_deque.h	/^  reverse_iterator rbegin() { return reverse_iterator(finish); }$/;"	f	class:__deque_iterator::deque
rbegin	.\stl_list.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:list
rbegin	.\stl_list.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:list
rbegin	.\stl_map.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:map
rbegin	.\stl_map.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:map
rbegin	.\stl_multimap.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:multimap
rbegin	.\stl_multimap.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:multimap
rbegin	.\stl_multiset.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:multiset
rbegin	.\stl_rope.h	/^	    const_reverse_iterator rbegin() { return const_rbegin(); }$/;"	f	class:rope
rbegin	.\stl_rope.h	/^	    reverse_iterator rbegin() { return mutable_rbegin(); }$/;"	f	class:rope
rbegin	.\stl_rope.h	/^	const_reverse_iterator rbegin() const {$/;"	f	class:rope
rbegin	.\stl_set.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:set
rbegin	.\stl_tree.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:rb_tree
rbegin	.\stl_tree.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:rb_tree
rbegin	.\stl_vector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector
rbegin	.\stl_vector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector
rdbuf	.\fstream.h	/^    filebuf* rdbuf() const { return &__my_fb; }$/;"	f	class:fstreambase
rdbuf	.\fstream.h	/^    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }$/;"	f	class:fstreambase
rdbuf	.\stdiostream.h	/^  stdiobuf* rdbuf() \/* const *\/ { return &_file; }$/;"	f	class:ostdiostream
rdbuf	.\stdiostream.h	/^  stdiobuf* rdbuf()\/* const *\/ { return &_file; }$/;"	f	class:istdiostream
rdbuf	.\streambuf.h	/^    streambuf* rdbuf() const { return _strbuf; }$/;"	f	class:ios
rdbuf	.\streambuf.h	/^    streambuf* rdbuf(streambuf *_s) {$/;"	f	class:ios
rdbuf	.\strstream.h	/^    strstreambuf* rdbuf() { return &__my_sb; }$/;"	f	class:strstreambase
rdios	.\streambuf.h	/^	ios* rdios() const { return _stream; }$/;"	f	class:ios::failure
rdstate	.\streambuf.h	/^    iostate rdstate() const { return _state; }$/;"	f	class:ios
re	.\std\complext.h	/^  _FLT re, im;$/;"	m	class:complex
re	.\std\dcomplex.h	/^  double re, im;$/;"	m	class:complex
re	.\std\fcomplex.h	/^  float re, im;$/;"	m	class:complex
re	.\std\ldcomplex.h	/^  long double re, im;$/;"	m	class:complex
read	.\iostream.h	/^    istream& read(signed char *ptr, streamsize n)$/;"	f	class:istream
read	.\iostream.h	/^    istream& read(unsigned char *ptr, streamsize n)$/;"	f	class:istream
read	.\iostream.h	/^    istream& read(void *ptr, streamsize n)$/;"	f	class:istream
read	.\libio.h	/^  _IO_ssize_t (*read) __P ((struct _IO_FILE *, void *, _IO_ssize_t));$/;"	m	struct:__anon1
read	.\stl_iterator.h	/^  void read() {$/;"	f	class:istream_iterator
read_func	.\parsestream.h	/^    CharReader read_func;$/;"	m	class:func_parsebuf
real	.\std\complext.h	/^  _FLT real () const { return re; }$/;"	f	class:complex
real	.\std\complext.h	/^real (const complex<_FLT>& x)$/;"	f
real	.\std\dcomplex.h	/^  double real () const { return re; }$/;"	f	class:complex
real	.\std\fcomplex.h	/^  float real () const { return re; }$/;"	f	class:complex
real	.\std\ldcomplex.h	/^  long double real () const { return re; }$/;"	f	class:complex
reallocate	.\stl_alloc.h	/^__default_alloc_template<threads, inst>::reallocate(void *p,$/;"	f	class:__default_alloc_template
reallocate	.\stl_alloc.h	/^static void * reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz)$/;"	f	class:__malloc_alloc_template
reallocate	.\stl_alloc.h	/^static void * reallocate(void *p, size_t old_sz, size_t new_sz)$/;"	f	class:debug_alloc
reallocate_map	.\stl_deque.h	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,$/;"	f	class:__deque_iterator::deque
ref	.\std\bastring.h	/^    size_t len, res, ref;$/;"	m	struct:basic_string::Rep
ref	.\stl_rope.h	/^	  static void ref(RopeBase* t) {}$/;"	f	class:rope
ref	.\stl_rope.h	/^	  static void ref(RopeBase* t)$/;"	f	class:rope
ref	.\stl_rope.h	/^	  static void ref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
ref	.\stl_rope.h	/^	  static void ref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
ref_nonnil	.\stl_rope.h	/^	  void ref_nonnil() {}$/;"	f	struct:__rope_RopeBase
ref_nonnil	.\stl_rope.h	/^	  void ref_nonnil()$/;"	f	struct:__rope_RopeBase
refcount	.\stl_rope.h	/^	    long refcount;  	\/\/ InterlockedIncrement wants a long *$/;"	m	struct:__rope_RopeBase
refcount	.\stl_rope.h	/^	    size_t refcount;$/;"	m	struct:__rope_RopeBase
refcount_lock	.\stl_rope.h	/^	    pthread_mutex_t refcount_lock;$/;"	m	struct:__rope_RopeBase
reference	.\defalloc.h	/^    typedef T& reference;$/;"	t	class:allocator
reference	.\std\bastring.h	/^  typedef charT& reference;$/;"	t	class:basic_string
reference	.\stl_bvector.h	/^  typedef __bit_reference  reference;$/;"	t	struct:__bit_iterator
reference	.\stl_bvector.h	/^  typedef __bit_reference reference;$/;"	t	class:vector
reference	.\stl_bvector.h	/^  typedef bool                 reference;$/;"	t	struct:__bit_const_iterator
reference	.\stl_deque.h	/^  typedef Ref reference;$/;"	t	struct:__deque_iterator::__deque_iterator
reference	.\stl_deque.h	/^  typedef value_type& reference;$/;"	t	class:__deque_iterator::deque
reference	.\stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_map
reference	.\stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_multimap
reference	.\stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_multiset
reference	.\stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_set
reference	.\stl_hashtable.h	/^  typedef Value& reference;$/;"	t	struct:__hashtable_iterator
reference	.\stl_hashtable.h	/^  typedef const Value& reference;$/;"	t	struct:__hashtable_const_iterator
reference	.\stl_hashtable.h	/^  typedef value_type&       reference;$/;"	t	class:hashtable
reference	.\stl_iterator.h	/^          reference;$/;"	t	class:reverse_iterator
reference	.\stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_bidirectional_iterator
reference	.\stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_iterator
reference	.\stl_iterator.h	/^  typedef Reference reference;$/;"	t	struct:iterator
reference	.\stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:bidirectional_iterator
reference	.\stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:iterator_traits
reference	.\stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:random_access_iterator
reference	.\stl_iterator.h	/^  typedef T&                   reference;$/;"	t	struct:forward_iterator
reference	.\stl_iterator.h	/^  typedef T&                 reference;$/;"	t	struct:input_iterator
reference	.\stl_iterator.h	/^  typedef const T&                   reference;$/;"	t	struct:iterator_traits
reference	.\stl_iterator.h	/^  typedef const T&           reference;$/;"	t	class:istream_iterator
reference	.\stl_iterator.h	/^  typedef typename Iterator::reference         reference;$/;"	t	struct:iterator_traits
reference	.\stl_iterator.h	/^  typedef void                reference;$/;"	t	class:back_insert_iterator
reference	.\stl_iterator.h	/^  typedef void                reference;$/;"	t	class:front_insert_iterator
reference	.\stl_iterator.h	/^  typedef void                reference;$/;"	t	class:insert_iterator
reference	.\stl_iterator.h	/^  typedef void                reference;$/;"	t	class:ostream_iterator
reference	.\stl_iterator.h	/^  typedef void                reference;$/;"	t	struct:output_iterator
reference	.\stl_list.h	/^  typedef Ref reference;$/;"	t	struct:__list_iterator
reference	.\stl_list.h	/^  typedef value_type& reference;$/;"	t	class:list
reference	.\stl_map.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:map
reference	.\stl_multimap.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:multimap
reference	.\stl_multiset.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:multiset
reference	.\stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:priority_queue
reference	.\stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:queue
reference	.\stl_raw_storage_iter.h	/^  typedef void                reference;$/;"	t	class:raw_storage_iterator
reference	.\stl_rope.h	/^	typedef __rope_charT_ref_proxy<charT,Alloc> reference;$/;"	t	class:rope
reference	.\stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;$/;"	t	class:__rope_iterator
reference	.\stl_rope.h	/^    typedef charT reference;    \/\/ Really a value.  Returning a reference$/;"	t	class:__rope_const_iterator
reference	.\stl_set.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:set
reference	.\stl_slist.h	/^  typedef Ref reference;$/;"	t	struct:__slist_iterator
reference	.\stl_slist.h	/^  typedef value_type& reference;$/;"	t	class:slist
reference	.\stl_stack.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:stack
reference	.\stl_tree.h	/^  typedef Ref reference;$/;"	t	struct:__rb_tree_iterator
reference	.\stl_tree.h	/^  typedef value_type& reference;$/;"	t	class:rb_tree
reference	.\stl_vector.h	/^  typedef value_type& reference;$/;"	t	class:vector
refill	.\stl_alloc.h	/^void* __default_alloc_template<threads, inst>::refill(size_t n)$/;"	f	class:__default_alloc_template
release	.\std\bastring.h	/^    void release () { if (--ref == 0) delete this; }$/;"	f	struct:basic_string::Rep
remove	.\stl_algo.h	/^ForwardIterator remove(ForwardIterator first, ForwardIterator last,$/;"	f
remove	.\stl_list.h	/^void list<T, Alloc>::remove(const T& value) {$/;"	f	class:list
remove	.\stl_slist.h	/^void slist<T,Alloc>::remove(const T& val)$/;"	f	class:slist
remove_copy	.\stl_algo.h	/^OutputIterator remove_copy(InputIterator first, InputIterator last,$/;"	f
remove_copy_if	.\stl_algo.h	/^OutputIterator remove_copy_if(InputIterator first, InputIterator last,$/;"	f
remove_if	.\stl_algo.h	/^ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,$/;"	f
remove_if	.\stl_list.h	/^void list<T, Alloc>::remove_if(Predicate pred) {$/;"	f	class:list
remove_if	.\stl_slist.h	/^template <class Predicate> void slist<T,Alloc>::remove_if(Predicate pred)$/;"	f	class:slist
rend	.\std\bastring.h	/^  const_reverse_iterator rend() const$/;"	f	class:basic_string
rend	.\std\bastring.h	/^  reverse_iterator       rend() { return reverse_iterator (begin ()); }$/;"	f	class:basic_string
rend	.\stl_bvector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector
rend	.\stl_bvector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector
rend	.\stl_deque.h	/^  const_reverse_iterator rend() const {$/;"	f	class:__deque_iterator::deque
rend	.\stl_deque.h	/^  reverse_iterator rend() { return reverse_iterator(start); }$/;"	f	class:__deque_iterator::deque
rend	.\stl_list.h	/^  const_reverse_iterator rend() const { $/;"	f	class:list
rend	.\stl_list.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:list
rend	.\stl_map.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:map
rend	.\stl_map.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:map
rend	.\stl_multimap.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multimap
rend	.\stl_multimap.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:multimap
rend	.\stl_multiset.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multiset
rend	.\stl_rope.h	/^	    const_reverse_iterator rend() { return const_rend(); }$/;"	f	class:rope
rend	.\stl_rope.h	/^	    reverse_iterator rend() { return mutable_rend(); }$/;"	f	class:rope
rend	.\stl_rope.h	/^	const_reverse_iterator rend() const {$/;"	f	class:rope
rend	.\stl_set.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:set
rend	.\stl_tree.h	/^  const_reverse_iterator rend() const { $/;"	f	class:rb_tree
rend	.\stl_tree.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:rb_tree
rend	.\stl_vector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector
rend	.\stl_vector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector
rep	.\std\bastring.h	/^  Rep *rep () const { return reinterpret_cast<Rep *>(dat) - 1; }$/;"	f	class:basic_string
rep	.\stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_map
rep	.\stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_multimap
rep	.\stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_multiset
rep	.\stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_set
rep_type	.\stl_map.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:map
rep_type	.\stl_multimap.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multimap
rep_type	.\stl_multiset.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multiset
rep_type	.\stl_set.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:set
replace	.\std\bastring.cc	/^replace (size_type pos, size_type n1, const charT* s, size_type n2)$/;"	f	class:basic_string
replace	.\std\bastring.cc	/^replace (size_type pos, size_type n1, size_type n2, charT c)$/;"	f	class:basic_string
replace	.\std\bastring.cc	/^replace (size_type pos1, size_type n1,$/;"	f	class:basic_string
replace	.\std\bastring.h	/^  basic_string& replace (iterator i1, iterator i2, const basic_string& str)$/;"	f	class:basic_string
replace	.\std\bastring.h	/^  basic_string& replace (iterator i1, iterator i2, const charT* s)$/;"	f	class:basic_string
replace	.\std\bastring.h	/^  basic_string& replace (iterator i1, iterator i2, const charT* s, size_type n)$/;"	f	class:basic_string
replace	.\std\bastring.h	/^  basic_string& replace (iterator i1, iterator i2, size_type n, charT c)$/;"	f	class:basic_string
replace	.\std\bastring.h	/^  basic_string& replace (size_type pos, size_type n, charT c)$/;"	f	class:basic_string
replace	.\std\bastring.h	/^  basic_string& replace (size_type pos, size_type n1, const charT* s)$/;"	f	class:basic_string
replace	.\std\bastring.h	/^replace (iterator i1, iterator i2, InputIterator j1, InputIterator j2)$/;"	f	class:basic_string
replace	.\stl_algo.h	/^void replace(ForwardIterator first, ForwardIterator last, const T& old_value,$/;"	f
replace	.\stl_rope.h	/^	static RopeBase * replace(RopeBase *old, size_t pos1,$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, charT c)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const charT * c_string)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const iterator& q, charT c)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const rope& r)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, const_iterator i, const_iterator j)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(const iterator& p, iterator i, iterator j)$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, charT c) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, const charT *c_string) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, const charT *i, size_t i_len) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, const const_iterator& i,$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, const iterator& i,$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, const rope& r) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, size_t n, charT c) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, size_t n, const charT *c_string) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, const charT *j) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, size_t i_len) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, size_t n, const rope& r) {$/;"	f	class:rope
replace	.\stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope
replace_copy	.\stl_algo.h	/^OutputIterator replace_copy(InputIterator first, InputIterator last,$/;"	f
replace_copy_if	.\stl_algo.h	/^OutputIterator replace_copy_if(Iterator first, Iterator last,$/;"	f
replace_if	.\stl_algo.h	/^void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,$/;"	f
replace_with_c_str	.\ropeimpl.h	/^const charT * rope<charT,Alloc>::replace_with_c_str() {$/;"	f	class:rope
repup	.\std\bastring.h	/^  void repup (Rep *p) { rep ()->release (); dat = p->data (); }$/;"	f	class:basic_string
requested_size	.\stl_tempbuf.h	/^  ptrdiff_t requested_size() const { return original_len; }$/;"	f	class:temporary_buffer
res	.\std\bastring.h	/^    size_t len, res, ref;$/;"	m	struct:basic_string::Rep
reserve	.\std\bastring.h	/^  void reserve (size_type) { }$/;"	f	class:basic_string
reserve	.\stl_bvector.h	/^  void reserve(size_type n) {$/;"	f	class:vector
reserve	.\stl_rope.h	/^	    void reserve(size_type res_arg = 0) {}$/;"	f	class:rope
reserve	.\stl_vector.h	/^  void reserve(size_type n) {$/;"	f	class:vector
reserve_elements_at_back	.\stl_deque.h	/^  iterator reserve_elements_at_back(size_type n) {$/;"	f	class:__deque_iterator::deque
reserve_elements_at_front	.\stl_deque.h	/^  iterator reserve_elements_at_front(size_type n) {$/;"	f	class:__deque_iterator::deque
reserve_map_at_back	.\stl_deque.h	/^  void reserve_map_at_back (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque
reserve_map_at_front	.\stl_deque.h	/^  void reserve_map_at_front (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque
resize	.\std\bastring.cc	/^resize (size_type n, charT c)$/;"	f	class:basic_string
resize	.\std\bastring.h	/^  void resize (size_type n)$/;"	f	class:basic_string
resize	.\stl_bvector.h	/^  void resize(size_type new_size, bool x = bool()) {$/;"	f	class:vector
resize	.\stl_deque.h	/^  void resize(size_type new_size) { resize(new_size, value_type()); }$/;"	f	class:__deque_iterator::deque
resize	.\stl_deque.h	/^  void resize(size_type new_size, const value_type& x) {$/;"	f	class:__deque_iterator::deque
resize	.\stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_map
resize	.\stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multimap
resize	.\stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multiset
resize	.\stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_set
resize	.\stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)$/;"	f	class:hashtable
resize	.\stl_list.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:list
resize	.\stl_list.h	/^void list<T, Alloc>::resize(size_type new_size, const T& x)$/;"	f	class:list
resize	.\stl_rope.h	/^	    void resize(size_type n) {}$/;"	f	class:rope
resize	.\stl_rope.h	/^	    void resize(size_type n, charT c) {}$/;"	f	class:rope
resize	.\stl_slist.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:slist
resize	.\stl_slist.h	/^void slist<T, Alloc>::resize(size_type len, const T& x)$/;"	f	class:slist
resize	.\stl_vector.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:vector
resize	.\stl_vector.h	/^  void resize(size_type new_size, const T& x) {$/;"	f	class:vector
result_type	.\stl_function.h	/^    typedef Result result_type;$/;"	t	struct:binary_function
result_type	.\stl_function.h	/^    typedef Result result_type;$/;"	t	struct:unary_function
result_type	.\stl_function.h	/^  typedef Result result_type;$/;"	t	struct:constant_void_fun
return_temporary_buffer	.\stl_tempbuf.h	/^void return_temporary_buffer(T* p) {$/;"	f
reverse	.\stl_algo.h	/^inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {$/;"	f
reverse	.\stl_list.h	/^void list<T, Alloc>::reverse() {$/;"	f	class:list
reverse	.\stl_slist.h	/^  void reverse() { if (head.next) head.next = __slist_reverse(head.next); }$/;"	f	class:slist
reverse_bidirectional_iterator	.\stl_iterator.h	/^  explicit reverse_bidirectional_iterator(BidirectionalIterator x)$/;"	f	class:reverse_bidirectional_iterator
reverse_bidirectional_iterator	.\stl_iterator.h	/^  reverse_bidirectional_iterator() {}$/;"	f	class:reverse_bidirectional_iterator
reverse_bidirectional_iterator	.\stl_iterator.h	/^class reverse_bidirectional_iterator {$/;"	c
reverse_copy	.\stl_algo.h	/^OutputIterator reverse_copy(BidirectionalIterator first,$/;"	f
reverse_iterator	.\std\bastring.h	/^  typedef ::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:basic_string
reverse_iterator	.\stl_bvector.h	/^          reverse_iterator;$/;"	t	class:vector
reverse_iterator	.\stl_bvector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector
reverse_iterator	.\stl_deque.h	/^          reverse_iterator; $/;"	t	class:__deque_iterator::deque
reverse_iterator	.\stl_deque.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:__deque_iterator::deque
reverse_iterator	.\stl_iterator.h	/^  explicit reverse_iterator(RandomAccessIterator x) : current(x) {}$/;"	f	class:reverse_iterator
reverse_iterator	.\stl_iterator.h	/^  explicit reverse_iterator(iterator_type x) : current(x) {}$/;"	f	class:reverse_iterator
reverse_iterator	.\stl_iterator.h	/^  reverse_iterator() {}$/;"	f	class:reverse_iterator
reverse_iterator	.\stl_iterator.h	/^  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}$/;"	f	class:reverse_iterator
reverse_iterator	.\stl_iterator.h	/^  reverse_iterator(const self& x) : current(x.current) {}$/;"	f	class:reverse_iterator
reverse_iterator	.\stl_iterator.h	/^class reverse_iterator $/;"	c
reverse_iterator	.\stl_iterator.h	/^class reverse_iterator {$/;"	c
reverse_iterator	.\stl_list.h	/^  reverse_iterator; $/;"	t	class:list
reverse_iterator	.\stl_list.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:list
reverse_iterator	.\stl_map.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:map
reverse_iterator	.\stl_multimap.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:multimap
reverse_iterator	.\stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:multiset
reverse_iterator	.\stl_rope.h	/^				 difference_type>  reverse_iterator;$/;"	t	class:rope
reverse_iterator	.\stl_rope.h	/^        typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rope
reverse_iterator	.\stl_set.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:set
reverse_iterator	.\stl_tree.h	/^          reverse_iterator; $/;"	t	class:rb_tree
reverse_iterator	.\stl_tree.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rb_tree
reverse_iterator	.\stl_vector.h	/^          reverse_iterator;$/;"	t	class:vector
reverse_iterator	.\stl_vector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector
rewind	.\iostdio.h	85;"	d
rfind	.\std\bastring.cc	/^rfind (charT c, size_type pos) const$/;"	f	class:basic_string
rfind	.\std\bastring.cc	/^rfind (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
rfind	.\std\bastring.h	/^  size_type rfind (const basic_string& str, size_type pos = npos) const$/;"	f	class:basic_string
rfind	.\std\bastring.h	/^  size_type rfind (const charT* s, size_type pos = npos) const$/;"	f	class:basic_string
right	.\parsestream.h	/^    char *right() const { return ebuf(); }$/;"	f	class:string_parsebuf
right	.\stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* right;$/;"	m	struct:__rope_RopeConcatenation
right	.\stl_tree.h	/^  base_ptr right;$/;"	m	struct:__rb_tree_node_base
right	.\stl_tree.h	/^  static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree
right	.\stl_tree.h	/^  static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree
right	.\streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon15
rightmost	.\stl_tree.h	/^  link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:rb_tree
root	.\stl_rope.h	/^    RopeBase * root;     \/\/ The whole rope.$/;"	m	class:__rope_iterator_base
root	.\stl_rope.h	/^    my_rope * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ref_proxy
root	.\stl_rope.h	/^    rope<charT,Alloc> * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ptr_proxy
root	.\stl_tree.h	/^  link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:rb_tree
root_rope	.\stl_rope.h	/^    rope<charT,Alloc> * root_rope;$/;"	m	class:__rope_iterator
rope	.\ropeimpl.h	/^rope<charT, Alloc>::rope(size_t n, charT c)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope()$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(RopeBase *t) : tree_ptr(t) { }$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(charT c)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(char_producer<charT> *fn, size_t len, bool delete_fn)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const charT *i, const charT *j)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const charT *s)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const charT *s, charT *e)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const charT *s, size_t len)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const const_iterator& s, const const_iterator& e)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const iterator& s, const iterator& e)$/;"	f	class:rope
rope	.\stl_rope.h	/^	rope(const rope &x)$/;"	f	class:rope
rope	.\stl_rope.h	/^class rope {$/;"	c
rotate	.\ropeimpl.h	/^inline void rotate(__rope_iterator<char,__ALLOC> first,$/;"	f
rotate	.\stl_algo.h	/^inline void rotate(ForwardIterator first, ForwardIterator middle,$/;"	f
rotate_copy	.\stl_algo.h	/^OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,$/;"	f
rounded_up_size	.\stl_rope.h	/^	static size_t rounded_up_size(size_t n) {$/;"	f	class:rope
rounded_up_size	.\stl_rope.h	/^    static size_t rounded_up_size(size_t n) {$/;"	f	struct:__rope_RopeBase
sapp	.\iomanip.h	/^template<class TP> class sapp {$/;"	c
saving	.\streambuf.h	/^    int saving() { return  1; }$/;"	f	class:streammarker
sbuf	.\parsestream.h	/^    streambuf *sbuf;$/;"	m	class:general_parsebuf
sbumpc	.\streambuf.h	/^    int sbumpc() { return _IO_getc(this); }$/;"	f	struct:streambuf
scanf	.\iostdio.h	86;"	d
scientific	.\streambuf.h	/^	   scientific=_IO_SCIENTIFIC, fixed=_IO_FIXED,$/;"	e	enum:ios::__anon15
search	.\stl_algo.h	/^inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
search_n	.\stl_algo.h	/^ForwardIterator search_n(ForwardIterator first, ForwardIterator last,$/;"	f
second	.\stl_pair.h	/^  T2 second;$/;"	m	struct:pair
second_argument_type	.\stl_function.h	/^    typedef Arg2 second_argument_type;$/;"	t	struct:binary_function
second_type	.\stl_pair.h	/^  typedef T2 second_type;$/;"	t	struct:pair
seek	.\libio.h	/^  _IO_fpos_t (*seek) __P ((struct _IO_FILE *, _IO_off_t, int));$/;"	m	struct:__anon1
seek_dir	.\streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	g	class:ios
seekdir	.\streambuf.h	/^    typedef enum seek_dir seekdir;$/;"	t	class:ios	typeref:enum:ios::seek_dir
select1st	.\stl_function.h	/^struct select1st : public unary_function<Pair, typename Pair::first_type> {$/;"	s
select2nd	.\stl_function.h	/^struct select2nd : public unary_function<Pair, typename Pair::second_type> {$/;"	s
self	.\stl_deque.h	/^  typedef __deque_iterator self;$/;"	t	struct:__deque_iterator::__deque_iterator
self	.\stl_iterator.h	/^                                         Distance> self;$/;"	t	class:reverse_bidirectional_iterator
self	.\stl_iterator.h	/^        self;$/;"	t	class:reverse_iterator
self	.\stl_iterator.h	/^  typedef reverse_iterator<Iterator> self;$/;"	t	class:reverse_iterator
self	.\stl_list.h	/^  typedef __list_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__list_iterator
self	.\stl_slist.h	/^  typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__slist_iterator
self	.\stl_tree.h	/^  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;$/;"	t	struct:__rb_tree_iterator
self_destruct_ptr	.\stl_rope.h	/^	    typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:rope
self_destruct_ptr	.\stl_rope.h	/^	    typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:rope
self_destruct_ptr	.\stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy
self_destruct_ptr	.\stl_rope.h	/^    	typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy
selfish	.\std\bastring.h	/^    bool selfish;$/;"	m	struct:basic_string::Rep
selfish	.\std\bastring.h	/^  void selfish () { unique (); rep ()->selfish = true; }$/;"	f	class:basic_string
sequence_buffer	.\stl_rope.h	/^	sequence_buffer() : prefix(0), buf_count(0) {}$/;"	f	class:sequence_buffer
sequence_buffer	.\stl_rope.h	/^	sequence_buffer(const sequence_buffer & x) {$/;"	f	class:sequence_buffer
sequence_buffer	.\stl_rope.h	/^	sequence_buffer(sequence& s) : prefix(&s), buf_count(0) {}$/;"	f	class:sequence_buffer
sequence_buffer	.\stl_rope.h	/^	sequence_buffer(sequence_buffer & x) {$/;"	f	class:sequence_buffer
sequence_buffer	.\stl_rope.h	/^class sequence_buffer : public output_iterator {$/;"	c
set	.\std\bastring.cc	/^set (size_t pos, const charT c, size_t n)$/;"	f	class:basic_string::Rep
set	.\std\straits.h	/^  static char_type* set (char_type* s1, const char_type& c, size_t n)$/;"	f	struct:string_char_traits
set	.\stl_set.h	/^  explicit set(const Compare& comp) : t(comp) {}$/;"	f	class:set
set	.\stl_set.h	/^  set() : t(Compare()) {}$/;"	f	class:set
set	.\stl_set.h	/^  set(InputIterator first, InputIterator last)$/;"	f	class:set
set	.\stl_set.h	/^  set(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:set
set	.\stl_set.h	/^  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:set
set	.\stl_set.h	/^  set(const value_type* first, const value_type* last) $/;"	f	class:set
set	.\stl_set.h	/^  set(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:set
set	.\stl_set.h	/^  set(const_iterator first, const_iterator last)$/;"	f	class:set
set	.\stl_set.h	/^  set(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:set
set	.\stl_set.h	/^class set {$/;"	c
set	.\streambuf.h	/^    void set(iostate flag) { _state |= flag;$/;"	f	class:ios
set_difference	.\stl_algo.h	/^OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,$/;"	f
set_intersection	.\stl_algo.h	/^OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,$/;"	f
set_malloc_handler	.\stl_alloc.h	/^static void (* set_malloc_handler(void (*f)()))()$/;"	f	class:__malloc_alloc_template
set_node	.\stl_deque.h	/^  void set_node(map_pointer new_node) {$/;"	f	struct:__deque_iterator::__deque_iterator
set_offset	.\streambuf.h	/^    void set_offset(int offset) { _pos = offset; }$/;"	f	class:streammarker
set_symmetric_difference	.\stl_algo.h	/^OutputIterator set_symmetric_difference(InputIterator1 first1,$/;"	f
set_union	.\stl_algo.h	/^OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,$/;"	f
setbuf	.\fstream.h	/^    void setbuf(char *ptr, int len) { rdbuf()->setbuf(ptr, len); }$/;"	f	class:fstreambase
setbuf	.\iostdio.h	110;"	d
setbuf	.\iostdio.h	87;"	d
setbuf	.\ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setbuf$/;"	f	class:__rope_iterator_base
setbuffer	.\iostdio.h	88;"	d
setcache	.\ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache$/;"	f	class:__rope_iterator_base
setcache_for_incr	.\ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache_for_incr$/;"	f	class:__rope_iterator_base
setf	.\streambuf.h	/^    fmtflags setf(fmtflags val) {$/;"	f	class:ios
setf	.\streambuf.h	/^    fmtflags setf(fmtflags val, fmtflags mask) {$/;"	f	class:ios
setg	.\streambuf.h	/^    void setg(char* eb, char* g, char *eg) {$/;"	f	struct:streambuf
setlinebuf	.\iostdio.h	111;"	d
setp	.\streambuf.h	/^    void setp(char* p, char* ep)$/;"	f	struct:streambuf
setsize	.\SFile.h	/^    int       setsize(int s) { int old = sz; sz = s; return old; }$/;"	f	class:SFile
setstate	.\streambuf.h	/^    void setstate(iostate flag) { _state |= flag; \/\/ ANSI$/;"	f	class:ios
setvbuf	.\iostdio.h	89;"	d
sgetc	.\streambuf.h	/^    int sgetc() { return _IO_peekc(this); }$/;"	f	struct:streambuf
sgetn	.\streambuf.h	/^    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }$/;"	f	struct:streambuf
shortbuf	.\streambuf.h	/^    char *shortbuf() { return _shortbuf; }$/;"	f	struct:streambuf
showbase	.\streambuf.h	/^	   showbase=_IO_SHOWBASE, showpoint=_IO_SHOWPOINT,$/;"	e	enum:ios::__anon15
showpoint	.\streambuf.h	/^	   showbase=_IO_SHOWBASE, showpoint=_IO_SHOWPOINT,$/;"	e	enum:ios::__anon15
showpos	.\streambuf.h	/^	   uppercase=_IO_UPPERCASE, showpos=_IO_SHOWPOS,$/;"	e	enum:ios::__anon15
simple_alloc	.\stl_alloc.h	/^class simple_alloc {$/;"	c
sin	.\std\complext.cc	/^sin (const complex<FLOAT>& x)$/;"	f
single_client_alloc	.\stl_alloc.h	/^typedef __default_alloc_template<false, 0> single_client_alloc;$/;"	t
single_client_alloc	.\stl_alloc.h	/^typedef malloc_alloc single_client_alloc;$/;"	t
sinh	.\std\complext.cc	/^sinh (const complex<FLOAT>& x)$/;"	f
size	.\SFile.h	/^    int       size() { return sz; }$/;"	f	class:SFile
size	.\std\bastring.h	/^  size_type size () const$/;"	f	class:basic_string
size	.\stl_bvector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector
size	.\stl_deque.h	/^  size_type size() const { return finish - start;; }$/;"	f	class:__deque_iterator::deque
size	.\stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_map
size	.\stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multimap
size	.\stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multiset
size	.\stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_set
size	.\stl_hashtable.h	/^  size_type size() const { return num_elements; }$/;"	f	class:hashtable
size	.\stl_list.h	/^  size_type size() const {$/;"	f	class:list
size	.\stl_map.h	/^  size_type size() const { return t.size(); }$/;"	f	class:map
size	.\stl_multimap.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multimap
size	.\stl_multiset.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multiset
size	.\stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:priority_queue
size	.\stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:queue
size	.\stl_rope.h	/^	size_type size() const { $/;"	f	class:rope
size	.\stl_rope.h	/^    size_t size;$/;"	m	struct:__rope_RopeBase
size	.\stl_set.h	/^  size_type size() const { return t.size(); }$/;"	f	class:set
size	.\stl_slist.h	/^  size_type size() const { return __slist_size(head.next); }$/;"	f	class:slist
size	.\stl_stack.h	/^  size_type size() const { return c.size(); }$/;"	f	class:stack
size	.\stl_tempbuf.h	/^  ptrdiff_t size() const { return len; }$/;"	f	class:temporary_buffer
size	.\stl_tree.h	/^  size_type size() const { return node_count; }$/;"	f	class:rb_tree
size	.\stl_vector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector
size1	.\editbuf.h	/^    inline int size1() { return gap_start() - data; }$/;"	f	struct:edit_buffer
size2	.\editbuf.h	/^    inline int size2() { return buf_size - gap_end_pos(); }$/;"	f	struct:edit_buffer
size_type	.\defalloc.h	/^    typedef size_t size_type;$/;"	t	class:allocator
size_type	.\std\bastring.h	/^  typedef size_t size_type;$/;"	t	class:basic_string
size_type	.\stl_bvector.h	/^  typedef size_t size_type;$/;"	t	class:vector
size_type	.\stl_deque.h	/^  typedef size_t size_type;$/;"	t	class:__deque_iterator::deque
size_type	.\stl_deque.h	/^  typedef size_t size_type;$/;"	t	struct:__deque_iterator::__deque_iterator
size_type	.\stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_map
size_type	.\stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multimap
size_type	.\stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multiset
size_type	.\stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_set
size_type	.\stl_hashtable.h	/^  typedef size_t            size_type;$/;"	t	class:hashtable
size_type	.\stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_const_iterator
size_type	.\stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_iterator
size_type	.\stl_list.h	/^  typedef size_t size_type;$/;"	t	class:list
size_type	.\stl_list.h	/^  typedef size_t size_type;$/;"	t	struct:__list_iterator
size_type	.\stl_map.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:map
size_type	.\stl_multimap.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multimap
size_type	.\stl_multiset.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multiset
size_type	.\stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:priority_queue
size_type	.\stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:queue
size_type	.\stl_rope.h	/^	typedef size_t size_type;$/;"	t	class:rope
size_type	.\stl_set.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:set
size_type	.\stl_slist.h	/^  typedef size_t size_type;$/;"	t	class:slist
size_type	.\stl_slist.h	/^  typedef size_t size_type;$/;"	t	struct:__slist_iterator_base
size_type	.\stl_stack.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:stack
size_type	.\stl_tree.h	/^  typedef size_t size_type;$/;"	t	class:rb_tree
size_type	.\stl_vector.h	/^  typedef size_t size_type;$/;"	t	class:vector
skipws	.\streambuf.h	/^    enum { skipws=_IO_SKIPWS,$/;"	e	enum:ios::__anon15
slist	.\stl_slist.h	/^  explicit slist(size_type n) { fill_initialize(n, value_type()); }$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist() { head.next = 0; }$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(InputIterator first, InputIterator last) {$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(const slist& L) { range_initialize(L.begin(), L.end()); }$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(const value_type* first, const value_type* last) {$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(const_iterator first, const_iterator last) {$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(int n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(long n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist
slist	.\stl_slist.h	/^  slist(size_type n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist
slist	.\stl_slist.h	/^class slist$/;"	c
smanip	.\iomanip.h	/^template <class TP> class smanip {$/;"	c
snextc	.\streambuf.h	/^    int snextc() {$/;"	f	struct:streambuf
sort	.\stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
sort	.\stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
sort	.\stl_list.h	/^void list<T, Alloc>::sort() {$/;"	f	class:list
sort	.\stl_list.h	/^void list<T, Alloc>::sort(StrictWeakOrdering comp) {$/;"	f	class:list
sort	.\stl_slist.h	/^void slist<T,Alloc>::sort()$/;"	f	class:slist
sort	.\stl_slist.h	/^void slist<T,Alloc>::sort(StrictWeakOrdering comp)$/;"	f	class:slist
sort_heap	.\stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
sort_heap	.\stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
splice	.\stl_list.h	/^  void splice(iterator position, list& x) {$/;"	f	class:list
splice	.\stl_list.h	/^  void splice(iterator position, list&, iterator first, iterator last) {$/;"	f	class:list
splice	.\stl_list.h	/^  void splice(iterator position, list&, iterator i) {$/;"	f	class:list
splice	.\stl_slist.h	/^  void splice(iterator pos, slist& L) {$/;"	f	class:slist
splice	.\stl_slist.h	/^  void splice(iterator pos, slist& L, iterator first, iterator last)$/;"	f	class:slist
splice	.\stl_slist.h	/^  void splice(iterator pos, slist& L, iterator i) {$/;"	f	class:slist
splice_after	.\stl_slist.h	/^  void splice_after(iterator pos, $/;"	f	class:slist
splice_after	.\stl_slist.h	/^  void splice_after(iterator pos, iterator prev)$/;"	f	class:slist
sprintf	.\iostdio.h	90;"	d
sputc	.\streambuf.h	/^    int sputc(int c) { return _IO_putc(c, this); }$/;"	f	struct:streambuf
sputn	.\streambuf.h	/^    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }$/;"	f	struct:streambuf
sqrt	.\std\complext.cc	/^sqrt (const complex<FLOAT>& x)$/;"	f
sscanf	.\iostdio.h	91;"	d
stable_partition	.\stl_algo.h	/^inline ForwardIterator stable_partition(ForwardIterator first,$/;"	f
stable_sort	.\stl_algo.h	/^inline void stable_sort(RandomAccessIterator first,$/;"	f
stack	.\stl_stack.h	/^class stack {$/;"	c
start	.\editbuf.h	/^    struct edit_mark *start, *end;$/;"	m	struct:edit_string	typeref:struct:edit_string::edit_mark
start	.\stl_bvector.h	/^  iterator start;$/;"	m	class:vector
start	.\stl_deque.h	/^  iterator start;$/;"	m	class:__deque_iterator::deque
start	.\stl_rope.h	/^    size_t start;$/;"	m	struct:__rope_RopeSubstring
start	.\stl_vector.h	/^  iterator start;$/;"	m	class:vector
start_free	.\stl_alloc.h	/^  static char *start_free;$/;"	m	class:__default_alloc_template
start_free	.\stl_alloc.h	/^char *__default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:__default_alloc_template
start_mark	.\editbuf.h	/^    struct edit_mark start_mark;$/;"	m	struct:edit_buffer	typeref:struct:edit_buffer::edit_mark
start_marker	.\editbuf.h	/^    inline struct edit_mark *start_marker() { return &start_mark; }$/;"	f	struct:edit_buffer
state_value	.\streambuf.h	/^enum state_value {$/;"	g
stderr	.\iostdio.h	57;"	d
stdin	.\iostdio.h	55;"	d
stdio	.\streambuf.h	/^	   unitbuf=_IO_UNITBUF, stdio=_IO_STDIO$/;"	e	enum:ios::__anon15
stdiobuf	.\stdiostream.h	/^class stdiobuf : public filebuf {$/;"	c
stdiofile	.\stdiostream.h	/^    FILE* stdiofile() const { return _file; }$/;"	f	class:stdiobuf
stdout	.\iostdio.h	56;"	d
stossc	.\streambuf.h	/^    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }$/;"	f	struct:streambuf
str	.\editbuf.h	/^    edit_string *str;$/;"	m	struct:edit_streambuf
str	.\strstream.h	/^    char *str() { return ((strstreambuf*)_strbuf)->str(); }$/;"	f	class:ostrstream
str	.\strstream.h	/^    char *str() { return ((strstreambuf*)_strbuf)->str(); }$/;"	f	class:strstream
stream	.\stl_iterator.h	/^  istream* stream;$/;"	m	class:istream_iterator
stream	.\stl_iterator.h	/^  ostream* stream;$/;"	m	class:ostream_iterator
streambuf	.\streambuf.h	/^struct streambuf : public _IO_FILE { \/\/ protected??$/;"	s
streammarker	.\streambuf.h	/^class streammarker : private _IO_marker {$/;"	c
streamoff	.\streambuf.h	/^typedef _IO_off64_t streamoff;$/;"	t
streamoff	.\streambuf.h	/^typedef _IO_off_t streamoff;$/;"	t
streampos	.\streambuf.h	/^typedef _IO_fpos64_t streampos;$/;"	t
streampos	.\streambuf.h	/^typedef _IO_fpos_t streampos;$/;"	t
streamsize	.\streambuf.h	/^    typedef int streamsize;$/;"	t	class:ios
streamsize	.\streambuf.h	/^typedef _IO_ssize_t streamsize;$/;"	t
string	.\stl_iterator.h	/^  const char* string;$/;"	m	class:ostream_iterator
string_char_traits	.\std\straits.h	/^struct string_char_traits <char> {$/;"	s
string_char_traits	.\std\straits.h	/^struct string_char_traits {$/;"	s
string_parsebuf	.\parsestream.h	/^class string_parsebuf : public parsebuf {$/;"	c
strstream	.\strstream.h	/^    strstream(char *cp, int n, int mode=ios::out) :strstreambase(cp,n,mode){}$/;"	f	class:strstream
strstream	.\strstream.h	/^  strstream() { }$/;"	f	class:strstream
strstream	.\strstream.h	/^class strstream : public strstreambase, public iostream {$/;"	c
strstreambase	.\strstream.h	/^    strstreambase() { init (&__my_sb); }$/;"	f	class:strstreambase
strstreambase	.\strstream.h	/^class strstreambase : virtual public ios {$/;"	c
strstreambuf	.\strstream.h	/^    strstreambuf() { init_dynamic(0, 0); }$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(char *ptr, int size, char *pstart = NULL)$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(const char *ptr, int size)$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(const signed char *ptr, int size)$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(const unsigned char *ptr, int size)$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(int initial_size) { init_dynamic(0, 0, initial_size); }$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(signed char *ptr, int size, signed char *pstart = NULL)$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(unsigned char *ptr, int size, unsigned char *pstart = NULL)$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^    strstreambuf(void *(*alloc)(_IO_size_t), void (*free)(void*))$/;"	f	class:strstreambuf
strstreambuf	.\strstream.h	/^class strstreambuf : public streambuf$/;"	c
substr	.\std\bastring.h	/^  basic_string substr (size_type pos = 0, size_type n = npos) const$/;"	f	class:basic_string
substr	.\stl_rope.h	/^	rope substr(const_iterator start, const_iterator end) const {$/;"	f	class:rope
substr	.\stl_rope.h	/^	rope substr(iterator start) const {$/;"	f	class:rope
substr	.\stl_rope.h	/^	rope substr(iterator start, iterator end) const {$/;"	f	class:rope
substr	.\stl_rope.h	/^	rope substr(size_t start, size_t len = 1) const {$/;"	f	class:rope
substr	.\stl_rope.h	/^	rope<charT,Alloc> substr(const_iterator start) {$/;"	f	class:rope
substring	.\ropeimpl.h	/^rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)$/;"	f	class:rope
substringfn	.\stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon10
subtractive_rng	.\stl_function.h	/^  subtractive_rng() { initialize(161803398u); }$/;"	f	class:subtractive_rng
subtractive_rng	.\stl_function.h	/^  subtractive_rng(unsigned int seed) { initialize(seed); }$/;"	f	class:subtractive_rng
subtractive_rng	.\stl_function.h	/^class subtractive_rng : public unary_function<unsigned int, unsigned int> {$/;"	c
swap	.\std\bastring.h	/^  void swap (basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }$/;"	f	class:basic_string
swap	.\stl_algobase.h	/^inline void swap(T& a, T& b) {$/;"	f
swap	.\stl_bvector.h	/^  void swap(__BVECTOR& x) {$/;"	f	class:vector
swap	.\stl_bvector.h	/^inline void swap(__bit_reference x, __bit_reference y) {$/;"	f
swap	.\stl_deque.h	/^  void swap(deque& x) {$/;"	f	class:__deque_iterator::deque
swap	.\stl_deque.h	/^inline void swap(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y) {$/;"	f	struct:__deque_iterator
swap	.\stl_hash_map.h	/^  void swap(hash_map& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_map
swap	.\stl_hash_map.h	/^  void swap(hash_multimap& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multimap
swap	.\stl_hash_map.h	/^inline void swap(hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
swap	.\stl_hash_map.h	/^inline void swap(hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
swap	.\stl_hash_set.h	/^  void swap(hash_multiset& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multiset
swap	.\stl_hash_set.h	/^  void swap(hash_set& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_set
swap	.\stl_hash_set.h	/^inline void swap(hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
swap	.\stl_hash_set.h	/^inline void swap(hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
swap	.\stl_hashtable.h	/^  void swap(hashtable& ht)$/;"	f	class:hashtable
swap	.\stl_hashtable.h	/^inline void swap(hashtable<Val, Key, HF, Extract, EqKey, A>& ht1,$/;"	f
swap	.\stl_list.h	/^  void swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }$/;"	f	class:list
swap	.\stl_list.h	/^inline void swap(list<T, Alloc>& x, list<T, Alloc>& y) {$/;"	f
swap	.\stl_map.h	/^  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:map
swap	.\stl_map.h	/^inline void swap(map<Key, T, Compare, Alloc>& x, $/;"	f
swap	.\stl_multimap.h	/^  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multimap
swap	.\stl_multimap.h	/^inline void swap(multimap<Key, T, Compare, Alloc>& x, $/;"	f
swap	.\stl_multiset.h	/^  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multiset
swap	.\stl_multiset.h	/^inline void swap(multiset<Key, Compare, Alloc>& x, $/;"	f
swap	.\stl_rope.h	/^	void swap(rope& b) {$/;"	f	class:rope
swap	.\stl_rope.h	/^inline void swap(crope x, crope y) { x.swap(y); }$/;"	f
swap	.\stl_rope.h	/^inline void swap(rope<charT, Alloc>& x, rope<charT, Alloc>& y) {$/;"	f
swap	.\stl_rope.h	/^inline void swap(wrope x, wrope y) { x.swap(y); }$/;"	f
swap	.\stl_set.h	/^  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:set
swap	.\stl_set.h	/^inline void swap(set<Key, Compare, Alloc>& x, $/;"	f
swap	.\stl_slist.h	/^  void swap(slist& L)$/;"	f	class:slist
swap	.\stl_slist.h	/^inline void swap(slist<T, Alloc>& x, slist<T, Alloc>& y) {$/;"	f
swap	.\stl_tree.h	/^  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {$/;"	f	class:rb_tree
swap	.\stl_tree.h	/^inline void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
swap	.\stl_vector.h	/^  void swap(vector<T, Alloc>& x) {$/;"	f	class:vector
swap	.\stl_vector.h	/^inline void swap(vector<T, Alloc>& x, vector<T, Alloc>& y) {$/;"	f
swap_lock	.\ropeimpl.h	/^    pthread_mutex_t rope<charT,Alloc>::swap_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:rope
swap_lock	.\stl_rope.h	/^	    static pthread_mutex_t swap_lock;$/;"	m	class:rope
swap_ranges	.\stl_algo.h	/^ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
sync_with_stdio	.\streambuf.h	/^    static void sync_with_stdio() { sync_with_stdio(1); }$/;"	f	class:ios
sz	.\SFile.h	/^    int       sz;                   \/\/ unit size for structured binary IO$/;"	m	class:SFile
t	.\stl_map.h	/^  rep_type t;  \/\/ red-black tree representing map$/;"	m	class:map
t	.\stl_multimap.h	/^  rep_type t;  \/\/ red-black tree representing multimap$/;"	m	class:multimap
t	.\stl_multiset.h	/^  rep_type t;  \/\/ red-black tree representing multiset$/;"	m	class:multiset
t	.\stl_set.h	/^  rep_type t;  \/\/ red-black tree representing set$/;"	m	class:set
table	.\stl_function.h	/^  unsigned int table[55];$/;"	m	class:subtractive_rng
tag	.\stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	m	struct:__rope_RopeBase	typeref:enum:__rope_RopeBase::__anon10
temporary_buffer	.\stl_tempbuf.h	/^  temporary_buffer(ForwardIterator first, ForwardIterator last) {$/;"	f	class:temporary_buffer
temporary_buffer	.\stl_tempbuf.h	/^  temporary_buffer(const temporary_buffer&) {}$/;"	f	class:temporary_buffer
temporary_buffer	.\stl_tempbuf.h	/^class temporary_buffer {$/;"	c
terminate	.\std\bastring.h	/^  void terminate () const$/;"	f	class:basic_string
this_dummy_member_must_be_first	.\type_traits.h	/^   typedef __true_type     this_dummy_member_must_be_first;$/;"	t	struct:__type_traits
tie	.\streambuf.h	/^    ostream* tie() const { return _tie; }$/;"	f	class:ios
tie	.\streambuf.h	/^    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }$/;"	f	class:ios
tmp_buf	.\stl_rope.h	/^    charT tmp_buf[iterator_buf_len];$/;"	m	class:__rope_iterator_base
top	.\stl_queue.h	/^  const_reference top() const { return c.front(); }$/;"	f	class:priority_queue
top	.\stl_stack.h	/^  const_reference top() const { return c.back(); }$/;"	f	class:stack
top	.\stl_stack.h	/^  reference top() { return c.back(); }$/;"	f	class:stack
traits_type	.\std\bastring.h	/^  typedef	   traits		traits_type;$/;"	t	class:basic_string
transfer	.\stl_list.h	/^  void transfer(iterator position, iterator first, iterator last) {$/;"	f	class:list
transform	.\stl_algo.h	/^OutputIterator transform(InputIterator first, InputIterator last,$/;"	f
transform	.\stl_algo.h	/^OutputIterator transform(InputIterator1 first1, InputIterator1 last1,$/;"	f
tree_concat	.\ropeimpl.h	/^rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)$/;"	f	class:rope
tree_ptr	.\stl_rope.h	/^	RopeBase *tree_ptr;$/;"	m	class:rope
true	.\stl_config.h	179;"	d
trunc	.\streambuf.h	/^	trunc = _IO_TRUNC,$/;"	e	enum:ios::open_mode
typename	.\stl_config.h	184;"	d
unary_compose	.\stl_function.h	/^  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}$/;"	f	class:unary_compose
unary_compose	.\stl_function.h	/^class unary_compose : public unary_function<typename Operation2::argument_type,$/;"	c
unary_function	.\stl_function.h	/^struct unary_function {$/;"	s
unary_negate	.\stl_function.h	/^  explicit unary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:unary_negate
unary_negate	.\stl_function.h	/^class unary_negate$/;"	c
unbuffered	.\streambuf.h	/^    int unbuffered() { return _flags & _IO_UNBUFFERED ? 1 : 0; }$/;"	f	struct:streambuf
unbuffered	.\streambuf.h	/^    void unbuffered(int i)$/;"	f	struct:streambuf
unget	.\iostream.h	/^    istream& unget() {$/;"	f	class:istream
unget	.\iostream.h	/^    istream& unget(char ch) { return putback(ch); }$/;"	f	class:istream
ungetc	.\iostdio.h	92;"	d
uninitialized_copy	.\stl_uninitialized.h	/^  uninitialized_copy(InputIterator first, InputIterator last,$/;"	f
uninitialized_copy	.\stl_uninitialized.h	/^inline char* uninitialized_copy(const char* first, const char* last,$/;"	f
uninitialized_copy	.\stl_uninitialized.h	/^inline wchar_t* uninitialized_copy(const wchar_t* first, const wchar_t* last,$/;"	f
uninitialized_copy_n	.\stl_uninitialized.h	/^uninitialized_copy_n(InputIterator first, Size count,$/;"	f
uninitialized_fill	.\stl_uninitialized.h	/^inline void uninitialized_fill(ForwardIterator first, ForwardIterator last, $/;"	f
uninitialized_fill_n	.\stl_uninitialized.h	/^inline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,$/;"	f
unique	.\std\bastring.h	/^  void unique () { if (rep ()->ref > 1) alloc (length (), true); }$/;"	f	class:basic_string
unique	.\stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last) {$/;"	f
unique	.\stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last,$/;"	f
unique	.\stl_list.h	/^void list<T, Alloc>::unique() {$/;"	f	class:list
unique	.\stl_list.h	/^void list<T, Alloc>::unique(BinaryPredicate binary_pred) {$/;"	f	class:list
unique	.\stl_slist.h	/^void slist<T,Alloc>::unique()$/;"	f	class:slist
unique	.\stl_slist.h	/^void slist<T,Alloc>::unique(BinaryPredicate pred)$/;"	f	class:slist
unique_copy	.\stl_algo.h	/^inline OutputIterator unique_copy(InputIterator first, InputIterator last,$/;"	f
unitbuf	.\streambuf.h	/^	   unitbuf=_IO_UNITBUF, stdio=_IO_STDIO$/;"	e	enum:ios::__anon15
unref	.\stl_rope.h	/^	  static void unref(RopeBase* t) {}$/;"	f	class:rope
unref	.\stl_rope.h	/^	  static void unref(RopeBase* t)$/;"	f	class:rope
unref	.\stl_rope.h	/^	  static void unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
unref	.\stl_rope.h	/^	  static void unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
unref_nonnil	.\stl_rope.h	/^	  void unref_nonnil() {}$/;"	f	struct:__rope_RopeBase
unref_nonnil	.\stl_rope.h	/^	  void unref_nonnil()$/;"	f	struct:__rope_RopeBase
unset	.\streambuf.h	/^    void unset(state_value flag) { _state &= ~flag; }$/;"	f	class:ios
unsetf	.\streambuf.h	/^    fmtflags unsetf(fmtflags mask) {$/;"	f	class:ios
upper_bound	.\stl_algo.h	/^inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f
upper_bound	.\stl_map.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:map
upper_bound	.\stl_map.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:map
upper_bound	.\stl_multimap.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:multimap
upper_bound	.\stl_multimap.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:multimap
upper_bound	.\stl_multiset.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:multiset
upper_bound	.\stl_set.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:set
upper_bound	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {$/;"	f	class:rb_tree
upper_bound	.\stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {$/;"	f	class:rb_tree
uppercase	.\streambuf.h	/^	   uppercase=_IO_UPPERCASE, showpos=_IO_SHOWPOS,$/;"	e	enum:ios::__anon15
val	.\stl_function.h	/^  Result val;$/;"	m	struct:constant_binary_fun
val	.\stl_function.h	/^  Result val;$/;"	m	struct:constant_unary_fun
val	.\stl_function.h	/^  result_type val;$/;"	m	struct:constant_void_fun
val	.\stl_hashtable.h	/^  Value val;$/;"	m	struct:__hashtable_node
value	.\stl_function.h	/^  typename Operation::first_argument_type value;$/;"	m	class:binder1st
value	.\stl_function.h	/^  typename Operation::second_argument_type value;$/;"	m	class:binder2nd
value	.\stl_iterator.h	/^  T value;$/;"	m	class:istream_iterator
value	.\stl_tree.h	/^  static reference value(base_ptr x) { return ((link_type)x)->value_field; }$/;"	f	class:rb_tree
value	.\stl_tree.h	/^  static reference value(link_type x) { return x->value_field; }$/;"	f	class:rb_tree
value_comp	.\stl_map.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:map
value_comp	.\stl_multimap.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:multimap
value_comp	.\stl_multiset.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:multiset
value_comp	.\stl_set.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:set
value_compare	.\stl_map.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:map::value_compare
value_compare	.\stl_map.h	/^  class value_compare$/;"	c	class:map
value_compare	.\stl_multimap.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:multimap::value_compare
value_compare	.\stl_multimap.h	/^  class value_compare : public binary_function<value_type, value_type, bool> {$/;"	c	class:multimap
value_compare	.\stl_multiset.h	/^  typedef Compare value_compare;$/;"	t	class:multiset
value_compare	.\stl_set.h	/^  typedef Compare value_compare;$/;"	t	class:set
value_field	.\stl_tree.h	/^  Value value_field;$/;"	m	struct:__rb_tree_node
value_type	.\defalloc.h	/^    typedef T value_type;$/;"	t	class:allocator
value_type	.\std\bastring.h	/^  typedef typename traits::char_type	value_type;$/;"	t	class:basic_string
value_type	.\stl_bvector.h	/^  typedef bool value_type;$/;"	t	class:vector
value_type	.\stl_deque.h	/^  typedef T value_type;$/;"	t	class:__deque_iterator::deque
value_type	.\stl_deque.h	/^  typedef T value_type;$/;"	t	struct:__deque_iterator::__deque_iterator
value_type	.\stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator
value_type	.\stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }$/;"	f	struct:__deque_iterator
value_type	.\stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_map
value_type	.\stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multimap
value_type	.\stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multiset
value_type	.\stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_set
value_type	.\stl_hashtable.h	/^  typedef Value value_type;$/;"	t	class:hashtable
value_type	.\stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_const_iterator
value_type	.\stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_iterator
value_type	.\stl_hashtable.h	/^inline V* value_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
value_type	.\stl_hashtable.h	/^value_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
value_type	.\stl_iterator.h	/^          value_type;$/;"	t	class:reverse_iterator
value_type	.\stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_bidirectional_iterator
value_type	.\stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_iterator
value_type	.\stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:bidirectional_iterator
value_type	.\stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:iterator_traits
value_type	.\stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:random_access_iterator
value_type	.\stl_iterator.h	/^  typedef T                    value_type;$/;"	t	struct:forward_iterator
value_type	.\stl_iterator.h	/^  typedef T                  value_type;$/;"	t	class:istream_iterator
value_type	.\stl_iterator.h	/^  typedef T                  value_type;$/;"	t	struct:input_iterator
value_type	.\stl_iterator.h	/^  typedef T         value_type;$/;"	t	struct:iterator
value_type	.\stl_iterator.h	/^  typedef typename Iterator::value_type        value_type;$/;"	t	struct:iterator_traits
value_type	.\stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:back_insert_iterator
value_type	.\stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:front_insert_iterator
value_type	.\stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:insert_iterator
value_type	.\stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:ostream_iterator
value_type	.\stl_iterator.h	/^  typedef void                value_type;$/;"	t	struct:output_iterator
value_type	.\stl_iterator.h	/^inline T* value_type(const T*) { return (T*)(0); }$/;"	f
value_type	.\stl_iterator.h	/^inline T* value_type(const bidirectional_iterator<T, Distance>&) {$/;"	f
value_type	.\stl_iterator.h	/^inline T* value_type(const forward_iterator<T, Distance>&) {$/;"	f
value_type	.\stl_iterator.h	/^inline T* value_type(const input_iterator<T, Distance>&) {$/;"	f
value_type	.\stl_iterator.h	/^inline T* value_type(const istream_iterator<T, Distance>&) { return (T*) 0; }$/;"	f
value_type	.\stl_iterator.h	/^inline T* value_type(const random_access_iterator<T, Distance>&) {$/;"	f
value_type	.\stl_iterator.h	/^inline T* value_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f
value_type	.\stl_iterator.h	/^value_type(const Iterator&) {$/;"	f
value_type	.\stl_iterator.h	/^value_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f
value_type	.\stl_list.h	/^  typedef T value_type;$/;"	t	class:list
value_type	.\stl_list.h	/^  typedef T value_type;$/;"	t	struct:__list_iterator
value_type	.\stl_list.h	/^value_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f
value_type	.\stl_map.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:map
value_type	.\stl_multimap.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:multimap
value_type	.\stl_multiset.h	/^  typedef Key value_type;$/;"	t	class:multiset
value_type	.\stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:priority_queue
value_type	.\stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:queue
value_type	.\stl_raw_storage_iter.h	/^  typedef void                value_type;$/;"	t	class:raw_storage_iterator
value_type	.\stl_rope.h	/^	    typedef typename sequence::value_type value_type;$/;"	t	class:sequence_buffer
value_type	.\stl_rope.h	/^	typedef charT value_type;$/;"	t	class:rope
value_type	.\stl_set.h	/^  typedef Key value_type;$/;"	t	class:set
value_type	.\stl_slist.h	/^  typedef T value_type;$/;"	t	class:slist
value_type	.\stl_slist.h	/^  typedef T value_type;$/;"	t	struct:__slist_iterator
value_type	.\stl_slist.h	/^value_type(const __slist_iterator<T, Ref, Ptr>&) {$/;"	f
value_type	.\stl_stack.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:stack
value_type	.\stl_tree.h	/^  typedef Value value_type;$/;"	t	class:rb_tree
value_type	.\stl_tree.h	/^  typedef Value value_type;$/;"	t	struct:__rb_tree_iterator
value_type	.\stl_tree.h	/^inline Value* value_type(const __rb_tree_iterator<Value, Ref, Ptr>&) {$/;"	f
value_type	.\stl_vector.h	/^  typedef T value_type;$/;"	t	class:vector
vector	.\stl_bvector.h	/^template<class Alloc> class vector<bool, Alloc>$/;"	c
vector	.\stl_vector.h	/^  explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector(InputIterator first, InputIterator last) :$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector(const vector<T, Alloc>& x) {$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector(const_iterator first, const_iterator last) {$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	.\stl_vector.h	/^  vector(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	.\stl_vector.h	/^class vector {$/;"	c
vfprintf	.\iostdio.h	93;"	d
void_pointer	.\stl_list.h	/^  typedef void* void_pointer;$/;"	t	class:list
void_pointer	.\stl_list.h	/^  typedef void* void_pointer;$/;"	t	struct:__list_node
void_pointer	.\stl_tree.h	/^  typedef void* void_pointer;$/;"	t	class:rb_tree
vprintf	.\iostdio.h	94;"	d
vsprintf	.\iostdio.h	95;"	d
vtable	.\libio.h	/^  const void *vtable;$/;"	m	struct:_IO_cookie_file
vtable	.\libioP.h	/^  const struct _IO_jump_t *vtable;$/;"	m	struct:_IO_FILE_plus	typeref:struct:_IO_FILE_plus::_IO_jump_t
width	.\streambuf.h	/^    int width() const { return _width; }$/;"	f	class:ios
width	.\streambuf.h	/^    int width(int val) { int save = _width; _width = val; return save; }$/;"	f	class:ios
write	.\iostream.h	/^    ostream& write(const signed char *s, streamsize n)$/;"	f	class:ostream
write	.\iostream.h	/^    ostream& write(const unsigned char *s, streamsize n)$/;"	f	class:ostream
write	.\iostream.h	/^    ostream& write(const void *s, streamsize n)$/;"	f	class:ostream
write	.\libio.h	/^  _IO_ssize_t (*write) __P ((struct _IO_FILE *, const void *, _IO_ssize_t));$/;"	m	struct:__anon1
write	.\stl_rope.h	/^	sequence_buffer& write(value_type *s, size_t len)$/;"	f	class:sequence_buffer
wrope	.\stl_rope.h	/^typedef rope<wchar_t, __ALLOC> wrope;$/;"	t
xchain	.\streambuf.h	/^    _IO_FILE*& xchain() { return _chain; }$/;"	f	struct:streambuf
xflags	.\streambuf.h	/^    int xflags() { return _IO_file_flags; }$/;"	f	struct:streambuf
xflags	.\streambuf.h	/^    int xflags(int f) {int fl = _IO_file_flags; _IO_file_flags = f; return fl;}$/;"	f	struct:streambuf
xput_char	.\streambuf.h	/^    void xput_char(char c) { *_IO_write_ptr++ = c; }$/;"	f	struct:streambuf
xsetflags	.\streambuf.h	/^    void xsetflags(int f) { _IO_file_flags |= f; }$/;"	f	struct:streambuf
xsetflags	.\streambuf.h	/^    void xsetflags(int f, int mask)$/;"	f	struct:streambuf
~__BVECTOR	.\stl_bvector.h	/^  ~__BVECTOR() { deallocate(); }$/;"	f	class:vector
~__rope_RopeSubstring	.\stl_rope.h	/^    virtual ~__rope_RopeSubstring() {}$/;"	f	struct:__rope_RopeSubstring
~__rope_char_consumer	.\stl_rope.h	/^	virtual ~__rope_char_consumer() {};$/;"	f	class:__rope_char_consumer
~__rope_find_char_char_consumer	.\ropeimpl.h	/^	~__rope_find_char_char_consumer() {}$/;"	f	class:__rope_find_char_char_consumer
~__rope_flatten_char_consumer	.\ropeimpl.h	/^	~__rope_flatten_char_consumer() {}$/;"	f	class:__rope_flatten_char_consumer
~__rope_insert_char_consumer	.\ropeimpl.h	/^	~__rope_insert_char_consumer() { };$/;"	f	class:__rope_insert_char_consumer
~__rope_iterator	.\stl_rope.h	/^    ~__rope_iterator() {$/;"	f	class:__rope_iterator
~__rope_self_destruct_ptr	.\stl_rope.h	/^    ~__rope_self_destruct_ptr() { __rope_RopeBase<charT,Alloc>::unref(ptr); }$/;"	f	struct:__rope_self_destruct_ptr
~basic_string	.\std\bastring.h	/^  ~basic_string ()$/;"	f	class:basic_string
~char_producer	.\stl_rope.h	/^	virtual ~char_producer() {};$/;"	f	class:char_producer
~deque	.\stl_deque.h	/^  ~deque() {$/;"	f	class:__deque_iterator::deque
~hashtable	.\stl_hashtable.h	/^  ~hashtable() { clear(); }$/;"	f	class:hashtable
~ios	.\streambuf.h	/^inline ios::~ios() {$/;"	f	class:ios
~list	.\stl_list.h	/^  ~list() {$/;"	f	class:list
~lock	.\stl_alloc.h	/^            ~lock() { __NODE_ALLOCATOR_UNLOCK; }$/;"	f	class:__default_alloc_template::lock
~rb_tree	.\stl_tree.h	/^  ~rb_tree() {$/;"	f	class:rb_tree
~rope	.\stl_rope.h	/^	~rope()$/;"	f	class:rope
~sequence_buffer	.\stl_rope.h	/^	~sequence_buffer() { flush(); }$/;"	f	class:sequence_buffer
~slist	.\stl_slist.h	/^  ~slist() { clear(); }$/;"	f	class:slist
~temporary_buffer	.\stl_tempbuf.h	/^  ~temporary_buffer() {  $/;"	f	class:temporary_buffer
~vector	.\stl_vector.h	/^  ~vector() { $/;"	f	class:vector
