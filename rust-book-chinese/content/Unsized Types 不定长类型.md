# 不定长类型

> [unsized-types.md](https://github.com/rust-lang/book/blob/master/first-edition/src/unsized-types.md)
> <br>
> commit ccb1d87d6faa9ff528d22b96595a0e2cbb16c0f2

大部分类型有一个特定的大小，以字节为单位，它们在编译时是已知的。例如，一个`i32`是 32 位大，或者 4 个字节。然而，有些类型有益于表达，却没有一个定义的大小。它们叫做“不定长”或者“动态大小”类型。一个例子是`[T]`。这个类型代表一个特定数量`t`的序列。不过我们并不知道有多少，所以大小是未知的。

Rust 知道几个这样的类型，不过它们有一些限制。这有三个：

1. 我们只能通过指针操作一个不定长类型的实例。`&[T]`刚好能正常工作，不过`[T]`不行。一个` &[T]`能正常工作，不过一个`[T]`不行。
2. 变量和参数不能拥有动态大小类型。
3. 只有一个`struct`的最后一个字段可能拥有一个动态大小类型；其它字段则不可以拥有动态大小类型。枚举变量不可以用动态大小类型作为数据。

所以为什么这很重要？好吧，因为`[T]`只能用在一个指针之后，如果我们没有对不定长类型的语言支持，它将不可能这么写：

```rust
impl Foo for str {
```

或者

```rust
impl<T> Foo for [T] {
```

相反，你将不得不这么写：

```rust
impl Foo for &str {
```

意味深长的是，这个实现将只能用于[引用](References and Borrowing 引用和借用.md)，并且不能用于其它类型的指针。通过`impl for str`，所有指针，包括（在一些地方，这里会有bug需要修复）用户自定义的智能指针，可以使用这个`impl`。

## `?Sized`

如果你想要写一个接受动态大小类型的函数，你可以使用这个特殊的 bound 语法，`?Sized`：

```rust
struct Foo<T: ?Sized> {
    f: T,
}
```

这个`?Sized`，读作“`T`可能是`Sized`的”，允许我们匹配固定长度和不定长度的类型。所有泛型类型参数隐式包含`Sized` bound，所以`?Sized`可以被用来移除这个隐式 bound。
